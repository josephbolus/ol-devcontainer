Directory structure:
└── devcontainers-devcontainers.github.io/
    ├── README.md
    ├── 404.html
    ├── _config.yml
    ├── CNAME
    ├── CODEOWNERS
    ├── collections.html
    ├── contributing.md
    ├── features.html
    ├── Gemfile
    ├── guides.html
    ├── index.html
    ├── LICENSE
    ├── overview.md
    ├── SECURITY.md
    ├── supporting.md
    ├── templates.html
    ├── _data/
    │   └── specification-toc.yml
    ├── _implementors/
    │   ├── contributing.md
    │   ├── features-distribution.md
    │   ├── features.md
    │   ├── json_reference.md
    │   ├── json_schema.md
    │   ├── reference.md
    │   ├── spec.md
    │   ├── templates-distribution.md
    │   └── templates.md
    ├── _includes/
    │   ├── cookie_notice.html
    │   ├── footer.html
    │   ├── head.html
    │   ├── js_files.html
    │   └── topnav.html
    ├── _layouts/
    │   ├── default.html
    │   ├── implementors.html
    │   ├── post.html
    │   ├── singlePage.html
    │   ├── specification.html
    │   └── table.html
    ├── _posts/
    │   ├── 2022-11-01-author-a-feature.md
    │   ├── 2022-12-16-dockerfile.md
    │   ├── 2023-02-15-gitlab-ci.md
    │   ├── 2023-06-14-feature-authoring-best-practices.md
    │   ├── 2023-08-22-prebuild.md
    │   └── 2024-01-23-dependabot.md
    ├── css/
    │   └── main.scss
    ├── js/
    │   └── page.js
    ├── static/
    │   └── .keep
    ├── .codesandbox/
    │   └── tasks.json
    ├── .devcontainer/
    │   ├── devcontainer.json
    │   └── fetch-index.sh
    └── .github/
        ├── pull_request_template.md
        └── workflows/
            └── publish.yml

================================================
FILE: README.md
================================================
# Development Containers Website

This repo holds the website for the [Development Containers Specification](https://github.com/devcontainers/spec).

You may view the site at [containers.dev](https://containers.dev).

## Building

If you'd like to build and preview the site yourself, we make it as smooth as possible through a dev container in this repo!

### Dev container

You may build GitHub Pages sites with [Jekyll](https://jekyllrb.com/), which is a Ruby gem. You could manually install these tools on your machine, or you can easily get started with the setup you already need through a dev container!

You may review this repo's dev container in the [`.devcontainer`](https://github.com/devcontainers/containers.dev/tree/gh-pages/.devcontainer) folder.

It is from this [Jekyll Dev Container Template](https://github.com/devcontainers/templates/tree/main/src/jekyll).

### Steps to build and run

* Clone or open this repo in the dev container-supporting editor of your choosing.
     * You may review supporting tools and services [here](https://containers.dev/supporting).
* Reopen this repo in the dev container, so that the container builds and you may develop inside it using the included tools. 
* Once the dev container finishes building, execute the following command in your dev container to start the site: `bundle exec jekyll serve`
* Check out the site! http://localhost:4000/containers.dev/

## Feedback and contributing

If you'd like to provide feedback on or contribute to the dev containers website, please feel free to open an issue or PR in this repo.

For issues on and contributions to the dev container specification itself, please visit the [Dev Containers Spec repo](https://github.com/devcontainers/spec).

## License

License for this repository: https://github.com/devcontainers/containers.dev/blob/gh-pages/LICENSE.



================================================
FILE: 404.html
================================================
---
layout: default
---

<div class="container text-center">
    <p>The page you are looking for cannot be found.</p>
    <h2>404</h2>
</div>


================================================
FILE: _config.yml
================================================
# Site settings
title: Development containers
description: >
  Development containers documentation and specification page.

# baseurl: / # the subpath of your site, e.g. /blog/
url: https://devcontainers.github.io # the base hostname & protocol for your site
git_address: https://github.com/devcontainers/devcontainers.github.io
git_edit_address: https://github.com/devcontainers/devcontainers.github.io/settings/pages/blob/gh-pages
theme_color: 2753E3

# Build settings
markdown: kramdown
highlighter: rouge

plugins:
  - github-pages
  - jemoji
  - jekyll-feed


exclude:
  - Gemfile
  - Gemfile.lock
  - .idea/
  - .gitignore
  - README.md
  - resources

timezone: Europe/Zurich

defaults:
- scope:
    path: _posts
    type: posts
  values:
    layout: post
    sectionid: guide

- scope:
    path: _docs
    type: docs
  values:
    layout: docs
    sectionid: docs
    seo:
      type: "WebPage"

- scope:
    path: _implementors
    type: implementors
  values:
    layout: implementors
    sectionid: implementors

collections:
  docs:
    permalink: /:collection/:path/
    output: true
  posts:
    permalink: /guide/:title
    output: true
  implementors:
    permalink: /:collection/:path/
    output: true



================================================
FILE: CNAME
================================================
containers.dev


================================================
FILE: CODEOWNERS
================================================
* @devcontainers/maintainers



================================================
FILE: collections.html
================================================
---
title: Collections
layout: table
sectionid: collection-index
---

<h1 style="margin-left: auto;margin-right: auto;">Collections</h1>
<p style="margin-left: auto;margin-right: auto;">
    This list below contains pointers to official and community-contributed dev container assets, including Features and
    Templates.
    Collections on this list are continuously crawled for liveness, and can be presented in UX of spec supporting tools
    (i.e. it will be presented in the GitHub Codespaces and VS Code Dev Containers UX).
</p>

<p>
    To add your own collection to this list, please create a PR editing <a
        href="https://github.com/devcontainers/devcontainers.github.io/blob/gh-pages/_data/collection-index.yml">this
        yaml file</a>.
</p>

<input type="text" id="searchInput" placeholder="Search">

<br>
<br>

<table id="collectionTable" class="tg">
    <tr>
        <td class="tg-0lax"><b>Name</b></td>
        <td class="tg-0lax"><b>Maintainer</b></td>
        <td class="tg-0lax"><b>Repository</b></td>
    </tr>

    {% for c in site.data.collection-index %}
    <tr>
        <td class="tg-0lax">{{ c.name }}</td>
        <td class="tg-0lax"><a rel="nofollow" href="{{ c.contact | strip_html  }}">{{ c.maintainer | strip_html }}</a>
        </td>
        <td class="tg-0lax"><a rel="nofollow" href="{{ c.repository | strip_html  }}">{{ c.repository | strip_html
                }}</a>
        </td>
    </tr>
    {% endfor %}
</table>

<script>
    const searchInput = document.getElementById('searchInput');
    const collectionTable = document.getElementById('collectionTable');
    const rows = collectionTable.getElementsByTagName('tr');

    searchInput.addEventListener('input', function () {
        const searchValue = searchInput.value.toLowerCase();

        for (let i = 1; i < rows.length; i++) {
            const name = rows[i].getElementsByTagName('td')[0].textContent.toLowerCase();
            const maintainer = rows[i].getElementsByTagName('td')[1].textContent.toLowerCase();
            const repository = rows[i].getElementsByTagName('td')[2].textContent.toLowerCase();

            if (name.includes(searchValue) || maintainer.includes(searchValue) || repository.includes(searchValue)) {
                rows[i].style.display = '';
            } else {
                rows[i].style.display = 'none';
            }
        }
    });
</script>


================================================
FILE: contributing.md
================================================
# How to Contribute to the Dev Container Specification

We're excited for your contributions to the Dev Container Specification! This document outlines how you can get involved. We also welcome you to join our [community Slack channel](https://aka.ms/dev-container-community).

## Spec contribution approaches

If you'd like to contribute a change or addition to the spec, you may follow the guidance below:
- Propose the change via an [issue](https://github.com/devcontainers/spec/issues) in this repository. Try to get early feedback before spending too much effort formalizing it.
- More formally document the proposed change in terms of properties and their semantics. Look to format your proposal like our [devcontainer.json reference](https://aka.ms/devcontainer.json).

Here is a sample:

| Property | Type | Description |
|----------|------|-------------|
| `image` | string | **Required** when [using an image](/docs/remote/create-dev-container.md#using-an-image-or-dockerfile). The name of an image in a container registry ([DockerHub](https://hub.docker.com), [GitHub Container Registry](https://docs.github.com/packages/guides/about-github-container-registry), [Azure Container Registry](https://azure.microsoft.com/services/container-registry/)) that VS Code and other `devcontainer.json` supporting services / tools should use to create the dev container. |

- PRs to the [schema](https://github.com/microsoft/vscode/blob/main/extensions/configuration-editing/schemas/devContainer.schema.src.json), i.e code or shell scripts demonstrating approaches for implementation.

Once there is discussion on your proposal, please also open and link a PR to update the [devcontainer.json reference doc](https://aka.ms/devcontainer.json). When your proposal is merged, the docs will be kept up-to-date with the latest spec.

### Contributing tool-specific support

Tool-specific properties are contained in namespaces in the `"customizations"` property. For instance, VS Code specific properties are formated as:

```bash
// Configure tool-specific properties.
"customizations": {
     // Configure properties specific to VS Code.
     "vscode": {
          // Set *default* container specific settings.json values on container create.
          "settings": {},
			
          // Additional VS Code specific properties...
     }
},
```

You may propose adding a new namespace for a specific tool, and any properties specific to that tool.

## Formatting Guidelines

When contributing an official doc or referencing dev containers in your projects, please consider the following guidelines:

- Refer to the spec as the "Development Container Specification"
     - All capital letters
     - Singular "Container" rather than plural "Containers"
- The term "dev container" shouldn't be capitalized on its own
     - It should only be capitalized when referring to an official tool title, like the VS Code Dev Containers extension 
- Signify `devcontainer.json` is a file type through backticks 
- Features and Templates should always be capitalized
- Refer to the CLI as the "Dev Container CLI" (note the caps)
- Use bolding for emphasis sprinkled throughout sections, rather than try to use it to always bold certain terms

## Review process

We use the following [labels](https://github.com/devcontainers/spec/labels) in the spec repo:

- `proposal`: Issues under discussion, still collecting feedback.
- `finalization`: Proposals we intend to make part of the spec.

[Milestones](https://github.com/devcontainers/spec/milestones) use a "month year" pattern (i.e. January 2022). If a finalized proposal is added to a milestone, it is intended to be merged during that milestone.

## Community Engagement
There are several additional options to engage with the dev container community, such as asking questions, providing feedback, or engaging on how your team may use or contribute to dev containers:
- [GitHub Discussions](https://github.com/devcontainers/spec/discussions): This is a great opportunity to connect with the community and maintainers of this project, without the requirement of contributing a change to the actual spec (which we see more in issues and PRs)
- [Community Slack channel](https://aka.ms/dev-container-community): This is a great opportunity to connect with the community and maintainers
- You can always check out the issues and PRs (and contribute new ones) across the repos in the [Dev Containers GitHub org](https://github.com/devcontainers) too!
- Community collections: You can contribute your own [Templates](https://containers.dev/implementors/templates-distribution/#distribution) and [Features](https://containers.dev/implementors/features-distribution/#distribution) to our [community index](https://containers.dev/collections)!


================================================
FILE: features.html
================================================
---
title: Features
layout: table
sectionid: collection-index-features
---

<h1 style="margin-left: auto;margin-right: auto;">Available Dev Container Features</h1>
<p style="margin-left: auto;margin-right: auto;">
    This table contains all official and community-supported <a href="implementors/features/">Dev Container Features</a>
    known at the time of crawling <a href="collections">each registered collection</a>. This list is continuously
    updated with the latest available feature information. See the <a
        href="https://github.com/devcontainers/feature-template">
        Feature quick start repository</a> to add your own!
    <br><br>
    <a href="implementors/features#referencing-a-feature">Referencing a Feature</a> below can be done in the "features"
    section of a devcontainer.json.
    <br><br>
    Please note that if you need to report a Feature, you should do so through the registry hosting the Feature.
</p>

<p>
    To add your own collection to this list, please create a PR editing <a
        href="https://github.com/devcontainers/devcontainers.github.io/blob/gh-pages/_data/collection-index.yml">this
        yaml file</a>.
</p>

<input type="text" id="searchInput" placeholder="Search">
<br>
<br>

<table id="collectionTable" class="tg">
    <tr>
        <td class="tg-0lax"><b>Feature Name</b></b></td>
        <td class="tg-0lax"><b>Maintainer</b></td>
        <td class="tg-0lax"><b>Reference</b></td>
        <td class="tg-0lax"><b>Latest Version</b></td>
    </tr>
    
    {% for c in site.data.devcontainer-index.collections %}
    {% for f in c.features %}
    {% if f.deprecated != true %}
    <tr>
        <td class="tg-0lax"><a rel="nofollow" href="{{ f.documentationURL | strip_html }}">{{ f.name | strip_html }}</a>
        </td>
        <td class="tg-0lax">{{ c.sourceInformation.maintainer | strip_html }}</td>
        <td class="tg-0lax"><code>{{ f.id | strip_html  }}:{{ f.majorVersion | strip_html }}</code></td>
        <td class="tg-0lax"><code>{{ f.version | strip_html  }}</code></td>
    </tr>
    {% endif %}
    {% endfor %}
    
    {% endfor %}
</table>

<script>
    const searchInput = document.getElementById('searchInput');
    const collectionTable = document.getElementById('collectionTable');
    const rows = collectionTable.getElementsByTagName('tr');

    searchInput.addEventListener('input', function () {
        const searchValue = searchInput.value.toLowerCase();

        for (let i = 1; i < rows.length; i++) {
            const name = rows[i].getElementsByTagName('td')[0].textContent.toLowerCase();
            const maintainer = rows[i].getElementsByTagName('td')[1].textContent.toLowerCase();
            const repository = rows[i].getElementsByTagName('td')[2].textContent.toLowerCase();

            if (name.includes(searchValue) || maintainer.includes(searchValue) || repository.includes(searchValue)) {
                rows[i].style.display = '';
            } else {
                rows[i].style.display = 'none';
            }
        }
    });
</script>


================================================
FILE: Gemfile
================================================
source "https://rubygems.org"
ruby RUBY_VERSION

gem "jekyll", "3.9.3"

# to use GitHub Pages
# gem "github-pages", group: :jekyll_plugins

# If you have any plugins, put them here!
group :jekyll_plugins do
   gem "jemoji"
   gem "github-pages"
   gem "jekyll-remote-theme"
   gem "jekyll-feed"
end

# Windows does not include zoneinfo files, so bundle the tzinfo-data gem
gem 'tzinfo-data', platforms: [:mingw, :mswin, :x64_mingw, :jruby]

gem 'webrick', '~> 1.7'


================================================
FILE: guides.html
================================================
---
layout: singlePage
title: Dev Container Guides
---

{% for post in site.posts %}
  <p>
    <h3><a href="{{ post.url }}">{{ post.title }}</a></h3>
    <p>{{ post.date | date_to_string }}</a></p>

    {{ post.excerpt }}
  </p>
{% endfor %}



================================================
FILE: index.html
================================================
---
layout: default
---

<!-- Place this tag in your head or just before your close body tag. -->
<script async defer src="https://buttons.github.io/buttons.js"></script>

<div class="header-container bg-primary jumbotron">
    <div class="container">
        <div class="intro">
            <h1>Development Containers</h1>
        </div>
        <p class="intro-text">
            An open specification for enriching containers with development specific content and settings.
        </p>

        <br />
        <div class="intro-text">
            <a class="github-button" href="https://github.com/devcontainers/spec" data-size="large"
                data-icon="octicon-star" data-show-count="true" tabindex="0"
                aria-label="Star devcontainers/spec on GitHub">Star</a>
        </div>
    </div>
</div>

<div class="container">
    <div class="row align-items-center">
        <div class="col-lg-7" role="navigation" aria-label="Main">
            <h2 class="header-light regular-pad">What are Development Containers?</h2>

            <p>A development container (or dev container for short) allows you to use a container as a full-featured
                development environment. It can be used to run an application, to separate tools, libraries, or runtimes
                needed for working with a codebase, and to aid in continuous integration and testing. Dev containers can
                be run locally or remotely, in a private or public cloud, in a variety of <a href="./supporting"
                    aria-label="Supporting tools">supporting tools and editors</a>.</p>

            <p>The Development Container Specification seeks to find ways to enrich existing formats with common
                development specific settings, tools, and configuration while still providing a simplified,
                un-orchestrated single container option – so that they can be used as coding environments or for
                continuous integration and testing. Beyond the specification's core metadata, the spec also enables
                developers to quickly share and reuse container setup steps through <a href="./features"
                    aria-label="See the Dev Container Features spec">Features</a> and <a href="./templates"
                    aria-label="See the Dev Container Templates spec">Templates</a>. </p>

        </div>
        <div class="col-lg-5">
            <div class="row align-items-center">
                <div class="col-lg-12">
                    <img alt="Go devcontainer.json config file" src="img/goConfig.png" class="img-fluid rounded" />
                    <p class="text-left"><i>Use or create dev container definitions for a multitude of tech stacks and
                            tools.</i></p>
                </div>
            </div>
        </div>

        <hr>

        <div class="row more-info">
            <div class="col-lg-4">
                <h1 class="text-center"><img src="img/cogs.png" alt="Gear cogs"></h1>
                <a href='{{ "/overview" | prepend: site.baseurl }}'>
                    <h3 class="text-center">Overview</h3>
                </a>
                <p>
                    More information about the Development Container Specification.
                </p>
            </div>
            <div class="col-lg-4">
                <h1 class="text-center"><img src="img/book.png" alt="Gear cogs"></h1>
                {% assign sorted = site.implementors | sort: 'index' %}
                <a href="{{ sorted.first.url | prepend: site.baseurl }}">
                    <h3 class="text-center">Specification</h3>
                </a>
                <p>
                    Check out the latest reference implementation and schemas.
                </p>
            </div>
            <div class="col-lg-4">
                <h1 class="text-center"><img src="img/branch.png" alt="Gear cogs"></h1>
                <a href='{{ "/supporting" | prepend: site.baseurl }}'>
                    <h3 class="text-center">Supporting Tools</h3>
                </a>
                <p>
                    A variety of tools and services support this standard.
                </p>
            </div>
        </div>
    </div>


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) Microsoft Corporation.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: overview.md
================================================
---
title: Overview
layout: singlePage
sectionid: overview
---

## <a href="#overview" name="overview" class="anchor"> What are development containers? </a>
As containerizing production workloads becomes commonplace, more developers are using containers for scenarios beyond deployment, including continuous integration, test automation, and even full-featured coding environments.

Each scenario’s needs can vary between simple single container environments to complex, orchestrated multi-container setups. Rather than attempting to create another orchestrator format, the Development Container Specification (or Dev Container Spec for short) seeks to find ways to enrich existing formats with metadata for common development specific settings, tools, and configuration.

### <a href="#metadata-format" name="metadata-format" class="anchor">  A structured metadata format </a>

Like the [Language Server Protocol](https://microsoft.github.io/language-server-protocol/) before it, the first format in the specification, [`devcontainer.json`](implementors/json_reference), was born out of necessity. It is a structured JSON with Comments (jsonc) metadata format that tools can use to store any needed configuration required to develop inside of local or cloud-based containerized coding. 

Since the spec was initally published, dev container metadata can now be stored in [image labels](../implementors/spec/#image-metadata) and in reusable chunks of metadata and install scripts known as [Dev Container Features](../features). We envision that this same structured data can be embedded in other formats -- all while retaining a common object model for consistent processing.

### <a href="#Development-vs-production" name="Development-vs-production" class="anchor"> Development vs production </a>

A development container defines an environment in which you develop your application before you are ready to deploy. While deployment and development containers may resemble one another, you may not want to include tools in a deployment image that you use during development.

<img alt="Diagram of inner and outer loop of container-based development" src="img/dev-container-stages.png"/>

### <a href="#build-and-test" name="build-and-test" class="anchor">  Build and test </a>

Beyond repeatable setup, these same development containers provide consistency to avoid environment specific problems across developers and centralized build and test automation services. The open-source [CLI reference implementation](https://github.com/devcontainers/cli) can either be used directly or integrated into product experience to use the structured metadata to deliver these benefits. It currently supports integrating with Docker Compose and a simplified, un-orchestrated single container option – so that they can be used as coding environments or for continuous integration and testing.

A GitHub Action and an Azure DevOps Task are available in [devcontainers/ci](https://github.com/devcontainers/ci) for running a repository's dev container in continuous integration (CI) builds. This allows you to reuse the same setup that you are using for local development to also build and test your code in CI.

### <a href="#supporting" name="supporting" class="anchor">  Supporting tools </a>

You can [learn more](/supporting.md) about how other tools and services support the Development Container Specification.



================================================
FILE: SECURITY.md
================================================
<!-- BEGIN MICROSOFT SECURITY.MD V0.0.5 BLOCK -->

## Security

Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet), [Xamarin](https://github.com/xamarin), and [our GitHub organizations](https://opensource.microsoft.com/).

If you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc751383(v=technet.10)), please report it to us as described below.

## Reporting Security Issues

**Please do not report security vulnerabilities through public GitHub issues.**

Instead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://msrc.microsoft.com/create-report).

If you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://www.microsoft.com/en-us/msrc/pgp-key-msrc).

You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://www.microsoft.com/msrc). 

Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:

  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)
  * Full paths of source file(s) related to the manifestation of the issue
  * The location of the affected source code (tag/branch/commit or direct URL)
  * Any special configuration required to reproduce the issue
  * Step-by-step instructions to reproduce the issue
  * Proof-of-concept or exploit code (if possible)
  * Impact of the issue, including how an attacker might exploit the issue

This information will help us triage your report more quickly.

If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://microsoft.com/msrc/bounty) page for more details about our active programs.

## Preferred Languages

We prefer all communications to be in English.

## Policy

Microsoft follows the principle of [Coordinated Vulnerability Disclosure](https://www.microsoft.com/en-us/msrc/cvd).

<!-- END MICROSOFT SECURITY.MD BLOCK -->


================================================
FILE: supporting.md
================================================
---
title: Supporting tools and services
layout: singlePage
sectionid: supporting
---

This page outlines tools and services that currently support the Development Container Specification, including the `devcontainer.json` format. A `devcontainer.json` file in your project tells tools and services that support the dev container spec how to access (or create) a dev container with a well-defined tool and runtime stack.

While most [dev container properties](implementors/json_reference) apply to any `devcontainer.json` supporting tool or service, a few are specific to certain tools, which are outlined below.

## <a href="#editors" name="editors" class="anchor"> Editors </a>

### <a href="#visual-studio-code" name="visual-studio-code" class="anchor"> Visual Studio Code </a>

Visual Studio Code specific properties go under `vscode` inside `customizations`.

```json
"customizations": {
		// Configure properties specific to VS Code.
		"vscode": {
			// Set *default* container specific settings.json values on container create.
			"settings": {},
			"extensions": [],
		}
}
```

| Property | Type  | Description |
|:------------------|:------------|:------------|
| `extensions` | array | An array of extension IDs that specify the extensions that should be installed inside the container when it is created. Defaults to `[]`. |
| `settings` | object | Adds default `settings.json` values into a container/machine specific settings file. Defaults to `{}`. |
{: .table .table-bordered}

Please note that the [Dev Containers](#dev-containers) extension and [GitHub Codespaces](#github-codespaces) support these VS Code properties.

### <a href="#visual-studio" name="visual-studio" class="anchor"> Visual Studio </a>

Visual Studio added dev container support in Visual Studio 2022 17.4 for C++ projects using CMake Presets. It is part of the Linux and embedded development with C++ workload, so make sure it is selected in your VS installation. Visual Studio manages the lifecycle of dev containers it uses as you work, but it treats them as remote targets in a similar way to other Linux or WSL targets.

You may learn more in the [announcement blog post](https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/).

### <a href="#intellij" name="intellij" class="anchor"> IntelliJ IDEA </a>

IntelliJ IDEA has early support dev containers that can be run remotely via an SSH connection or locally using Docker.

You may learn more in the [announcement blog post](https://blog.jetbrains.com/idea/2023/06/intellij-idea-2023-2-eap-6/#SupportforDevContainers).

## <a href="#tools" name="tools" class="anchor"> Tools </a>

### <a href="#devcontainer-cli" name="devcontainer-cli" class="anchor"> Dev Container CLI </a>

The Dev Container Command Line Interface (CLI) is a reference implementation for the Dev Container Spec. It is in development in the [devcontainers/cli](https://github.com/devcontainers/cli) repo. It is intended both for use directly and by tools or services that want to support the spec.

The CLI can take a `devcontainer.json` and create and configure a dev container from it. It allows for prebuilding dev container configurations using a CI or DevOps product like GitHub Actions. It can detect and include dev container features and apply them at container runtime, and run [lifecycle scripts](implementors/json_reference/#lifecycle-scripts) like `postCreateCommand`, providing more power than a plain `docker build` and `docker run`.

#### <a href="#dev-containers-cli" name="dev-containers-cli" class="anchor"> VS Code extension CLI </a>

The [VS Code Dev Containers extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) includes a variation of the Dev Container CLI that adds the ability use the command line to open a dev container in VS Code. It is also automatically updated when the extension updates. 

Press <kbd>cmd/ctrl</kbd>+<kbd>shift</kbd>+<kbd>p</kbd> or <kbd>F1</kbd> and select the **Dev Containers: Install devcontainer CLI** command to install it.

### <a href="#cachix-devenv" name="cachix-devenv" class="anchor"> Cachix devenv </a>

Cachix's **[devenv](https://devenv.sh/)** now supports automatically generating a `.devcontainer.json` file. This gives you a more convenient and consistent way to use [Nix](https://nixos.org/) with any Dev Container Spec supporting tool or service!

See [devenv documentation](https://devenv.sh/integrations/codespaces-devcontainer/) for detais. 

### <a href="#jetify-devbox" name="jetify-devbox" class="anchor"> Jetify Devbox </a>

[Jetify](https://jetify.com) (formerly jetpack.io) is a [Nix](https://nixos.org/)-based service for deploying applications. [DevBox](https://www.jetify.com/devbox/) provides a way to use Nix to generate a development environment. [Jetify's VS Code extension](https://marketplace.visualstudio.com/items?itemName=jetpack-io.devbox) allows you to quickly take advantage of DevBox in any Dev Container Spec supporting tool or service. 

Press <kbd>cmd/ctrl</kbd>+<kbd>shift</kbd>+<kbd>p</kbd> or <kbd>F1</kbd> and select the **Generate Dev Container files** command to get started!

### <a href="#dev-containers" name="dev-containers" class="anchor"> VS Code Dev Containers extension </a>

The [Visual Studio Code Dev Containers extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) lets you use a [Docker container](https://docker.com) as a full-featured development environment. It allows you to open any folder inside (or mounted into) a container and take advantage of Visual Studio Code's full feature set. There is more information in the Dev Containers [documentation](https://code.visualstudio.com/docs/remote/containers).

> **Tip:** If you make a change to your dev container after having built and connected to it, be sure to run **Dev Containers: Rebuild Container** from the Command Palette (<kbd>cmd/ctrl</kbd>+<kbd>shift</kbd>+<kbd>p</kbd> or <kbd>F1</kbd>) to pick up any changes you make.

#### <a href="#product-specific-properties" name="product-specific-properties" class="anchor"> Product specific properties </a>

The Dev Containers extension implements the [VS Code properties](#visual-studio-code) specific properties.

#### <a href="#dev-containers-code-specific-limitations" name="dev-containers-specific-limitations" class="anchor"> Product specific limitations </a>

Some properties may also have certain limitations in the Dev Containers extension.

| Property or variable | Type  | Description |
|:------------------|:------------|:------------|
| `workspaceMount` | string | Not yet supported when using Clone Repository in Container Volume. |
| `workspaceFolder` | string | Not yet supported when using Clone Repository in Container Volume. |
| `${localWorkspaceFolder}`  | Any | Not yet supported when using Clone Repository in Container Volume. |
| `${localWorkspaceFolderBasename}` | Any | Not yet supported when using Clone Repository in Container Volume. |
{: .table .table-bordered}

## <a href="#services" name="services" class="anchor"> Services </a>

### <a href="#github-codespaces" name="github-codespaces" class="anchor"> GitHub Codespaces </a>

A [codespace](https://docs.github.com/en/codespaces/overview) is a development environment that's hosted in the cloud. Codespaces run on a variety of VM-based compute options hosted by GitHub.com, which you can configure from 2 core machines up to 32 core machines. You can connect to your codespaces from the browser or locally using Visual Studio Code.

> **Tip:** If you make a change to your dev container after having built and connected to your codespace, be sure to run **Codespaces: Rebuild Container** from the Command Palette (<kbd>cmd/ctrl</kbd>+<kbd>shift</kbd>+<kbd>p</kbd> or <kbd>F1</kbd>) to pick up any changes you make.

#### <a href="#codespaces-specific-properties" name="codespaces-specific-properties" class="anchor"> Product specific properties </a>
GitHub Codespaces works with a growing number of tools and, where applicable, their `devcontainer.json` properties. For example, connecting the Codespaces web editor or VS Code enables the use of [VS Code properties](#visual-studio-code).

If your Codespaces project needs additional permissions for other repositories, you can configure this through the `repositories` and `permissions` properties. You may learn more about this in the [Codespaces documentation](https://docs.github.com/en/codespaces/managing-your-codespaces/managing-repository-access-for-your-codespaces). As with other tools, Codespaces specific properties are placed within a `codespaces` namespace inside the `customizations` property.

```json
"customizations": {
	// Configure properties specific to Codespaces.
	"codespaces": {
		"repositories": {
			"my_org/my_repo": {
				"permissions": {
					"issues": "write"
				}
			}
		}
	}
}
```

You can customize which files are initially opened when the codespace is created:
```json
"customizations": {
	// Configure properties specific to Codespaces.
	"codespaces": {
		"openFiles": [
			"README"
			"src/index.js"
		]
	}
}
```

The paths are relative to the root of the repository. They will be opened in order, with the first file activated.

> **Note** that currently Codespaces reads these properties from `devcontainer.json`, not image metadata.

#### <a href="#codespaces-specific-limitations" name="codespaces-specific-limitations" class="anchor"> Product specific limitations </a>

Some properties may apply differently to codespaces.

| Property or variable | Type | Description |
|----------|---------|----------------------|
| `mounts` | array | Codespaces ignores "bind" mounts with the exception of the Docker socket. Volume mounts are still allowed.|
| `forwardPorts` | array | Codespaces does not yet support the `"host:port"` variation of this property. |
| `portsAttributes` | object | Codespaces does not yet support the `"host:port"` variation of this property.|
| `shutdownAction` | enum | Does not apply to Codespaces. |
| `${localEnv:VARIABLE_NAME}` | Any | For Codespaces, the host is in the cloud rather than your local machine.|
| `customizations.codespaces` | object | Codespaces reads this property from devcontainer.json, not image metadata. |
| `hostRequirements` | object | Codespaces reads this property from devcontainer.json, not image metadata. |
{: .table .table-bordered}

### <a href="#codesandbox" name="codesandbox" class="anchor"> CodeSandbox </a>

[CodeSandbox](https://codesandbox.io/) provides cloud development environments running on a microVM architecture. VM specs start at 2 vCPUs + 2 GB RAM per environment (free tier) and can go up to 16 vCPUs + 32 GB RAM.

When you import a GitHub repository into CodeSandbox, it will automatically provision a dedicated environment for every branch. Thanks to memory snapshotting, CodeSandbox then resumes and branches an environment in under two seconds.

CodeSandbox offers support for multiple editors, so you can code using the CodeSandbox web editor, VS Code, or the CodeSandbox iOS app.

**Tip:** After importing a repository into CodeSandbox, you can use the built-in UI to configure the environment using dev containers.

#### <a href="#codesandbox-specific-properties" name="codesandbox-specific-properties" class="anchor"> Product specific properties </a>
CodeSandbox has built-in support for any programming language and supports Debian and Ubuntu-based images.

All properties specific to CodeSandbox are placed within a `.codesandbox` folder at root level. Typically, this will contain a `tasks.json` file, which defines the commands to be run at startup or with a click.

More details about these can be found in the CodeSandbox [documentation](https://codesandbox.io/docs/learn/repositories/task).

#### <a href="#codesandbox-specific-limitations" name="codesandbox-specific-limitations" class="anchor"> Product specific limitations </a>

CodeSandbox runs dev containers using rootless Podman instead of Docker. CodeSandbox also uses [devcontainers/cli](https://github.com/devcontainers/cli) to manage dev containers. So any limitations of rootless Podman and Dev Container CLI should apply to CodeSandbox. 

The following properties apply differently to CodeSandbox.

| Property or variable | Type | Description |
|----------|---------|----------------------|
| `forwardPorts` | array | CodeSandbox does not need this property. All ports opened in dev containers will be mapped to a public URL automatically. |
| `portsAttributes` | object | CodeSandbox does not yet support this property. Ports are attached to tasks configured in `.codesandbox/tasks.json` and are attributed to the tasks.|
| `otherPortsAttributes` | object | CodeSandbox does not yet support this property. |
| `remoteUser` | string | CodeSandbox currently ignores this property and overrides this as `root`. CodeSandbox uses rootless Podman to run containers. Running with a non-root remote user is the same as running as a root remote user in rootless Podman, from a security perspective. CodeSandbox plans on supporting this in the future. |
| `shutdownAction` | string | Does not apply to CodeSandbox. |
| `capAdd` | array | CodeSandbox does not support adding docker capabilities. As the containers are run as a non-root user, capabilities that need root access will not work. |
| `features` | object | CodeSandbox automatically adds docker-cli to the container and connects to the host socket. Features like `docker-in-docker` and `docker-outside-of-docker` will work a bit differently. As the docker-cli and socket from host are accessible in the container, most use cases should work as expected. |
| `${localEnv:VARIABLE_NAME}` | Any | For CodeSandbox, the host is in the cloud rather than in your local machine.|
| `hostRequirements` | object | CodeSandbox does not yet support this property. |
{: .table .table-bordered}

### <a href="#devpod" name="devpod" class="anchor"> DevPod </a>

[DevPod](https://github.com/loft-sh/devpod) is a client-only tool to create reproducible developer environments based on a `devcontainer.json` on any backend. Each developer environment runs in a container and is specified through a `devcontainer.json`. Through DevPod providers these environments can be created on any backend, such as the local computer, a Kubernetes cluster, any reachable remote machine or in a VM in the cloud.

### <a href="#gitpod" name="gitpod" class="anchor"> Gitpod </a>

[**Gitpod Flex**](https://www.gitpod.io/) is a platform for automating and standardizing development environments. Available as a self-hosted solution in your cloud or for local development through Gitpod Desktop, Gitpod Flex scales to support environments with up to 896 vCPUs and 12TB of RAM, including GPU support and compatibility with multiple editors like VS Code, JetBrains, Cursor, and Zed.

Gitpod Flex fully adheres to the Dev Container Specification, enabling developers to create portable and reproducible environments through `devcontainer.json`. To apply changes, simply run `gitpod environment devcontainer rebuild` from within any development environment.


For more details on constraints, customizations, and automation options, please refer to the [blog announcement](https://www.gitpod.io/blog/gitpod-supports-development-container).


### <a href="#schema" name="schema" class="anchor"> Schema </a>

You can explore the [VS Code implementation](implementors/json_schema) of the dev container schema.



================================================
FILE: templates.html
================================================
---
title: Templates
layout: table
sectionid: collection-index-templates
---

<h1 style="margin-left: auto;margin-right: auto;">Available Dev Container Templates</h1>
<p style="margin-left: auto;margin-right: auto;">
    This table contains all official and community-supported <a href="implementors/templates/">Dev Container Templates</a>
    known at the time of crawling <a href="collections">each registered collection</a>. This list is continuously 
    updated with the latest available Template information. See the <a href="https://github.com/devcontainers/template-starter">
    Template quick start repository</a> to add your own!
    <br><br>
    Templates listed here will be presented in the UX of <a href="supporting">supporting tools</a>.
    <br><br>
    Please note that if you need to report a Template, you should do so through the registry hosting the Template.
</p>

<p>
    To add your own collection to this list, please create a PR editing <a
        href="https://github.com/devcontainers/devcontainers.github.io/blob/gh-pages/_data/collection-index.yml">this
        yaml file</a>.
</p>

<input type="text" id="searchInput" placeholder="Search">
<br>
<br>

<table id="collectionTable" class="tg">
    <tr>
        <td class="tg-0lax"><b>Template Name</b></b></td>
        <td class="tg-0lax"><b>Maintainer</b></td>
        <td class="tg-0lax"><b>Reference</b></td>
        <td class="tg-0lax"><b>Latest Version</b></td>
    </tr>
    
    {% for c in site.data.devcontainer-index.collections %}
    {% for f in c.templates %}
    <tr>
        <td class="tg-0lax"><a rel="nofollow" href="{{ f.documentationURL | strip_html }}">{{ f.name | strip_html }}</a>
        </td>
        <td class="tg-0lax">{{ c.sourceInformation.maintainer | strip_html }}</td>
        <td class="tg-0lax"><code>{{ f.id | strip_html  }}:{{ f.version | strip_html }}</code></td>
        <td class="tg-0lax"><code>{{ f.version | strip_html  }}</code></td>
    </tr>
    {% endfor %}
    
    {% endfor %}
</table>

<script>
    const searchInput = document.getElementById('searchInput');
    const collectionTable = document.getElementById('collectionTable');
    const rows = collectionTable.getElementsByTagName('tr');

    searchInput.addEventListener('input', function () {
        const searchValue = searchInput.value.toLowerCase();

        for (let i = 1; i < rows.length; i++) {
            const name = rows[i].getElementsByTagName('td')[0].textContent.toLowerCase();
            const maintainer = rows[i].getElementsByTagName('td')[1].textContent.toLowerCase();

            if (name.includes(searchValue) || maintainer.includes(searchValue)) {
                rows[i].style.display = '';
            } else {
                rows[i].style.display = 'none';
            }
        }
    });
</script>


================================================
FILE: _data/specification-toc.yml
================================================
- title: Development Containers
  children:
  - title: Base Protocol
    anchor: Base_Protocol
    children:
    - title: Cancel
      anchor: Base_Protocol_Cancel
    - title: ErrorResponse
      anchor: Base_Protocol_ErrorResponse
    - title: Event
      anchor: Base_Protocol_Event
    - title: ProtocolMessage
      anchor: Base_Protocol_ProtocolMessage
    - title: Request
      anchor: Base_Protocol_Request
    - title: Response
      anchor: Base_Protocol_Response
  - title: Events
    anchor: Events
    children:
    - title: Breakpoint
      anchor: Events_Breakpoint
    - title: Capabilities
      anchor: Events_Capabilities
    - title: Continued
      anchor: Events_Continued
    - title: Exited
      anchor: Events_Exited
    - title: Initialized
      anchor: Events_Initialized
    - title: Invalidated
      anchor: Events_Invalidated
    - title: LoadedSource
      anchor: Events_LoadedSource
    - title: Memory
      anchor: Events_Memory
    - title: Module
      anchor: Events_Module
    - title: Output
      anchor: Events_Output
    - title: Process
      anchor: Events_Process
    - title: ProgressEnd
      anchor: Events_ProgressEnd
    - title: ProgressStart
      anchor: Events_ProgressStart
    - title: ProgressUpdate
      anchor: Events_ProgressUpdate
    - title: Stopped
      anchor: Events_Stopped
    - title: Terminated
      anchor: Events_Terminated
    - title: Thread
      anchor: Events_Thread
  - title: Requests
    anchor: Requests
    children:
    - title: Attach
      anchor: Requests_Attach
    - title: BreakpointLocations
      anchor: Requests_BreakpointLocations
    - title: Completions
      anchor: Requests_Completions
    - title: ConfigurationDone
      anchor: Requests_ConfigurationDone
    - title: Continue
      anchor: Requests_Continue
    - title: DataBreakpointInfo
      anchor: Requests_DataBreakpointInfo
    - title: Disassemble
      anchor: Requests_Disassemble
    - title: Disconnect
      anchor: Requests_Disconnect
    - title: Evaluate
      anchor: Requests_Evaluate
    - title: ExceptionInfo
      anchor: Requests_ExceptionInfo
    - title: Goto
      anchor: Requests_Goto
    - title: GotoTargets
      anchor: Requests_GotoTargets
    - title: Initialize
      anchor: Requests_Initialize
    - title: Launch
      anchor: Requests_Launch
    - title: LoadedSources
      anchor: Requests_LoadedSources
    - title: Modules
      anchor: Requests_Modules
    - title: Next
      anchor: Requests_Next
    - title: Pause
      anchor: Requests_Pause
    - title: ReadMemory
      anchor: Requests_ReadMemory
    - title: Restart
      anchor: Requests_Restart
    - title: RestartFrame
      anchor: Requests_RestartFrame
    - title: ReverseContinue
      anchor: Requests_ReverseContinue
    - title: Scopes
      anchor: Requests_Scopes
    - title: SetBreakpoints
      anchor: Requests_SetBreakpoints
    - title: SetDataBreakpoints
      anchor: Requests_SetDataBreakpoints
    - title: SetExceptionBreakpoints
      anchor: Requests_SetExceptionBreakpoints
    - title: SetExpression
      anchor: Requests_SetExpression
    - title: SetFunctionBreakpoints
      anchor: Requests_SetFunctionBreakpoints
    - title: SetInstructionBreakpoints
      anchor: Requests_SetInstructionBreakpoints
    - title: SetVariable
      anchor: Requests_SetVariable
    - title: Source
      anchor: Requests_Source
    - title: StackTrace
      anchor: Requests_StackTrace
    - title: StepBack
      anchor: Requests_StepBack
    - title: StepIn
      anchor: Requests_StepIn
    - title: StepInTargets
      anchor: Requests_StepInTargets
    - title: StepOut
      anchor: Requests_StepOut
    - title: Terminate
      anchor: Requests_Terminate
    - title: TerminateThreads
      anchor: Requests_TerminateThreads
    - title: Threads
      anchor: Requests_Threads
    - title: Variables
      anchor: Requests_Variables
    - title: WriteMemory
      anchor: Requests_WriteMemory
  - title: Reverse Requests
    anchor: Reverse_Requests
    children:
    - title: RunInTerminal
      anchor: Reverse_Requests_RunInTerminal
  - title: Types
    anchor: Types
    children:
    - title: Breakpoint
      anchor: Types_Breakpoint
    - title: BreakpointLocation
      anchor: Types_BreakpointLocation
    - title: Capabilities
      anchor: Types_Capabilities
    - title: Checksum
      anchor: Types_Checksum
    - title: ChecksumAlgorithm
      anchor: Types_ChecksumAlgorithm
    - title: ColumnDescriptor
      anchor: Types_ColumnDescriptor
    - title: CompletionItem
      anchor: Types_CompletionItem
    - title: CompletionItemType
      anchor: Types_CompletionItemType
    - title: DataBreakpoint
      anchor: Types_DataBreakpoint
    - title: DataBreakpointAccessType
      anchor: Types_DataBreakpointAccessType
    - title: DisassembledInstruction
      anchor: Types_DisassembledInstruction
    - title: ExceptionBreakMode
      anchor: Types_ExceptionBreakMode
    - title: ExceptionBreakpointsFilter
      anchor: Types_ExceptionBreakpointsFilter
    - title: ExceptionDetails
      anchor: Types_ExceptionDetails
    - title: ExceptionFilterOptions
      anchor: Types_ExceptionFilterOptions
    - title: ExceptionOptions
      anchor: Types_ExceptionOptions
    - title: ExceptionPathSegment
      anchor: Types_ExceptionPathSegment
    - title: FunctionBreakpoint
      anchor: Types_FunctionBreakpoint
    - title: GotoTarget
      anchor: Types_GotoTarget
    - title: InstructionBreakpoint
      anchor: Types_InstructionBreakpoint
    - title: InvalidatedAreas
      anchor: Types_InvalidatedAreas
    - title: Message
      anchor: Types_Message
    - title: Module
      anchor: Types_Module
    - title: ModulesViewDescriptor
      anchor: Types_ModulesViewDescriptor
    - title: Scope
      anchor: Types_Scope
    - title: Source
      anchor: Types_Source
    - title: SourceBreakpoint
      anchor: Types_SourceBreakpoint
    - title: StackFrame
      anchor: Types_StackFrame
    - title: StackFrameFormat
      anchor: Types_StackFrameFormat
    - title: StepInTarget
      anchor: Types_StepInTarget
    - title: SteppingGranularity
      anchor: Types_SteppingGranularity
    - title: Thread
      anchor: Types_Thread
    - title: ValueFormat
      anchor: Types_ValueFormat
    - title: Variable
      anchor: Types_Variable
    - title: VariablePresentationHint
      anchor: Types_VariablePresentationHint


================================================
FILE: _implementors/contributing.md
================================================
---
layout: implementors
title:  "How to contribute to the Development Container Specification"
shortTitle: "Contributing"
author: Microsoft
index: 9
---

We're excited for your contributions to the Dev Container Specification! This document outlines how you can get involved. We also welcome you to join our [community Slack channel](https://aka.ms/dev-container-community).

## <a href="#contribution-approaches" name="contribution-approaches" class="anchor"> Spec Contribution approaches </a>

If you'd like to contribute a change or addition to the spec, you may follow the guidance below:
- Propose the change via an [issue](https://github.com/devcontainers/spec/issues) in this repository. Try to get early feedback before spending too much effort formalizing it.
- More formally document the proposed change in terms of properties and their semantics. Look to format your proposal like our [devcontainer.json reference](https://aka.ms/devcontainer.json).

Here is a sample:

| Property | Type  | Description |
|:------------------|:------------|:------------|
| `image`    | string      | **Required** when using an image. The name of an image in a container registry ([DockerHub](https://hub.docker.com), [GitHub Container Registry](https://docs.github.com/packages/guides/about-github-container-registry), [Azure Container Registry](https://azure.microsoft.com/services/container-registry/)) that VS Code and other `devcontainer.json` supporting services / tools should use to create the dev container. |
{: .table .table-bordered}

- PRs to the [schema](https://github.com/microsoft/vscode/blob/main/extensions/configuration-editing/schemas/devContainer.schema.src.json), i.e code or shell scripts demonstrating approaches for implementation.

Once there is discussion on your proposal, please also open and link a PR to update the [devcontainer.json reference doc](https://aka.ms/devcontainer.json). When your proposal is merged, the docs will be kept up-to-date with the latest spec.

### <a href="#tool-specific-support" name="tool-specific-support" class="anchor"> Contributing tool-specific support </a>

Tool-specific properties are contained in namespaces in the `"customizations"` property. For instance, VS Code specific properties are formated as:

```bash
// Configure tool-specific properties.
"customizations": {
     // Configure properties specific to VS Code.
     "vscode": {
          // Set *default* container specific settings.json values on container create.
          "settings": {},
			
          // Additional VS Code specific properties...
     }
},
```

You may propose adding a new namespace for a specific tool, and any properties specific to that tool.

### <a href="#formatting-guidelines" name="formatting-guidelines" class="anchor"> Formatting Guidelines </a>

When contributing an official doc or referencing dev containers in your projects, please consider the following guidelines:

- Refer to the spec as the "Development Container Specification"
     - All capital letters
     - Singular "Container" rather than plural "Containers"
- The term "dev container" shouldn't be capitalized on its own
     - It should only be capitalized when referring to an official tool title, like the VS Code Dev Containers extension 
- Signify `devcontainer.json` is a file type through backticks 
- Features and Templates should always be capitalized
- Refer to the CLI as the "Dev Container CLI" (note the caps)
- Use bolding for emphasis sprinkled throughout sections, rather than try to use it to always bold certain terms

## <a href="#review-process" name="review-process" class="anchor"> Review process </a>

We use the following [labels](https://github.com/devcontainers/spec/labels) in the spec repo:

- `proposal`: Issues under discussion, still collecting feedback.
- `finalization`: Proposals we intend to make part of the spec.

[Milestones](https://github.com/devcontainers/spec/milestones) use a "month year" pattern (i.e. January 2022). If a finalized proposal is added to a milestone, it is intended to be merged during that milestone.

## <a href="#community-engagement" name="community-engagement" class="anchor"> Community Engagement </a>

There are several additional options to engage with the dev container community, such as asking questions, providing feedback, or engaging on how your team may use or contribute to dev containers:
- [GitHub Discussions](https://github.com/devcontainers/spec/discussions): This is a great opportunity to connect with the community and maintainers of this project, without the requirement of contributing a change to the actual spec (which we see more in issues and PRs)
- [Community Slack channel](https://aka.ms/dev-container-community): This is a great opportunity to connect with the community and maintainers
- You can always check out the issues and PRs (and contribute new ones) across the repos in the [Dev Containers GitHub org](https://github.com/devcontainers) too!
- Community collections: You can contribute your own [Templates](https://containers.dev/implementors/templates-distribution/#distribution) and [Features](https://containers.dev/implementors/features-distribution/#distribution) to our [community index](https://containers.dev/collections)!


================================================
FILE: _implementors/features-distribution.md
================================================
---
layout: implementors
title:  "Dev container Features contribution and discovery"
shortTitle: "Features distribution"
author: Microsoft
index: 6
---

**TL;DR Check out the [quick start repository](https://github.com/devcontainers/feature-template) to get started on distributing your own Dev Container Features.**

This specification defines a pattern where community members and organizations can author and self-publish [Dev Container Features](../features). 

Goals include:

- For Feature authors, create a "self-service" way to publish a Feature, either publicly or privately, that is not centrally controlled.
- For users, provide the ability to validate the integrity of previously fetched Feature assets. 
- For users, provide the ability for a user to pin to a particular version (absolute, or semantic version) of a Feature to allow for consistent, repeatable environments.
- Provide the ability to standardize publishing such that [supporting tools](../../supporting) may implement their own mechanism to aid Feature discoverability as they see fit.

> **Tip:** This section covers details on the Features specification. If you are looking for summarized information on creating your own Features, check out the [quick start](https://github.com/devcontainers/feature-starter) and [core Features](https://github.com/devcontainers/features) repositories.

## <a href="#source-code" name="source-code" class="anchor"> Source Code </a>

Features source code is stored in a git repository.

For ease of authorship and maintenance, [1..n] features can share a single git repository. This set of Features is referred to as a "collection," and will share the same [`devcontainer-collection.json`](#devcontainer-collection-json) file and "namespace" (eg. `<owner>/<repo>`).

Source code for the set follows the example file structure below:

```
.
├── README.md
├── src
│   ├── dotnet
│   │   ├── devcontainer-feature.json
│   │   ├── install.sh
│   │   └── ...
|   ├
│   ├── go
│   │   ├── devcontainer-feature.json
│   │   └── install.sh
|   ├── ...
│   │   ├── devcontainer-feature.json
│   │   └── install.sh
├── test
│   ├── dotnet
│   │   ├── test.sh
│   │   └── ...
│   └── go
│   |   └── test.sh
|   ├── ...
│   │   └── test.sh
├── ...
```

... where `src` is a directory containing a sub-folder with the name of the Feature (e.g. `src/dotnet` or `src/go`) with at least a file named `devcontainer-feature.json` that contains the Feature metadata, and an `install.sh` script that implementing tools will use as the entrypoint to install the Feature.

Each sub-directory should be named such that it matches the `id` field of the `devcontainer-feature.json`.  Other files can also be included in the Feature's sub-directory, and will be included during the [packaging step](#packaging) alongside the two required files.  Any files that are not part of the Feature's sub-directory (e.g. outside of `src/dotnet`) will not included in the [packaging step](#packaging).

Optionally, a mirrored `test` directory can be included with an accompanying `test.sh` script.  Implementing tools may use this to run tests against the given Feature.

## <a href="#versioning" name="versioning" class="anchor"> Versioning </a>

Each Feature is individually [versioned according to the semver specification](https://semver.org/).  The `version` property in the respective `devcontainer-feature.json` file is parsed to determine if the Feature should be republished.

Tooling that handles publishing Features will not republish Features if that exact version has already been published; however, tooling must republish major and minor versions in accordance with the semver specification.

## <a href="#packaging" name="packaging" class="anchor"> Packaging </a>

Features are distributed as tarballs. The tarball contains the entire contents of the Feature sub-directory, including the `devcontainer-feature.json`, `install.sh`, and any other files in the directory.

The tarball is named `devcontainer-feature-<id>.tgz`, where `<id>` is the Feature's `id` field.

A reference implementation for packaging and distributing Features is provided as a [GitHub Action](https://github.com/devcontainers/action).

### <a href="#devcontainer-collection-json" name="devcontainer-collection-json" class="anchor"> devcontainer-collection.json </a>

The `devcontainer-collection.json` is an auto-generated metadata file.

| Property | Type | Description |
| :--- | :--- | :--- |
| `sourceInformation` | object | Metadata from the implementing packaging tool. |
| `features` | array | The list of features that are contained in this collection.|
{: .table .table-bordered}

Each Features's `devcontainer-feature.json` metadata file is appended into the `features` top-level array.

## <a href="#distribution" name="distribution" class="anchor"> Distribution </a>

There are several supported ways to distribute Features. Distribution is handled by the implementing packaging tool such as the [Dev Container CLI](https://github.com/devcontainers/cli) or [Dev Container Publish GitHub Action](https://github.com/marketplace/actions/dev-container-publish). See the [quick start repository](https://github.com/devcontainers/feature-template) for a full working example.

A user references a distributed Feature in a `devcontainer.json` as defined in ['referencing a Feature'](../features#referencing-a-feature).

### <a href="#oci-registry" name="oci-registry" class="anchor"> OCI Registry </a>

An OCI registry that implements the [OCI Artifact Distribution Specification](https://github.com/opencontainers/distribution-spec) serves as the primary distribution mechanism for Features.

Each packaged Feature is pushed to the registry following the naming convention `<registry>/<namespace>/<id>[:version]`, where version is the major, minor, and patch version of the Feature, according to the semver specification.

> **Note:** The `namespace` is a unique identifier for the collection of Features.  There are no strict rules for the `namespace`; however, one pattern is to set `namespace` equal to source repository's `<owner>/<repo>`. 

A custom media type `application/vnd.devcontainers` and `application/vnd.devcontainers.layer.v1+tar` are used as demonstrated below.

For example, the `go` Feature in the `devcontainers/features` namespace at version `1.2.3` would be pushed to the ghcr.io OCI registry.  

> **Note:** The example below uses [`oras`](https://oras.land/) for demonstration purposes.  A supporting tool should directly implement the required functionality from the aforementioned OCI artifact distribution specification.

```bash
# ghcr.io/devcontainers/features/go:1 
REGISTRY=ghcr.io
NAMESPACE=devcontainers/features
FEATURE=go

ARTIFACT_PATH=devcontainer-feature-go.tgz

for VERSION in 1  1.2  1.2.3  latest
do
    oras push ${REGISTRY}/${NAMESPACE}/${FEATURE}:${VERSION} \
            --config /dev/null:application/vnd.devcontainers \
                             ./${ARTIFACT_PATH}:application/vnd.devcontainers.layer.v1+tar
done
```

The "namespace" is the globally identifiable name for the collection of Features. (eg: `owner/repo` for the source code's git repository).

The auto-generated `devcontainer-collection.json` is pushed to the registry with the same `namespace` as above and no accompanying `feature` name. The collection file is always tagged as `latest`.

```bash
# ghcr.io/devcontainers/features
REGISTRY=ghcr.io
NAMESPACE=devcontainers/features

oras push ${REGISTRY}/${NAMESPACE}:latest \
        --config /dev/null:application/vnd.devcontainers \
                            ./devcontainer-collection.json:application/vnd.devcontainers.collection.layer.v1+json
```

Additionally, an [annotation](https://github.com/opencontainers/image-spec/blob/main/annotations.md) named `dev.containers.metadata` should be populated on the manifest when published by an implementing tool.  This annotation is the escaped JSON object of the entire `devcontainer-feature.json` as it appears during the [packaging stage](#packaging).  

An example manifest with the `dev.containers.metadata` annotation:

```json
{
  "schemaVersion": 2,
  "mediaType": "application/vnd.oci.image.manifest.v1+json",
  "config": {
    "mediaType": "application/vnd.devcontainers",
    "digest": "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
    "size": 0
  },
  "layers": [
    {
      "mediaType": "application/vnd.devcontainers.layer.v1+tar",
      "digest": "sha256:738af5504b253dc6de51d2cb1556cdb7ce70ab18b2f32b0c2f12650ed6d2e4bc",
      "size": 3584,
      "annotations": {
        "org.opencontainers.image.title": "devcontainer-feature-myFeature.tgz"
      }
    }
  ],
  "annotations": {
    "dev.containers.metadata": "{\"name\": \"My Feature\",\"id\": \"myFeature\",\"version\": \"1.0.0\",\"dependsOn\": {\"ghcr.io/myotherFeature:1\": {\"flag\": true},\"features.azurecr.io/aThirdFeature:1\": {},\"features.azurecr.io/aFourthFeature:1.2.3\": {}}}"
  }
}
```

### <a href="#directly-reference-tarball" name="directly-reference-tarball" class="anchor"> Directly referencing a tarball </a>

A Feature can be referenced directly in a user's [`devcontainer.json`](../spec#a-hrefdevcontainerjson-namedevcontainerjson-classanchor-devcontainerjson-a) file by HTTPS URI that points to the tarball from the [package step](#packaging).

The `.tgz` archive file must be named `devcontainer-feature-<featureId>.tgz`.

### <a href="#addendum-locally-referenced" name="addendum-locally-referenced" class="anchor"> Locally referenced Features </a>

Instead of publishing a Feature to an OCI registry, a Feature's source code may be referenced from a local folder. Locally referencing a Feature may be useful when first authoring a Feature.

A local Feature is referenced in the devcontainer's `feature` object **relative to the folder containing the project's `devcontainer.json`**.

Additional constraints exists when including local Features in a project:

* The project must have a `.devcontainer/` folder at the root of the [**project workspace folder**](/implementors/spec/#project-workspace-folder).

* A local Feature's source code **must** be contained within a sub-folder of the `.devcontainer/` folder.

* The sub-folder name **must** match the Feature's `id` field.

* A local Feature may **not** be referenced by absolute path.

* The local Feature's sub-folder **must** contain at least a `devcontainer-feature.json` file and `install.sh` entrypoint script, mirroring the [previously outlined file structure](#Source-code).

The relative path is provided using unix-style path syntax (eg `./myFeature`) regardless of the host operating system.

An example project is illustrated below:

```
.
├── .devcontainer/
│   ├── localFeatureA/
│   │   ├── devcontainer-feature.json
│   │   ├── install.sh
│   │   └── ...
│   ├── localFeatureB/
│   │   ├── devcontainer-feature.json
│   │   ├── install.sh
│   │   └── ...
│   ├── devcontainer.json
```

##### <a href="#devcontainerjson" name="devcontainerjson" class="anchor"> devcontainer.json </a>
```jsonc
{
        // ...
        "features": {
                "./localFeatureA": {},
                "./localFeatureB": {}
        }
}
```



================================================
FILE: _implementors/features.md
================================================
---
layout: implementors
title:  "Dev Container Features reference"
shortTitle: "Features"
author: Microsoft
index: 5
---

**Development Container Features** are self-contained, shareable units of installation code and development container configuration. The name comes from the idea that referencing one of them allows you to quickly and easily add more tooling, runtime, or library "features" into your development container for you or your collaborators to use.

Feature metadata is captured by a `devcontainer-feature.json` file in the root folder of the feature.

> **Note:** While Features may be installed on top of any base image, the implementation of a Feature might restrict it to a subset of possible base images. For example, some Features may be authored to work with a certain Linux distro (e.g. debian-based images that use the `apt` package manager).
> 
> This page covers details on the Features specification. If you are looking for summarized information on creating your own Features, check out the [quick start](https://github.com/devcontainers/feature-starter) and [core Features](https://github.com/devcontainers/features) repositories.

## <a href="#folder-structure" name="folder-structure" class="anchor"> Folder Structure </a>

A Feature is a self contained entity in a folder with at least a `devcontainer-feature.json` and `install.sh` entrypoint script.  Additional files are permitted and are packaged along side the required files.

```
+-- feature
|    +-- devcontainer-feature.json
|    +-- install.sh
|    +-- (other files)
```

## <a href="#devcontainer-feature-json-properties" name="devcontainer-feature-json-properties" class="anchor"> devcontainer-feature.json properties </a>

The `devcontainer-feature.json` file defines metadata about a given Feature.

All properties are optional **except for `id`, `version`, and `name`**. 

[devContainerFeature.schema.json](https://github.com/devcontainers/spec/blob/main/schemas/devContainerFeature.schema.json) defines the schema for the `devcontainer-feature.json` file.

The properties of the file are as follows:

| Property | Type | Description |
| :--- | :--- | :--- |
| `id` | string | <b>Required</b>: Identifier of the Feature.  Must be unique in the context of the repository where the Feature exists and must match the name of the directory where the `devcontainer-feature.json` resides. |
| `version` | string | <b>Required</b>: The semantic version of the Feature (e.g: <code>1.0.0</code>). |
| `name` | string | <b>Required</b>: A "human-friendly" display name for the Feature. |
| `description` | string | Description of the Feature. |
| `documentationURL` | string | Url that points to the documentation of the Feature. |
| `licenseURL` | string | Url that points to the license of the Feature. |
| `keywords` | array | List of strings relevant to a user that would search for this definition/Feature. |
| `options` | object | A map of options that will be passed as environment variables to the execution of the script. |
| `containerEnv` | object | A set of name value pairs that sets or overrides environment variables. |
| `privileged` | boolean | Sets [privileged mode](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities) for the container (required by things like docker-in-docker) when the feature is used. |
| `init` | boolean | Adds the [tiny init](https://github.com/RKrahl/tiny-init) process to the container (`--init`) when the Feature is used. |
| `capAdd` | array | Adds container [capabilities](https://docs.docker.com/engine/security/#linux-kernel-capabilities) when the Feature is used. |
| `securityOpt` | array | Sets container security options like updating the [seccomp profile](https://docs.docker.com/engine/security/seccomp/) when the Feature is used. |
| `entrypoint` | string | Set if the feature requires an "entrypoint" script that should fire at container start up. |
| `customizations` | object | Product specific properties, each namespace under `customizations` is treated as a separate set of properties. For each of this sets the object is parsed, values are replaced while arrays are set as a union. |
| `dependsOn` | object | An object (\**)  of Feature dependencies that **must** be satisified before this Feature is installed. Elements follow the same semantics of the `features` object in `devcontainer.json`. [See *Installation Order* for further information](#installation-order).  |
| `installsAfter` | array | Array of ID's of Features (omitting a version tag) that should execute before this one. Allows control for Feature authors on soft dependencies between different Features. [See *Installation Order* for further information](#installation-order). |
| `legacyIds` | array | Array of old IDs used to publish this Feature. The property is useful for renaming a currently published Feature within a single namespace. |
| `deprecated` | boolean | Indicates that the Feature is deprecated, and will not receive any further updates/support. This property is intended to be used by the supporting tools for highlighting Feature deprecation. |
| `mounts` | object | Defaults to unset. Cross-orchestrator way to add additional mounts to a container. Each value is an object that accepts the same values as the [Docker CLI `--mount` flag](https://docs.docker.com/engine/reference/commandline/run/#mount). The Pre-defined [devcontainerId](/implementors/json_reference#variables-in-devcontainerjson) variable may be referenced in the value. For example:<br />`"mounts": [{ "source": "dind-var-lib-docker", "target": "/var/lib/docker", "type": "volume" }]` |
{: .table .table-bordered}

(**) The ID must refer to either a Feature (1) published to an OCI registry, (2) a Feature Tgz URI, or (3) a Feature in the local file tree. Deprecated Feature identifiers (i.e GitHub Release) are not supported and the presence of this property may be considered a fatal error or ignored. For [local Features (ie: during development)](../features-distribution#addendum-locally-referenced), you may also depend on other local Features by providing a relative path to the Feature, relative to folder containing the active `devcontainer.json`. This behavior of Features within this property again mirror the `features` object in `devcontainer.json`.


### <a href="#lifecycle-hooks" name="lifecycle-hooks" class="anchor"> Lifecycle Hooks </a>

The following lifecycle hooks may be declared as properties of `devcontainer-feature.json`. 

| Property | Type|
| :--- | :--- |
| `onCreateCommand` | [string, array, object](/implementors/json_reference#formatting-string-vs-array-properties)|
| `updateContentCommand` | [string, array, object](/implementors/json_reference#formatting-string-vs-array-properties)|
| `postCreateCommand` | [string, array, object](/implementors/json_reference#formatting-string-vs-array-properties)|
| `postStartCommand` | [string, array, object](/implementors/json_reference#formatting-string-vs-array-properties) |
| `postAttachCommand` | [string, array, object](/implementors/json_reference#formatting-string-vs-array-properties) |
{: .table .table-bordered}

#### <a href="#behavior" name="behavior" class="anchor"> Behavior </a>

Each property mirrors the behavior of the matching property in [`devcontainer.json`](/implementors/json_reference#Lifecycle-scripts), including the behavior that commands are executed from the context of the [project workspace folder](/implementors/spec/#project-workspace-folder).

For each lifecycle hook (in [Feature installation order](/implementors/features/#installation-order)), each command contributed by a Feature is executed in sequence (blocking the next command from executing). Commands provided by Features are always executed _before_ any user-provided lifecycle commands (i.e: in the `devcontainer.json`).

If a Feature provides a given command with the [object syntax](/implementors/json_reference#formatting-string-vs-array-properties), all commands within that group are executed in parallel, but still blocking commands from subsequent Features and/or the `devcontainer.json`.

> **Note**: These properties are stored within [image metadata](/implementors/spec/#merge-logic).

#### Writing scripts to known container path

It may be helpful for a Feature to write scripts to a known, persistent path within the container (i.e. for later use in a given lifecycle hook). 

Take for instance the `git-lfs` Feature, which [writes a script](https://github.com/devcontainers/features/blob/4fca96b5e8a4bfc93679098cb19d73c65ce571eb/src/git-lfs/install.sh#L190-L216) to `/usr/local/share/pull-git-lfs-artifacts.sh` during installation.

##### install.sh
```bash
PULL_GIT_LFS_SCRIPT_PATH="/usr/local/share/pull-git-lfs-artifacts.sh"

tee "$PULL_GIT_LFS_SCRIPT_PATH" > /dev/null \
<< EOF
#!/bin/sh
set -e
<...truncated...>
EOF
```

This script is then executed during the [`postCreateCommand` lifecycle hook](https://github.com/devcontainers/features/blob/4fca96b5e8a4bfc93679098cb19d73c65ce571eb/src/git-lfs/devcontainer-feature.json#L23).

##### devcontainer-feature.json
```jsonc
{
    "id": "git-lfs",
    "version": "1.1.0",
    "name": "Git Large File Support (LFS)",
    // <...truncated...>
    "postCreateCommand": "/usr/local/share/pull-git-lfs-artifacts.sh",
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}
```

### <a href="#options-property" name="options-property" class="anchor"> The `options` property </a>

The options property contains a map of option IDs and their related configuration settings. The ID becomes the name of the environment variable in all caps. See [option resolution](#option-resolution) for more details. For example:

```json
{
  "options": {
    "optionIdGoesHere": {
      "type": "string",
      "description": "Description of the option",
      "proposals": ["value1", "value2"],
      "default": "value1"
    }
  }
}
```

| Property | Type | Description |
| :--- | :--- | :--- |
| `optionId` | string | ID of the option that is converted into an all-caps environment variable with the selected value in it. |
| `optionId.type` | string | Type of the option. Valid types are currently: `boolean`, `string` |
| `optionId.proposals` | array | A list of suggested string values. Free-form values **are** allowed. Omit when using `optionId.enum`. |
| `optionId.enum` | array | A strict list of allowed string values. Free-form values are **not** allowed. Omit when using `optionId.proposals`. |
| `optionId.default` | string or boolean | Default value for the option. |
| `optionId.description` | string | Description for the option. |
{: .table .table-bordered}

### <a href="#user-env-var" name="user-env-var" class="anchor"> User environment variables </a>

Feature scripts run as the `root` user and sometimes need to know which user account the dev container will be used with.

`_REMOTE_USER` and `_CONTAINER_USER` environment variables are passsed to the Features scripts with `_CONTAINER_USER` being the container's user and `_REMOTE_USER` being the configured `remoteUser`. If no `remoteUser` is configured, `_REMOTE_USER` is set to the same value as `_CONTAINER_USER`.

Additionally, the home folders of the two users are passed to the Feature scripts as `_REMOTE_USER_HOME` and `_CONTAINER_USER_HOME` environment variables.

The container user can be set with `containerUser` in the `devcontainer.json` and image metadata, `user` in the `docker-compose.yml`, `USER` in the Dockerfile, and can be passed down from the base image.

### <a href="#dev-container-id" name="dev-container-id" class="anchor"> Dev Container ID </a>

An identifier will be referred to as `${devcontainerId}` in the `devcontainer.json` and the Feature metadata and that will be replaced with the dev container's id. It should only be used in parts of the configuration and metadata that is not used for building the image because that would otherwise prevent pre-building the image at a time when the dev container's id is not known yet. Excluding boolean, numbers and enum properties the properties supporting `${devcontainerId}` in the Feature metadata are: `entrypoint`, `mounts`, `customizations`.

Implementations can choose how to compute this identifier. They must ensure that it is unique among other dev containers on the same Docker host and that it is stable across rebuilds of dev containers. The identifier must only contain alphanumeric characters. We describe a way to do this below.

#### <a href="#label-based" name="label-based" class="anchor"> Label-based Implementation  </a>

The following assumes that a dev container can be identified among other dev containers on the same Docker host by a set of labels on the container. Implementations may choose to follow this approach.

The identifier is derived from the set of container labels uniquely identifying the dev container. It is up to the implementation to choose these labels. E.g., if the dev container is based on a local folder the label could be named `devcontainer.local_folder` and have the local folder's path as its value.

E.g., the [`ghcr.io/devcontainers/features/docker-in-docker` Feature](https://github.com/devcontainers/features/blob/main/src/docker-in-docker/devcontainer-feature.json) could use the dev container id with:

```jsonc
{
    "id": "docker-in-docker",
    "version": "1.0.4",
    // ...
    "mounts": [
        {
            "source": "dind-var-lib-docker-${devcontainerId}",
            "target": "/var/lib/docker",
            "type": "volume"
        }
    ]
}
```

#### <a href="#label-based-comp" name="label-based-comp" class="anchor"> Label-based Computation  </a>

- Input the labels as a JSON object with the object's keys being the label names and the object's values being the labels' values.
	- To ensure implementations get to the same result, the object keys must be sorted and any optional whitespace outside of the keys and values must be removed.
- Compute a SHA-256 hash from the UTF-8 encoded input string.
- Use a base-32 encoded representation left-padded with '0' to 52 characters as the result.

JavaScript implementation taking an object with the labels as argument and returning a string as the result:

```js
const crypto = require('crypto');
function uniqueIdForLabels(idLabels) {
	const stringInput = JSON.stringify(idLabels, Object.keys(idLabels).sort()); // sort properties
	const bufferInput = Buffer.from(stringInput, 'utf-8');
	const hash = crypto.createHash('sha256')
		.update(bufferInput)
		.digest();
	const uniqueId = BigInt(`0x${hash.toString('hex')}`)
		.toString(32)
		.padStart(52, '0');
	return uniqueId;
}
```

## <a href="#devcontainer-json-properties" name="devcontainer-json-properties" class="anchor"> devcontainer.json properties </a>

Features are referenced in a user's [`devcontainer.json`](../json_reference) under the top level `features` object.

A user can specify an arbitrary number of Features.  At build time, these Features will be installed in an order defined by a combination of the [installation order rules and implementation](#Installation-Order). 

A single Feature is provided as a key/value pair, where the key is the Feature identifier, and the value is an object containing "options" (or empty for "default").  Each key in the feature object must be unique.

These options are sourced as environment variables at build-time, as specified in [Option Resolution](#Option-Resolution).

Below is a valid `features` object provided as an example.
```jsonc
"features": {
  "ghcr.io/user/repo/go": {},
  "ghcr.io/user/repo1/go:1": {},
  "ghcr.io/user/repo2/go:latest": {},
  "https://github.com/user/repo/releases/devcontainer-feature-go.tgz": { 
        "optionA": "value" 
  },
  "./myGoFeature": { 
        "optionA": true,
        "optionB": "hello",
        "version" : "1.0.0"
  }
}
```

> **Note:** The `:latest` version annotation is added implicitly if omitted. To pin to a specific package version ([example](https://github.com/devcontainers/features/pkgs/container/features/go/versions)), append it to the end of the Feature.

An option's value can be provided as either a `string` or `boolean`, and should match what is expected by the feature in the `devcontainer-feature.json` file.

As a shorthand, the value of the `features` property can be provided as a single string. This string is mapped to an option called `version`. In the example below, both examples are equivalent. 

```jsonc
"features": {
  "ghcr.io/owner/repo/go": "1.18"
}
```
```jsonc
"features": {
  "ghcr.io/owner/repo/go": {
    "version": "1.18"
  }
}
```

### <a href="#referencing-a-feature" name="referencing-a-feature" class="anchor"> Referencing a Feature </a>

The `id` format specified dicates how a supporting tool will locate and download a given feature. `id` is one of the following:

| Type | Description | Example |
| :--- | :--- | :--- |
| `<oci-registry>/<namespace>/<feature>[:<semantic-version>]` | Reference to feature in OCI registry(*) | `ghcr.io/user/repo/go` <br> `ghcr.io/user/repo/go:1` <br> `ghcr.io/user/repo/go:latest`|
| `https://<uri-to-feature-tgz>` | Direct HTTPS URI to a tarball. | `https://github.com/user/repo/releases/devcontainer-feature-go.tgz` |
| `./<path-to-feature-dir>`| A relative directory(**) to folder containing a devcontainer-feature.json. | `./myGoFeature` |
{: .table .table-bordered}

(*) OCI registry must implement the [OCI Artifact Distribution Specification](https://github.com/opencontainers/distribution-spec). Some implementors can be [found here](https://oras.land/implementors/).

(**) The provided path is always relative to the folder containing the `devcontainer.json`. Further requirements are outlined in the [Locally Referenced Addendum](../features-distribution#addendum-locally-referenced).

## <a href="#versioning" name="versioning" class="anchor"> Versioning </a>

Each Feature is individually [versioned according to the semver specification](https://semver.org/). The `version` property in the respective `devcontainer-feature.json` file is updated to increment the Feature's version.

Tooling that handles releasing Features will not republish Features if that exact version has already been published; however, tooling must republish major and minor versions in accordance with the semver specification.

## <a href="#authoring" name="authoring" class="anchor"> Authoring </a>

Features can be authored in a number of languages, the most straightforward being bash scripts. If a Feature is authored in a different language, information about it should be included in the metadata so that users can make an informed choice about it.

Reference information about the application required to execute the Feature should be included in `devcontainer-feature.json` in the metadata section.

Applications should default to `/bin/sh` for Features that do not include this information.

If the Feature is included in a folder as part of the repository that contains `devcontainer.json`, no other steps are necessary.

## <a href="#release" name="release" class="anchor"> Release </a>

_For information on distributing Features, see the [Features distribution page](../features-distribution)._

## <a href="#execution" name="execution" class="anchor"> Execution </a>

### <a href="#invoking-installsh" name="invoking-installsh" class="anchor"> Invoking `install.sh` </a>

The `install.sh` script for each Feature should be executed as `root` during a container image build. This allows the script to add needed OS dependencies or settings that could not otherwise be modified. This also allows the script to switch into another user's context using the `su` command (e.g., `su ${USERNAME} -c "command-goes-here"`). In combination, this allows both root and non-root image modifications to occur even if `sudo` is not present in the base image for security reasons.

To ensure that the appropriate shell is used, the execute bit should be set on `install.sh` and the file invoked directly (e.g. `chmod +x install.sh && ./install.sh`). 

> **Note:** It is recommended that Feature authors write `install.sh` using a shell available by default in their supported distributions (e.g., `bash` in Debian/Ubuntu or Fedora, `sh` in Alpine). In the event a different shell is required (e.g., `fish`), `install.sh` can be used to boostrap by checking for the presence of the desired shell, installing it if needed, and then invoking a secondary script using the shell.
> 
> The `install.sh` file can similarly be used to bootstrap something written in a compiled language like Go. Given the increasing likelihood that a Feature needs to work on both x86_64 and arm64-based devices (e.g., Apple Silicon Macs), `install.sh` can detect the current architecture (e.g., using something like `uname -m` or `dpkg --print-architecture`), and then invoke the right executable for that architecture.

### <a href="#installation-order" name="installation-order" class="anchor"> Installation order </a>

By default, Features are installed on top of a base image in an order determined as optimal by the implementing tool.

If any of the following properties are provided in the Feature's `devcontainer-feature.json`, or the user's `devcontainer.json`, the order indicated by these propert(ies) are respected.

* The `dependsOn` property defined as a part of a Feature's `devcontainer-feature.json`.
* The `installsAfter` property defined as part of a Feature's `devcontainer-feature.json`.
* The `overrideFeatureInstallOrder` property in user's `devcontainer.json`. Allows users to control the order of execution of their Features.

#### <a href="#dependsOn" name="dependsOn" class="anchor"> dependsOn</a>

The optional `dependsOn` property indicates a set of required, "hard" dependencies for a given Feature.  

The `dependsOn` property is declared in a Feature's `devcontainer-feature.json` metadata file. Elements of this property mirror the semantics of the `features` object in `devcontainer.json`.  Therefore, all dependencies may provide the relevant options, or an empty object (eg: `"bar:123": {}`) if the Feature's default options are sufficient.  Identical Features that provide different options are treated as _different_ Features (see [Feature equality](#definition-feature-equality) for more info).

All Features indicated in the `dependsOn` property **must** be satisfied (a Feature [equal](#definition-feature-equality) to each dependency is present in the installation order) _before_ the given Feature is set to be installed.  If any of the Features indicated in the `dependsOn` property cannot be installed (e.g due to circular dependency, failure to resolve the Feature, etc) the entire dev container creation should fail.

The `dependsOn` property must be evaluated recursively.  Therefore, if a Feature dependency has its own `dependsOn` property, that Feature's dependencies must also be satisfied before the given Feature is installed.

```json
{
    "name": "My Feature",
    "id": "myFeature",
    "version": "1.0.0",
    "dependsOn": {
        "foo:1": {
            "flag": true
        },
        "bar:1.2.3": {},
        "baz@sha256:a4cdc44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" {},
    }
}
```

In the snippet above, `myfeature` MUST be installed after `foo`, `bar`, and `baz`.  If the Features provided via the `dependsOn` property declare their own dependencies, those must also be satisfied before the Feature is installed.

#### <a href="#installsAfter" name="installsAfter" class="anchor"> installsAfter </a>

The `installsAfter` property indicates a "soft dependency" that influences the installation order of Features that are already queued to be installed.  The effective behavior of this property is the same as `dependsOn`, with the following differences:

- `installsAfter` is **not** evaluated recursively.
- `installsAfter` only influences the installation order of Features that are **already set to be installed**.  Any Feature not set to be installed after (1) resolving the `dependsOn` dependency tree or (2) indicated by the user's `devcontainer.json` should not be added to the installation list.
- The Feature indicated by `installsAfter` can **not** provide options, nor are they able to be pinned to a specific version tag or digest.  Resolution to the canonical name should still be performed (eg: If the Feature has been [renamed](#steps-to-rename-a-feature)).

```
{
    "name": "My Feature",
    "id": "myFeature",
    "version": "1.0.0",
    "installsAfter": [
        "foo",
        "bar"
    ]
}
```

In the snippet above, `myfeature` must be installed after `foo` and `bar` **if** the Feature is already queued to be installed.  If `second` and `third` are not already queued to be installed, this dependency relationship should be ignored.

#### <a href="#overrideFeatureInstallOrder" name="overrideFeatureInstallOrder" class="anchor"> overrideFeatureInstallOrder </a>

The `overrideFeatureInstallOrder` property of `devcontainer.json` is an array of Feature IDs that are to be installed in descending priority order as soon as its dependencies outlined above are installed.

> This property may not indicate an installation order that is inconsistent with the resolved dependency graph (see [dependency algorithm](#dependency-installation-order-algorithm)).  If the `overrideFeatureInstallOrder` property is inconsistent with the dependency graph, the implementing tool should fail the dependency resolution step.

This evaluation is performed by assigning a [`roundPriority`](#2-assigning-round-priority) to all nodes that match match the Feature identifier (version omitted) present in the property. 

For example, given `n` Features in the `overrideFeatureInstallOrder` array, the orchestrating tool should assign a `roundPriority` of `n - idx` to each Feature, where `idx` is the zero-based index of the Feature in the array.

For example:

```javascript
overrideFeatureInstallOrder = [
  "foo",
  "bar",
  "baz"
]
```

would result in the following `roundPriority` assignments:

```javascript
const roundPriority = {
  "foo": 3,
  "bar": 2,
  "baz": 1
}
```

This property must not influence the dependency relationship as defined by the dependency graph (see [dependency graph](#1-build-a-dependency-graph)) and shall only be evaulated at the round-based sorting step (see [round sort](#3-round-based-sorting)).  Put another way, this property cannot "pull forward" a Feature until all of its dependencies (both soft and hard) have been installed.  After a Feature's dependencies have been installed in other rounds, this property should "pull forward" each Feature as early as possible (given the order of identifiers in the array).

Similar to `installsAfter`, this property's members may not provide options, nor are they able to be pinned to a specific version tag or digest.

If a Feature is indicated in `overrideFeatureInstallOrder` but not a member of the dependency graph (it is not queued to be installed), the orchestrating tool may fail the dependency resolution step.

> ## Definitions
> ### <a href="#definition-feature-equality" name="definition-feature-equality" class="anchor">  Definition: Feature Equality </a>

>
> This specification defines two Features as equal if both Features point to the same exact contents and are executed with > the same options.
> 
> **For Features published to an OCI registry**, two Feature are identical if their manifest digests are equal, and the > options executed against the Feature are equal (compared value by value).  Identical manifest digests implies that the tgz  contents of the Feature and its entire `devcontainer-feature.json` are identical.  If any of these conditions are not met,  the Features are considered not equal.
> 
> **For Features fetched by HTTPS URI**, two Features are identical if the contents of the tgz are identical (hash to the > same value), and the options executed against the Feature are equal (compared value by value).  If any of these conditions  are not met, the Features are considered not equal.
> 
> **For local Features**, each Feature is considered unique and not equal to any other local Feature.
> 
> ### <a href="#definition-feature-equality" name="definition-feature-equality" class="anchor"> Definition: Round Stable Sort </a>

> 
> To prevent non-deterministic behavior, the algorithm will sort each **round** according to the following rules:
> 
> - Compare and sort each Feature lexiographically by their fully qualified resource name (For OCI-published Features, that  means the ID without version or digest.).  If the comparison is equal:
> - Compare and sort each Feature from oldest to newest tag (`latest` being the "most new").  If the comparision is equal:
> - Compare and sort each Feature by their options by:
>   - Greatest number of user-defined options (note omitting an option will default that value to the Feature's default value  and is not considered a user-defined option). If the comparison is equal:
>   - Sort the provided option keys lexicographically.  If the comparison is equal:
>   - Sort the provided option values lexicographically. If the comparision is equal:
> - Sort Features by their canonical name (For OCI-published Features, the Feature ID resolved to the digest hash).
> 
> If there is no difference based on these comparator rules, the Features are considered equal.

> ## <a href="#dependency-installation-order-algorithm" name="dependency-installation-order-algorithm" class="anchor"> Dependency installation order algorithm </a>
>
> An implementing tool is responsible for calculating the Feature installation order (or providing an error if no valid installation order can be resolved). The set of Features to be installed is the union of user-defined Features (those directly indicated in the user's `devcontainer.json` and their dependencies (those indicated by the `dependsOn` or `installsAfter` property, taking into account the user dev container's `overrideFeatureInstallOrder` property).  The implmenting tool will perform the following steps:
>
> ### (1) Build a dependency graph
> 
> From the user-defined Features, the orchestrating tool will build a dependency graph.  The graph will be built by traversing the `dependsOn` and `installsAfter` properties of each Feature.  The metadata for each dependency is then fetched and the node added as an edge to to the dependent Feature.  For `dependsOn`  dependencies, the dependency will be fed back into the worklist to be recursively resolved. 
> 
> An accumulator is maintained with all uniquely discovered and user-provided Features, each with a reference to its dependencies.  If the exact Feature (see **Feature Equality**) has already been added to the accumulator, it will not be added again.  The accumulator will be fed into (B3) after the Feature tree has  been resolved.
> 
> The graph may be stored as an adjacency list with two kinds of edges (1) `dependsOn` edges or "hard dependencies" and (2) `installsAfter` edges or "soft dependencies".
> 
> ### (2) Assigning round priority
> 
> Each node in the graph has an implicit, default `roundPriority` of 0.
> 
> To influence installation order globally while still honoring the dependency graph of built in **(1)**, `roundPriority` values may be tweaks for each Feature.  When each round is calculated in **(3)**, only the Features equal to the max `roundPriority` of that set will be committed (the remaining will be > uncommitted and reevaulated in subsequent rounds).
> 
> The `roundPriority` is set to a non-zero value in the following instances:
> 
> - If the [`devcontainer.json` contains an `overrideFeatureInstallOrder`](#overrideFeatureInstallOrder).
> 
> #### (3) Round-based sorting
> 
> Perform a sort on the result of **(1)** in rounds. This sort will rearrange Features, producing a sorted list of Features to install.  The sort will be performed as follows: 
> 
> Start with all the elements from **(2)** in a `worklist` and an empty list `installationOrder`.  While the `worklist` is not empty, iterate through each element in the `worklist` and check if all its dependencies (if any) are already members of `installationOrder`.  If the check is true, add it to an intermediate  list `round` If not, skip it.  Equality is determined in **Feature Equality**.
> 
> Then for each intermediate `round` list, commit to `installationOrder` only those nodes who share the maximum `roundPriority`.  Return all nodes in `round` with a strictly lower `roundPriority` to the `worklist` to be reprocessed in subsequent iterations.  If there are multiple nodes with the same `roundPriority`,  commit them to `installationOrder` with a final sort according to **Round Stable Sort**.
> 
> Repeat for as many rounds as necessary until `worklist` is empty.  If there is ever a round where no elements are added to `installationOrder`, the algorithm should terminate and return an error.  This indicates a circular dependency or other fatal error in the dependency graph.  Implementations should attempt to  provide the user with information about the error and possible mitigation strategies.
>
> ### Notes
>
> From an implementation point of view, `installsAfter` nodes may be added as a separate set of directed edges, just as `dependsOn` nodes are added as directed edges (see **(1)**).  Before round-based installation and sorting **(3)**, an orchestrating tool should remove all `installsAfter` directed edges that do not correspond with a Feature in the `worklist` that is set to be installed.  In each round, a Feature can then be installed if all its requirements (both `dependsOn` and `installsAfter` dependencies) have been fulfilled in previous rounds.
> 
> An implemention should fail the dependency resolution step if the evaluation of the `installsAfter` property results in an inconsistent state (eg: a circular dependency).
>

### <a href="#option-resolution" name="option-resolution" class="anchor"> Option Resolution </a>

A Feature's `options` - specified as the value of a single Feature key/value pair in the user's `devcontainer.json` - are passed to the Feature as environment variables.

A supporting tool will parse the `options` object provided by the user.  If a value is provided for a Feature, it will be emitted to a file named `devcontainer-features.env` following the format `<OPTION_NAME>=<value>`.  

To ensure a option that is valid as an environment variable, the follow substitutions are performed:

```javascript
(str: string) => str
	.replace(/[^\w_]/g, '_')
	.replace(/^[\d_]+/g, '_')
	.toUpperCase();
```

This file is sourced at build-time for the feature `install.sh` entrypoint script to handle.

Any options defined by a feature's `devcontainer-feature.json` that are omitted in the user's `devcontainer.json` will be implicitly exported as its default value.

### <a href="#option-resolution-example" name="option-resolution-example" class="anchor"> Option resolution example </a>

Suppose a `python` Feature has the following `options` parameters declared in the `devcontainer-feature.json` file:

```jsonc
// ...
"options": {
    "version": {
        "type": "string",
        "enum": ["latest", "3.10", "3.9", "3.8", "3.7", "3.6"],
        "default": "latest",
        "description": "Select a Python version to install."
    },
    "pip": {
        "type": "boolean",
        "default": true,
        "description": "Installs pip"
    },
    "optimize": {
        "type": "boolean",
        "default": true,
        "description": "Optimize python installation"
    }
}
```

The user's `devcontainer.json` declared the python Feature like so:

```jsonc

"features": {
    "ghcr.io/devcontainers/features/python:1": {
        "version": "3.10",
        "pip": false
    }
}
```
The emitted environment variables will be:

```bash
VERSION="3.10"
PIP="false"
OPTIMIZE="true"
```

These will be sourced and visible to the `install.sh` entrypoint script.  The following `install.sh`...

```bash
#!/usr/bin/env bash

echo "Version is $VERSION"
echo "Pip? $PIP"
echo "Optimize? $OPTIMIZE"
```

... outputs the following:
```
Version is 3.10
Pip? false
Optimize? true
```

### <a href="#steps-to-rename-a-feature" name="steps-to-rename-a-feature" class="anchor"> Steps to rename a Feature </a>

1. Update the Feature [source code](./features-distribution.md#source-code) folder and the `id` property in the [devcontainer-feature.json properties](#devcontainer-featurejson-properties) to reflect the new `id`. Other properties (`name`, `documentationUrl`, etc.) can optionally be updated during this step.
2. Add or update the `legacyIds` property to the Feature, including the previously used `id`.
3. Bump the semantic version of the Feature.  
4. Rerun the `devcontainer features publish` command, or equivalent tool that implements the [Features distribution specification](./features-distribution.md#distribution).

#### Example: Renaming a Feature

Let's say we currently have a `docker-from-docker` Feature 👇 

Current `devcontainer-feature.json` : 

```jsonc
{
    "id": "docker-from-docker",
    "version": "2.0.1",
    "name": "Docker (Docker-from-Docker)",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/docker-from-docker",
    ....
}
```

We'd want to rename this Feature to `docker-outside-of-docker`. The source code folder of the Feature will be updated to `docker-outside-of-docker` and the updated `devcontainer-feature.json` will look like 👇 

```jsonc
{
    "id": "docker-outside-of-docker",
    "version": "2.0.2",
    "name": "Docker (Docker-outside-of-Docker)",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/docker-outside-of-docker",
    "legacyIds": [
        "docker-from-docker"
    ]
    ....
}
```

**Note** - The semantic version of the Feature defined by the `version` property should be **continued** and should not be restarted at `1.0.0`.

### <a href="#implementation-notes" name="implementation-notes" class="anchor"> Implementation notes </a>

There are several things to keep in mind for an application that implements Features:

- The order of execution of Features is determined by the application, based on the `installsAfter` property used by Feature authors. It can be overridden by users if necessary with the `overrideFeatureInstallOrder` in `devcontainer.json`.
- Features are used to create an image that can be used to create a container or not.
- Parameters like `privileged`, `init` are included if just 1 feature requires them.
- Parameters like `capAdd`, `securityOp`  are concatenated.
- `containerEnv` is added before the feature is executed as `ENV` commands in the Dockerfile.
- Each Feature script executes as its own layer to aid in caching and rebuilding.



================================================
FILE: _implementors/json_reference.md
================================================
---
layout: implementors
title:  "Dev Container metadata reference"
shortTitle: "Dev Container metadata reference"
author: Microsoft
index: 4
---

The `devcontainer.json` file contains any needed metadata and settings required to configurate a **development container** for a given well-defined tool and runtime stack. It can be used by [tools and services that support the dev container spec](../../supporting) to create a **development environment** that contains one or more **development containers**.

Metadata properties marked with a 🏷️️ can be stored in the `devcontainer.metadata` **[container image label](/implementors/reference/#labels)** in addition to `devcontainer.json`. This label can contain an array of json snippets that will be automatically merged with `devcontainer.json` contents (if any) when a container is created.

## <a href="#general-properties" name="general-properties" class="anchor"> General devcontainer.json properties </a>

| Property | Type  | Description |
|:------------------|:------------|:------------|
| `name` | string | A name for the dev container displayed in the UI. |
| `forwardPorts` 🏷️ | array | An array of port numbers or `"host:port"` values  (e.g. `[3000, "db:5432"]`) that should always be forwarded from inside the primary container to the local machine (including on the web). The property is most useful for forwarding ports that cannot be auto-forwarded because the related process that starts before the `devcontainer.json` supporting service / tool connects or for forwarding a service not in the primary container in Docker Compose scenarios (e.g. `"db:5432"`). Defaults to `[]`. |
| `portsAttributes` 🏷️ | object | Object that maps a port number, `"host:port"` value, range, or regular expression to a set of default options. See [port attributes](#port-attributes) for available options. For example: <br />`"portsAttributes": {"3000": {"label": "Application port"}}` |
| `otherPortsAttributes` 🏷️ | object | Default options for ports, port ranges, and hosts that aren't configured using `portsAttributes`. See [port attributes](#port-attributes) for available options. For example: <br /> `"otherPortsAttributes": {"onAutoForward": "silent"}` |
| `containerEnv` 🏷️ | object | A set of name-value pairs that sets or overrides environment variables for the container. Environment and [pre-defined variables](#variables-in-devcontainerjson) may be referenced in the values. For example:<br/> `"containerEnv": { "MY_VARIABLE": "${localEnv:MY_VARIABLE}" }`<br /> If you want to reference an existing container variable while setting this one (like updating the `PATH`), use `remoteEnv` instead. <br /> `containerEnv` will set the variable on the Docker container itself, so all processes spawned in the container will have access to it. But it will also be static for the life of the container - you must rebuild the container to update the value. <br /> We recommend using `containerEnv` (over `remoteEnv`) as much as possible since it allows all processes to see the variable and isn't client-specific. |
| `remoteEnv` 🏷️ | object | A set of name-value pairs that sets or overrides environment variables for the `devcontainer.json` supporting service / tool (or sub-processes like terminals) but not the container as a whole. Environment and [pre-defined variables](#variables-in-devcontainerjson) may be referenced in the values. <br /> You may want to use `remoteEnv` (over `containerEnv`) if the value isn't static since you can update its value without having to rebuild the full container. |
| `remoteUser` 🏷️ | string | Overrides the user that `devcontainer.json` supporting services tools / runs as in the container (along with sub-processes like terminals, tasks, or debugging). Does not change the user the container as a whole runs as which can be set using `containerUser`. Defaults to the user the container as a whole is running as (often `root`). <br /> You may learn more in the [remoteUser section below](#remoteUser). |
| `containerUser` 🏷️ | string | Overrides the user for all operations run as inside the container. Defaults to either `root` or the last `USER` instruction in the related Dockerfile used to create the image. If you want any connected tools or related processes to use a different user than the one for the container, see `remoteUser`. |
| `updateRemoteUserUID` 🏷️ | boolean | On Linux, if `containerUser` or `remoteUser` is specified, the user's UID/GID will be updated to match the local user's UID/GID to avoid permission problems with bind mounts. Defaults to `true`. |
| `userEnvProbe` 🏷️ | enum | Indicates the type of shell to use to "probe" for user environment variables to include in `devcontainer.json` supporting services' / tools' processes: `none`, `interactiveShell`, `loginShell`, or `loginInteractiveShell` (default). The specific shell used is based on the default shell for the user (typically bash). For example, bash interactive shells will typically include variables set in `/etc/bash.bashrc` and `~/.bashrc` while login shells usually include variables from `/etc/profile` and `~/.profile`. Setting this property to `loginInteractiveShell` will get variables from all four files. |
| `overrideCommand` 🏷️ | boolean | Tells `devcontainer.json` supporting services / tools whether they should run `/bin/sh -c "while sleep 1000; do :; done"` when starting the container instead of the container's default command (since the container can shut down if the default command fails). Set to `false` if the default command must run for the container to function properly. Defaults to `true` for when using an image Dockerfile and `false` when referencing a Docker Compose file. |
| `shutdownAction` 🏷️ | enum | Indicates whether `devcontainer.json` supporting tools should stop the containers when the related tool window is closed / shut down.<br>Values are  `none`, `stopContainer` (default for image or Dockerfile), and `stopCompose` (default for Docker Compose). |
| `init` 🏷️ | boolean | Defaults to `false`. Cross-orchestrator way to indicate whether the [tini init process](https://github.com/krallin/tini) should be used to help deal with zombie processes. |
| `privileged` 🏷️ | boolean | Defaults to `false`. Cross-orchestrator way to cause the container to run in privileged mode (`--privileged`). Required for things like Docker-in-Docker, but has security implications particularly when running directly on Linux. |
| `capAdd` 🏷️ | array | Defaults to `[]`. Cross-orchestrator way to add capabilities typically disabled for a container. Most often used to add the `ptrace` capability required to debug languages like C++, Go, and Rust. For example: <br />`"capAdd": ["SYS_PTRACE"]` |
| `securityOpt` 🏷️ | array | Defaults to `[]`. Cross-orchestrator way to set container security options. For example: <br /> `"securityOpt": [ "seccomp=unconfined" ]` |
| `mounts` 🏷️ | string or object | Defaults to unset. Cross-orchestrator way to add additional mounts to a container. Each value is a string that accepts the same values as the [Docker CLI `--mount` flag](https://docs.docker.com/engine/reference/commandline/run/#mount). Environment and [pre-defined variables](#variables-in-devcontainerjson) may be referenced in the value. For example:<br />`"mounts": [{ "source": "dind-var-lib-docker", "target": "/var/lib/docker", "type": "volume" }]` |
| `features` | object | An object of [Dev Container Feature IDs](../../features) and related options to be added into your primary container. The specific options that are available varies by feature, so see its documentation for additional details. For example: <br />`"features": { "ghcr.io/devcontainers/features/github-cli": {} }` |
| `overrideFeatureInstallOrder` | array | By default, Features will attempt to automatically set the order they are installed based on a `installsAfter` property within each of them. This property allows you to override the Feature install order when needed. For example: <br />`"overrideFeatureInstallОrder": [ "ghcr.io/devcontainers/features/common-utils", "ghcr.io/devcontainers/features/github-cli" ]` |
| `customizations` 🏷️| object | Product specific properties, defined in [supporting tools](../../supporting) |
{: .table .table-bordered}

## <a href="#scenario-specific" name="scenario-specific" class="anchor"> Scenario specific properties </a>

The focus of `devcontainer.json` is to describe how to enrich a container for the purposes of development rather than acting as a multi-container orchestrator format. Instead, container orchestrator formats can be referenced when needed to manage multiple containers and their lifecycles. Today, `devcontainer.json` includes scenario specific properties for working without a container orchestrator (by directly referencing an image or Dockerfile) and for using Docker Compose as a simple multi-container orchestrator.

### <a href="#image-specific" name="image-specific" class="anchor"> Image or Dockerfile specific properties </a>

| Property | Type  | Description |
|:------------------|:------------|:------------|
| `image` | string | **Required** when using an image. The name of an image in a container registry ([DockerHub](https://hub.docker.com), [GitHub Container Registry](https://docs.github.com/packages/guides/about-github-container-registry), [Azure Container Registry](https://azure.microsoft.com/services/container-registry/)) that `devcontainer.json` supporting services / tools should use to create the dev container. |
| `build.dockerfile` | string |**Required** when using a Dockerfile. The location of a [Dockerfile](https://docs.docker.com/engine/reference/builder/) that defines the contents of the container. The path is relative to the `devcontainer.json` file. |
| `build.context` | string | Path that the Docker build should be run from relative to `devcontainer.json`. For example, a value of `".."` would allow you to reference content in sibling directories. Defaults to `"."`. |
| `build.args` | Object | A set of name-value pairs containing [Docker image build arguments](https://docs.docker.com/engine/reference/commandline/build/#build-arg) that should be passed when building a Dockerfile.  Environment and [pre-defined variables](#variables-in-devcontainerjson) may be referenced in the values. Defaults to not set. For example: `"build": { "args": { "MYARG": "MYVALUE", "MYARGFROMENVVAR": "${localEnv:VARIABLE_NAME}" } }` |
| `build.options` | array | An array of [Docker image build options](https://docs.docker.com/engine/reference/commandline/build/#options) that should be passed to the build command when building a Dockerfile. Defaults to `[]`. For example: `"build": { "options": [ "--add-host=host.docker.internal:host-gateway" ] }` |
| `build.target` | string | A string that specifies a [Docker image build target](https://docs.docker.com/engine/reference/commandline/build/#target) that should be passed when building a Dockerfile. Defaults to not set. For example: `"build": { "target": "development" }` |
| `build.cacheFrom` | string,<br>array | A string or array of strings that specify one or more images to use as caches when building the image. Cached image identifiers are passed to the `docker build` command with `--cache-from`. |
| `appPort` | integer,<br>string,<br>array |  In most cases, we recommend using the new [forwardPorts property](#general-properties). This property accepts a port or array of ports that should be published locally when the container is running. Unlike `forwardPorts`, your application may need to listen on all interfaces (`0.0.0.0`) not just `localhost` for it to be available externally. Defaults to `[]`.<br>Learn more about publishing vs forwarding ports [here](#publishing-vs-forwarding-ports).<br>Note that the array syntax will execute the command without a shell. You can [learn more](#formatting-string-vs-array-properties) about formatting string vs array properties. |
| `workspaceMount` | string | Requires `workspaceFolder` be set as well. Overrides the default local mount point for the workspace when the container is created. Supports the same values as the [Docker CLI `--mount` flag](https://docs.docker.com/engine/reference/commandline/run/#mount). Environment and [pre-defined variables](#variables-in-devcontainerjson) may be referenced in the value. For example: <br />`"workspaceMount": "source=${localWorkspaceFolder}/sub-folder,target=/workspace,type=bind,consistency=cached", "workspaceFolder": "/workspace"` |
| `workspaceFolder` | string | Requires `workspaceMount` be set. Sets the default path that `devcontainer.json` supporting services / tools should open when connecting to the container. Defaults to the automatic source code mount location. |
| `runArgs` | array | An array of [Docker CLI arguments](https://docs.docker.com/engine/reference/commandline/run/) that should be used when running the container. Defaults to `[]`. For example, this allows ptrace based debuggers like C++ to work in the container:<br /> `"runArgs": [ "--cap-add=SYS_PTRACE", "--security-opt", "seccomp=unconfined" ]` . |
{: .table .table-bordered}

### <a href="#compose-specific" name="compose-specific" class="anchor"> Docker Compose specific properties </a>

| Property | Type  | Description |
|:------------------|:------------|:------------|
| `dockerComposeFile` | string,<br>array | **Required** when using [Docker Compose](https://docs.docker.com/compose/). Path or an ordered list of paths to Docker Compose files relative to the `devcontainer.json` file. Using an array is useful [when extending your Docker Compose configuration](https://docs.docker.com/compose/extends/#multiple-compose-files). The order of the array matters since the contents of later files can override values set in previous ones.<br>The default `.env` file is picked up from the root of the project, but you can use `env_file` in your Docker Compose file to specify an alternate location.<br>Note that the array syntax will execute the command without a shell. You can [learn more](#formatting-string-vs-array-properties) about formatting string vs array properties. |
| `service` | string | **Required** when using [Docker Compose](https://docs.docker.com/compose/). The name of the service `devcontainer.json` supporting services / tools should connect to once running. |
| `runServices` | array | An array of services in your Docker Compose configuration that should be started by `devcontainer.json` supporting services / tools. These will also be stopped when you disconnect unless `"shutdownAction"` is `"none"`. Defaults to all services. |
| `workspaceFolder` | string | Sets the default path that `devcontainer.json` supporting services / tools should open when connecting to the container (which is often the path to a volume mount where the source code can be found in the container). Defaults to `"/"`. |
{: .table .table-bordered}

## <a href="#tool-specific" name="tool-specific" class="anchor"> Tool-specific properties </a>

While most properties apply to any `devcontainer.json` supporting tool or service, a few are specific to certain tools. You may explore this in the [supporting tools and services document](../../supporting).

## <a href="#lifecycle-scripts" name="lifecycle-scripts" class="anchor"> Lifecycle scripts </a>

When creating or working with a dev container, you may need different commands to be run at different points in the container's lifecycle. The table below lists a set of command properties you can use to update what the container's contents in the order in which they are run (for example, `onCreateCommand` will run after `initializeCommand`). Each command property is an string or list of command arguments that should execute from the `workspaceFolder`.

| Property | Type  | Description |
|:------------------|:------------|:------------|
| `initializeCommand` | string,<br>array,<br>object | A command string or list of command arguments to run on the **host machine** during initialization, including during container creation and on subsequent starts.  The command may run more than once during a given session.<br /><br /> ⚠️ The command is run wherever the source code is located on the host. For cloud services, this is in the cloud.<br><br>Note that the array syntax will execute the command without a shell. You can [learn more](#formatting-string-vs-array-properties) about formatting string vs array vs object properties. |
| `onCreateCommand` 🏷️ | string,<br>array,<br>object | This command is the first of three (along with `updateContentCommand` and `postCreateCommand`) that finalizes container setup when a dev container is created. It and subsequent commands execute **inside** the container immediately after it has started for the first time.<br /><br> Cloud services can use this command when caching or prebuilding a container. This means that it will not typically have access to user-scoped assets or secrets.<br><br>Note that the array syntax will execute the command without a shell. You can [learn more](#formatting-string-vs-array-properties) about formatting string vs array vs object properties. |
| `updateContentCommand` 🏷️ | string,<br>array,<br>object  | This command is the second of three that finalizes container setup when a dev container is created. It executes inside the container after `onCreateCommand` whenever new content is available in the source tree during the creation process.<br><br />It will execute at least once, but cloud services will also periodically execute the command to refresh cached or prebuilt containers. Like cloud services using `onCreateCommand`, it can only take advantage of repository and org scoped secrets or permissions.<br><br>Note that the array syntax will execute the command without a shell. You can [learn more](#formatting-string-vs-array-properties) about formatting string vs array vs object properties. |
| `postCreateCommand` 🏷️ | string,<br>array,<br>object | This command is the last of three that finalizes container setup when a dev container is created. It happens after `updateContentCommand` and once the dev container has been assigned to a user for the first time.<br><br />Cloud services can use this command to take advantage of user specific secrets and permissions.<br><br>Note that the array syntax will execute the command without a shell. You can [learn more](#formatting-string-vs-array-properties) about formatting string vs array vs object properties. |
| `postStartCommand` 🏷️ | string,<br>array,<br>object | A command to run each time the container is successfully started.<br><br>Note that the array syntax will execute the command without a shell. You can [learn more](#formatting-string-vs-array-properties) about formatting string vs array vs object properties. |
| `postAttachCommand` 🏷️ | string,<br>array,<br>object | A command to run each time a tool has successfully attached to the container.<br><br>Note that the array syntax will execute the command without a shell. You can [learn more](#formatting-string-vs-array-properties) about formatting string vs array vs object properties. |
| `waitFor` 🏷️ | enum | An enum that specifies the command any tool should wait for before connecting. Defaults to `updateContentCommand`. This allows you to use `onCreateCommand` or `updateContentCommand` for steps that must happen before `devcontainer.json` supporting tools connect while still using `postCreateCommand` for steps that can happen behind the scenes afterwards. |
{: .table .table-bordered}

For each command property, if the value is a single string, it will be run in `/bin/sh`. Use `&&` in a string to execute multiple commands. For example, `"yarn install"` or `"apt-get update && apt-get install -y curl"`. The array syntax `["yarn", "install"]` will invoke the command (in this case `yarn`) directly without using a shell. Each fires after your source code has been mounted, so you can also run shell scripts from your source tree. For example: `bash scripts/install-dev-tools.sh`.

If one of the lifecycle scripts fails, any subsequent scripts will not be executed. For instance, if `postCreateCommand` fails, `postStartCommand` and any following scripts will be skipped.

## <a href="#min-host-reqs" name="min-host-reqs" class="anchor"> Minimum host requirements </a>

While `devcontainer.json` does not focus on hardware or VM provisioning, it can be useful to know your container's minimum RAM, CPU, and storage requirements. This is what the `hostRequirements` properties allow you to do. Cloud services can use these properties to automatically default to the best compute option available, while in other cases, you will be presented with a warning if the requirements are not met.

| Property | Type  | Description |
|:------------------|:------------|:------------|
| `hostRequirements.cpus` 🏷️ | integer | Indicates the minimum required number of CPUs / virtual CPUs / cores. For example: `"hostRequirements": {"cpus": 2}` |
| `hostRequirements.memory` 🏷️ | string |  A string indicating minimum memory requirements with a `tb`, `gb`, `mb`, or `kb` suffix. For example, `"hostRequirements": {"memory": "4gb"}` |
| `hostRequirements.storage` 🏷️ | string | A string indicating minimum storage requirements with a `tb`, `gb`, `mb`, or `kb` suffix. For example, `"hostRequirements": {"storage": "32gb"}` |
| `hostRequirements.gpu` 🏷️ | boolean,<br>string,<br>object | Indicates if any GPU is required. A boolean indicates if a GPU is required or not. The string `"optional"` indicates that a GPU is used when available, but is not required.<br><br>The object syntax specifies how much GPU resources are required. The `cores` property indicates the minimum number of cores and the `memory` property indicates minimum storage requirements with a `tb`, `gb`, `mb`, or `kb` suffix. For example, `"gpu": { "cores": 1000, "storage": "32gb" }` |
 {: .table .table-bordered}

## <a href="#port-attributes" name="port-attributes" class="anchor"> Port attributes </a>

The `portsAttributes` and `otherPortsAttributes` properties allow you to map default port options for one or more manually or automatically forwarded ports. The following is a list of options that can be set in the configuration object assigned to the property.

| Property | Type  | Description |
|:------------------|:------------|:------------|
| `label` 🏷️ | string | Display name for the port in the ports view. Defaults to not set. |
| `protocol` 🏷️ | enum | Controls protocol handling for forwarded ports. When not set, the port is assumed to be a raw TCP stream which, if forwarded to `localhost`, supports any number of protocols. However, if the port is forwarded to a web URL (e.g. from a cloud service on the web), only HTTP ports in the container are supported. Setting this property to `https` alters handling by ignoring any SSL/TLS certificates present when communicating on the port and using the correct certificate for the forwarded URL instead (e.g `https://*.githubpreview.dev`). If set to `http`, processing is the same as if the protocol is not set. Defaults to not set. |
| `onAutoForward` 🏷️ | enum | Controls what should happen when a port is auto-forwarded once you've connected to the container. `notify` is the default, and a notification will appear when the port is auto-forwarded. If set to `openBrowser`, the port will be opened in the system's default browser. A value of `openBrowserOnce` will open the browser only once. `openPreview` will open the URL in `devcontainer.json` supporting services' / tools' embedded preview browser. A value of `silent` will forward the port, but take no further action. A value of `ignore` means that this port should not be auto-forwarded at all. |
| `requireLocalPort` 🏷️ | boolean | Dictates when port forwarding is required to map the port in the container to the same port locally or not. If set to `false`, the `devcontainer.json` supporting services /  tools will attempt to use the specified port forward to `localhost`, and silently map to a different one if it is unavailable. If set to `true`, you will be notified if it is not possible to use the same port. Defaults to `false`. |
| `elevateIfNeeded` 🏷️ | boolean | Forwarding low ports like 22, 80, or 443 to `localhost` on the same port from `devcontainer.json` supporting services / tools may require elevated permissions on certain operating systems. Setting this property to `true` will automatically try to elevate the `devcontainer.json` supporting tool's permissions in this situation. Defaults to `false`. |
{: .table .table-bordered}

## <a href="#formatting-string-vs-array-properties" name="formatting-string-vs-array-properties" class="anchor"> Formatting string vs. array properties </a>

The format of certain properties will vary depending on the involvement of a shell.

`postCreateCommand`, `postStartCommand`, `postAttachCommand`, and `initializeCommand` all have 3 types: 
* Array: Passed to the OS for execution without going through a shell
* String: Goes through a shell (it needs to be parsed into command and arguments)
* Object: All lifecycle scripts have been extended to support `object` types to allow for [parallel execution](https://containers.dev/implementors/spec/#parallel-exec)

`runArgs` only has the array type. Using `runArgs` via a typical command line, you'll need single quotes if the shell runs into parameters with spaces. However, these single quotes aren't passed on to the executable. Thus, in your `devcontainer.json`, you'd follow the array format and leave out the single quotes:

```json
"runArgs": ["--device-cgroup-rule=my rule here"]
```

Rather than:

```json
"runArgs": ["--device-cgroup-rule='my rule here'"]
```

We can compare the string, array, and object versions of `postAttachCommand` as well. You can use the following string format, which will remove the single quotes as part of the shell's parsing:

```json
"postAttachCommand": "echo foo='bar'"
```

By contrast, the array format will keep the single quotes and write them to standard out (you can see the output in the dev container log):

```json
"postAttachCommand": ["echo", "foo='bar'"]
```

Finally, you may use an object format:

```json
{
  "postAttachCommand": {
    "server": "npm start",
    "db": ["mysql", "-u", "root", "-p", "my database"]
  }
}
```

## <a href="#variables-in-devcontainerjson" name="variables-in-devcontainerjson" class="anchor"> Variables in devcontainer.json </a>

Variables can be referenced in certain string values in `devcontainer.json` in the following format: **${variableName}**. The following is a list of available variables you can use.

| Variable | Properties | Description |
|:------------------|:------------|:------------|
| `${localEnv:VARIABLE_NAME}` | Any | Value of an environment variable on the **host machine** (in the examples below, called `VARIABLE_NAME`). Unset variables are left blank. <br /><br />  ⚠️ Clients (like VS Code) may need to be **restarted** to pick up newly set variables. <br /><br /> ⚠️ For a cloud service, the host is in the cloud rather than your local machine. <br /><br /> **Examples** <br /><br /> **1.** Set a variable containing your local home folder on Linux / macOS or the user folder on Windows:<br/> `"remoteEnv": { "LOCAL_USER_PATH": "${localEnv:HOME}${localEnv:USERPROFILE}" }`.   <br /><br /> A default value for when the environment variable is not set can be given with `${localEnv:VARIABLE_NAME:default_value}`.  <br /><br />  **2.** In modern versions of macOS, default configurations allow setting local variables with the command `echo 'export VARIABLE_NAME=my-value' >> ~/.zshenv`.  |
| `${containerEnv:VARIABLE_NAME}` | `remoteEnv` | Value of an existing environment variable inside the container once it is up and running (in this case, called `VARIABLE_NAME`). For example:<br /> `"remoteEnv": { "PATH": "${containerEnv:PATH}:/some/other/path" }` <br /><br /> A default value for when the environment variable is not set can be given with `${containerEnv:VARIABLE_NAME:default_value}`. |
| `${localWorkspaceFolder}`  | Any | Path of the local folder that was opened in the `devcontainer.json` supporting service / tool (that contains `.devcontainer/devcontainer.json`). |
| `${containerWorkspaceFolder}` | Any | The path that the workspaces files can be found in the container. |
| `${localWorkspaceFolderBasename}` | Any | Name of the local folder that was opened in the `devcontainer.json` supporting service / tool (that contains `.devcontainer/devcontainer.json`). |
| `${containerWorkspaceFolderBasename}` | Any | Name of the folder where the workspace files can be found in the container. |
| `${devcontainerId}` | Any | Allow Features to refer to an identifier that is unique to the dev container they are installed into and that is stable across rebuilds.<br> The properties supporting it in devcontainer.json are: `name`, `runArgs`, `initializeCommand`, `onCreateCommand`, `updateContentCommand`, `postCreateCommand`, `postStartCommand`, `postAttachCommand`, `workspaceFolder`, `workspaceMount`, `mounts`, `containerEnv`, `remoteEnv`, `containerUser`, `remoteUser`, and `customizations`. |
{: .table .table-bordered}

## <a href="#schema" name="schema" class="anchor"> Schema </a>

You can see the dev container schema [here](https://github.com/devcontainers/spec/blob/main/schemas/devContainer.base.schema.json).

## <a href="#publishing-vs-forwarding-ports" name="publishing-vs-forwarding-ports" class="anchor"> Publishing vs forwarding ports </a>

Docker has the concept of "publishing" ports when the container is created. Published ports behave very much like ports you make available to your local network. If your application only accepts calls from `localhost`, it will reject connections from published ports just as your local machine would for network calls. Forwarded ports, on the other hand, actually look like `localhost` to the application.

## <a href="#remoteUser" name="remoteUser" class="anchor"> remoteUser </a>

A dev container configuration will inherit the `remoteUser` property from the base image it uses.

Using the [images](https://github.com/devcontainers/images) and [Templates](https://github.com/devcontainers/templates) part of the spec as an example: `remoteUser` in these images is set to a custom value - you may view an example in the [C++ image](https://github.com/devcontainers/images/blob/main/src/cpp/.devcontainer/devcontainer.json#L26). The [C++ Template](https://github.com/devcontainers/templates/tree/main/src/cpp) will then inherit the custom `remoteUser` value from [its base C++ image](https://github.com/devcontainers/templates/blob/main/src/cpp/.devcontainer/Dockerfile#L1).



================================================
FILE: _implementors/json_schema.md
================================================
---
layout: implementors
title:  "devcontainer.json schema"
shortTitle: "devcontainer.json schema"
author: Microsoft
index: 3
---

You may review the current devcontainer.json schemas in the spec repo, which include:
* The [base schema](https://github.com/devcontainers/spec/blob/main/schemas/devContainer.base.schema.json): schema describing all base properties as documented in the [devcontainer.json reference](../json_reference).
* The [main schema](https://github.com/devcontainers/spec/blob/main/schemas/devContainer.schema.json): references the base schema, plus all schemas containing tool-specific properties.

## <a href="#base-schema" name="base-schema" class="anchor"> Base Schema </a>

```json
{
	"$schema": "http://json-schema.org/draft-07/schema#",
	"description": "Defines a dev container",
	"allowComments": true,
	"allowTrailingCommas": false,
	"definitions": {
		"devContainerCommon": {
			"type": "object",
			"properties": {
				"name": {
					"type": "string",
					"description": "A name for the dev container which can be displayed to the user."
				},
				"features": {
					"type": "object",
					"description": "Features to add to the dev container.",
					"additionalProperties": true
				},
				"overrideFeatureInstallOrder": {
					"type": "array",
					"description": "Array consisting of the Feature id (without the semantic version) of Features in the order the user wants them to be installed.",
					"items": {
						"type": "string"
					}
				},
				"forwardPorts": {
					"type": "array",
					"description": "Ports that are forwarded from the container to the local machine. Can be an integer port number, or a string of the format \"host:port_number\".",
					"items": {
						"oneOf": [
							{
								"type": "integer",
								"maximum": 65535,
								"minimum": 0
							},
							{
								"type": "string",
								"pattern": "^([a-z0-9-]+):(\\d{1,5})$"
							}
						]
					}
				},
				"portsAttributes": {
					"type": "object",
					"patternProperties": {
						"(^\\d+(-\\d+)?$)|(.+)": {
							"type": "object",
							"description": "A port, range of ports (ex. \"40000-55000\"), or regular expression (ex. \".+\\\\/server.js\").  For a port number or range, the attributes will apply to that port number or range of port numbers. Attributes which use a regular expression will apply to ports whose associated process command line matches the expression.",
							"properties": {
								"onAutoForward": {
									"type": "string",
									"enum": [
										"notify",
										"openBrowser",
										"openBrowserOnce",
										"openPreview",
										"silent",
										"ignore"
									],
									"enumDescriptions": [
										"Shows a notification when a port is automatically forwarded.",
										"Opens the browser when the port is automatically forwarded. Depending on your settings, this could open an embedded browser.",
										"Opens the browser when the port is automatically forwarded, but only the first time the port is forward during a session. Depending on your settings, this could open an embedded browser.",
										"Opens a preview in the same window when the port is automatically forwarded.",
										"Shows no notification and takes no action when this port is automatically forwarded.",
										"This port will not be automatically forwarded."
									],
									"description": "Defines the action that occurs when the port is discovered for automatic forwarding",
									"default": "notify"
								},
								"elevateIfNeeded": {
									"type": "boolean",
									"description": "Automatically prompt for elevation (if needed) when this port is forwarded. Elevate is required if the local port is a privileged port.",
									"default": false
								},
								"label": {
									"type": "string",
									"description": "Label that will be shown in the UI for this port.",
									"default": "Application"
								},
								"requireLocalPort": {
									"type": "boolean",
									"markdownDescription": "When true, a modal dialog will show if the chosen local port isn't used for forwarding.",
									"default": false
								},
								"protocol": {
									"type": "string",
									"enum": [
										"http",
										"https"
									],
									"description": "The protocol to use when forwarding this port."
								}
							},
							"default": {
								"label": "Application",
								"onAutoForward": "notify"
							}
						}
					},
					"markdownDescription": "Set default properties that are applied when a specific port number is forwarded. For example:\n\n```\n\"3000\": {\n  \"label\": \"Application\"\n},\n\"40000-55000\": {\n  \"onAutoForward\": \"ignore\"\n},\n\".+\\\\/server.js\": {\n \"onAutoForward\": \"openPreview\"\n}\n```",
					"defaultSnippets": [
						{
							"body": {
								"${1:3000}": {
									"label": "${2:Application}",
									"onAutoForward": "notify"
								}
							}
						}
					],
					"additionalProperties": false
				},
				"otherPortsAttributes": {
					"type": "object",
					"properties": {
						"onAutoForward": {
							"type": "string",
							"enum": [
								"notify",
								"openBrowser",
								"openPreview",
								"silent",
								"ignore"
							],
							"enumDescriptions": [
								"Shows a notification when a port is automatically forwarded.",
								"Opens the browser when the port is automatically forwarded. Depending on your settings, this could open an embedded browser.",
								"Opens a preview in the same window when the port is automatically forwarded.",
								"Shows no notification and takes no action when this port is automatically forwarded.",
								"This port will not be automatically forwarded."
							],
							"description": "Defines the action that occurs when the port is discovered for automatic forwarding",
							"default": "notify"
						},
						"elevateIfNeeded": {
							"type": "boolean",
							"description": "Automatically prompt for elevation (if needed) when this port is forwarded. Elevate is required if the local port is a privileged port.",
							"default": false
						},
						"label": {
							"type": "string",
							"description": "Label that will be shown in the UI for this port.",
							"default": "Application"
						},
						"requireLocalPort": {
							"type": "boolean",
							"markdownDescription": "When true, a modal dialog will show if the chosen local port isn't used for forwarding.",
							"default": false
						},
						"protocol": {
							"type": "string",
							"enum": [
								"http",
								"https"
							],
							"description": "The protocol to use when forwarding this port."
						}
					},
					"defaultSnippets": [
						{
							"body": {
								"onAutoForward": "ignore"
							}
						}
					],
					"markdownDescription": "Set default properties that are applied to all ports that don't get properties from the setting `remote.portsAttributes`. For example:\n\n```\n{\n  \"onAutoForward\": \"ignore\"\n}\n```",
					"additionalProperties": false
				},
				"updateRemoteUserUID": {
					"type": "boolean",
					"description": "Controls whether on Linux the container's user should be updated with the local user's UID and GID. On by default when opening from a local folder."
				},
				"remoteEnv": {
					"type": "object",
					"additionalProperties": {
						"type": [
							"string",
							"null"
						]
					},
					"description": "Remote environment variables to set for processes spawned in the container including lifecycle scripts and any remote editor/IDE server process."
				},
				"remoteUser": {
					"type": "string",
					"description": "The username to use for spawning processes in the container including lifecycle scripts and any remote editor/IDE server process. The default is the same user as the container."
				},
				"initializeCommand": {
					"type": [
						"string",
						"array"
					],
					"description": "A command string or list of command arguments to run on the host machine during initialization, including during container creation and on subsequent starts.  The command may run more than once during a given session. This command is run before \"onCreateCommand\". If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell.",

					"items": {
						"type": "string"
					}
				},
				"onCreateCommand": {
					"type": [
						"string",
						"array",
						"object"
					],
					"description": "A command to run when creating the container. This command is run after \"initializeCommand\" and before \"updateContentCommand\". If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell.",
					"items": {
						"type": "string"
					},
					"additionalProperties": {
						"type": [
							"string",
							"array"
						],
						"items": {
							"type": "string"
						}
					}
				},
				"updateContentCommand": {
					"type": [
						"string",
						"array",
						"object"
					],
					"description": "A command to run when creating the container and rerun when the workspace content was updated while creating the container. This command is run after \"onCreateCommand\" and before \"postCreateCommand\". If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell.",
					"items": {
						"type": "string"
					},
					"additionalProperties": {
						"type": [
							"string",
							"array"
						],
						"items": {
							"type": "string"
						}
					}
				},
				"postCreateCommand": {
					"type": [
						"string",
						"array",
						"object"
					],
					"description": "A command to run after creating the container. This command is run after \"updateContentCommand\" and before \"postStartCommand\". If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell.",
					"items": {
						"type": "string"
					},
					"additionalProperties": {
						"type": [
							"string",
							"array"
						],
						"items": {
							"type": "string"
						}
					}
				},
				"postStartCommand": {
					"type": [
						"string",
						"array",
						"object"
					],
					"description": "A command to run after starting the container. This command is run after \"postCreateCommand\" and before \"postAttachCommand\". If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell.",
					"items": {
						"type": "string"
					},
					"additionalProperties": {
						"type": [
							"string",
							"array"
						],
						"items": {
							"type": "string"
						}
					}
				},
				"postAttachCommand": {
					"type": [
						"string",
						"array",
						"object"
					],
					"description": "A command to run when attaching to the container. This command is run after \"postStartCommand\". If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell.",
					"items": {
						"type": "string"
					},
					"additionalProperties": {
						"type": [
							"string",
							"array"
						],
						"items": {
							"type": "string"
						}
					}
				},
				"waitFor": {
					"type": "string",
					"enum": [
						"initializeCommand",
						"onCreateCommand",
						"updateContentCommand",
						"postCreateCommand",
						"postStartCommand"
					],
					"description": "The user command to wait for before continuing execution in the background while the UI is starting up. The default is \"updateContentCommand\"."
				},
				"userEnvProbe": {
					"type": "string",
					"enum": [
						"none",
						"loginShell",
						"loginInteractiveShell",
						"interactiveShell"
					],
					"description": "User environment probe to run. The default is \"loginInteractiveShell\"."
				},
				"hostRequirements": {
					"type": "object",
					"description": "Host hardware requirements.",
					"allOf": [
						{
							"type": "object",
							"properties": {
								"cpus": {
									"type": "integer",
									"minimum": 1,
									"description": "Number of required CPUs."
								},
								"memory": {
									"type": "string",
									"pattern": "^\\d+([tgmk]b)?$",
									"description": "Amount of required RAM in bytes. Supports units tb, gb, mb and kb."
								},
								"storage": {
									"type": "string",
									"pattern": "^\\d+([tgmk]b)?$",
									"description": "Amount of required disk space in bytes. Supports units tb, gb, mb and kb."
								},
								"gpu": {
									"oneOf": [
										{
											"type": [
												"boolean",
												"string"
											],
											"enum": [
												true,
												false,
												"optional"
											],
											"description": "Indicates whether a GPU is required. The string \"optional\" indicates that a GPU is optional. An object value can be used to configure more detailed requirements."
										},
										{
											"type": "object",
											"properties": {
												"cores": {
													"type": "integer",
													"minimum": 1,
													"description": "Number of required cores."
												},
												"memory": {
													"type": "string",
													"pattern": "^\\d+([tgmk]b)?$",
													"description": "Amount of required RAM in bytes. Supports units tb, gb, mb and kb."
												}
											},
											"description": "Indicates whether a GPU is required. The string \"optional\" indicates that a GPU is optional. An object value can be used to configure more detailed requirements.",
											"additionalProperties": false
										}
									]
								}
							}
						}
					]
				},
				"customizations": {
					"type": "object",
					"description": "Tool-specific configuration. Each tool should use a JSON object subproperty with a unique name to group its customizations."
				},
				"additionalProperties": {
					"type": "object",
					"additionalProperties": true
				}
			}
		},
		"nonComposeBase": {
			"type": "object",
			"properties": {
				"appPort": {
					"type": [
						"integer",
						"string",
						"array"
					],
					"description": "Application ports that are exposed by the container. This can be a single port or an array of ports. Each port can be a number or a string. A number is mapped to the same port on the host. A string is passed to Docker unchanged and can be used to map ports differently, e.g. \"8000:8010\".",
					"items": {
						"type": [
							"integer",
							"string"
						]
					}
				},
				"containerEnv": {
					"type": "object",
					"additionalProperties": {
						"type": "string"
					},
					"description": "Container environment variables."
				},
				"containerUser": {
					"type": "string",
					"description": "The user the container will be started with. The default is the user on the Docker image."
				},
				"mounts": {
					"type": "array",
					"description": "Mount points to set up when creating the container. See Docker's documentation for the --mount option for the supported syntax.",
					"items": {
						"type": "string"
					}
				},
				"runArgs": {
					"type": "array",
					"description": "The arguments required when starting in the container.",
					"items": {
						"type": "string"
					}
				},
				"shutdownAction": {
					"type": "string",
					"enum": [
						"none",
						"stopContainer"
					],
					"description": "Action to take when the user disconnects from the container in their editor. The default is to stop the container."
				},
				"overrideCommand": {
					"type": "boolean",
					"description": "Whether to overwrite the command specified in the image. The default is true."
				},
				"workspaceFolder": {
					"type": "string",
					"description": "The path of the workspace folder inside the container."
				},
				"workspaceMount": {
					"type": "string",
					"description": "The --mount parameter for docker run. The default is to mount the project folder at /workspaces/$project."
				}
			}
		},
		"dockerfileContainer": {
			"oneOf": [
				{
					"type": "object",
					"properties": {
						"build": {
							"type": "object",
							"description": "Docker build-related options.",
							"allOf": [
								{
									"type": "object",
									"properties": {
										"dockerfile": {
											"type": "string",
											"description": "The location of the Dockerfile that defines the contents of the container. The path is relative to the folder containing the `devcontainer.json` file."
										},
										"context": {
											"type": "string",
											"description": "The location of the context folder for building the Docker image. The path is relative to the folder containing the `devcontainer.json` file."
										}
									},
									"required": [
										"dockerfile"
									]
								},
								{
									"$ref": "#/definitions/buildOptions"
								}
							]
						}
					},
					"required": [
						"build"
					]
				},
				{
					"allOf": [
						{
							"type": "object",
							"properties": {
								"dockerFile": {
									"type": "string",
									"description": "The location of the Dockerfile that defines the contents of the container. The path is relative to the folder containing the `devcontainer.json` file."
								},
								"context": {
									"type": "string",
									"description": "The location of the context folder for building the Docker image. The path is relative to the folder containing the `devcontainer.json` file."
								}
							},
							"required": [
								"dockerFile"
							]
						},
						{
							"type": "object",
							"properties": {
								"build": {
									"description": "Docker build-related options.",
									"$ref": "#/definitions/buildOptions"
								}
							}
						}
					]
				}
			]
		},
		"buildOptions": {
			"type": "object",
			"properties": {
				"target": {
					"type": "string",
					"description": "Target stage in a multi-stage build."
				},
				"args": {
					"type": "object",
					"additionalProperties": {
						"type": [
							"string"
						]
					},
					"description": "Build arguments."
				},
				"cacheFrom": {
					"type": [
						"string",
						"array"
					],
					"description": "The image to consider as a cache. Use an array to specify multiple images.",
					"items": {
						"type": "string"
					}
				}
			}
		},
		"imageContainer": {
			"type": "object",
			"properties": {
				"image": {
					"type": "string",
					"description": "The docker image that will be used to create the container."
				}
			},
			"required": [
				"image"
			]
		},
		"composeContainer": {
			"type": "object",
			"properties": {
				"dockerComposeFile": {
					"type": [
						"string",
						"array"
					],
					"description": "The name of the docker-compose file(s) used to start the services.",
					"items": {
						"type": "string"
					}
				},
				"service": {
					"type": "string",
					"description": "The service you want to work on. This is considered the primary container for your dev environment which your editor will connect to."
				},
				"runServices": {
					"type": "array",
					"description": "An array of services that should be started and stopped.",
					"items": {
						"type": "string"
					}
				},
				"workspaceFolder": {
					"type": "string",
					"description": "The path of the workspace folder inside the container. This is typically the target path of a volume mount in the docker-compose.yml."
				},
				"shutdownAction": {
					"type": "string",
					"enum": [
						"none",
						"stopCompose"
					],
					"description": "Action to take when the user disconnects from the primary container in their editor. The default is to stop all of the compose containers."
				},
				"overrideCommand": {
					"type": "boolean",
					"description": "Whether to overwrite the command specified in the image. The default is false."
				}
			},
			"required": [
				"dockerComposeFile",
				"service",
				"workspaceFolder"
			]
		}
	},
	"oneOf": [
		{
			"allOf": [
				{
					"oneOf": [
						{
							"allOf": [
								{
									"oneOf": [
										{
											"$ref": "#/definitions/dockerfileContainer"
										},
										{
											"$ref": "#/definitions/imageContainer"
										}
									]
								},
								{
									"$ref": "#/definitions/nonComposeBase"
								}
							]
						},
						{
							"$ref": "#/definitions/composeContainer"
						}
					]
				},
				{
					"$ref": "#/definitions/devContainerCommon"
				}
			]
		},
		{
			"type": "object",
			"$ref": "#/definitions/devContainerCommon",
			"additionalProperties": false
		}
	]
}
```

## <a href="#main-schema" name="main-schema" class="anchor"> Main Schema </a>

```json
{
    "allOf": [
        {
            "$ref": "./devContainer.base.schema.json"
        },
        {
            "$ref": "https://raw.githubusercontent.com/microsoft/vscode/main/extensions/configuration-editing/schemas/devContainer.codespaces.schema.json"
        },
        {
            "$ref": "https://raw.githubusercontent.com/microsoft/vscode/main/extensions/configuration-editing/schemas/devContainer.vscode.schema.json"
        }
    ]
}
```



================================================
FILE: _implementors/reference.md
================================================
---
layout: implementors
title:  "Reference Implementation"
shortTitle: "Reference Implementation"
author: Microsoft
index: 2
---

The reference implementation for the specification is available through a [development container CLI](https://github.com/devcontainers/cli). This CLI can take a `devcontainer.json` and create and configure a dev container from it.

## <a href="#what-is-CLI" name="what-is-CLI" class="anchor"> What is the Dev Container CLI? </a>
When tools like VS Code and Codespaces detect a `devcontainer.json` file in a user's project, they use a CLI to configure a dev container. We've now opened up this CLI as a reference implementation so that individual users and other tools can read in `devcontainer.json` metadata and create dev containers from it.

This CLI can either be used directly or integrated into product experiences, similar to how it's integrated with Dev Containers and Codespaces today. It currently supports both a simple single container option and integrates with [Docker Compose](https://docs.docker.com/compose/) for multi-container scenarios.

The CLI is available in the [devcontainers/cli](https://github.com/devcontainers/cli) repository.

## <a href="#try-it" name="try-it" class="anchor"> How can I try it? </a>

We'd love for you to try out the Dev Container CLI and let us know what you think. You can quickly try it out in just a few simple steps, either by installing its npm package or building the CLI repo from sources.

You may learn more about building from sources in the [CLI repo's README](https://github.com/devcontainers/cli#try-it-out). On this page, we'll focus on using the npm package.

To install the npm package, you will need Python, Node.js (version 14 or greater), and C/C++ installed to build one of the dependencies. The VS Code [How to Contribute](https://github.com/microsoft/vscode/wiki/How-to-Contribute) wiki has details about the recommended toolsets.

### <a href="#npm-install" name="npm-install" class="anchor"> npm install </a>

```bash
npm install -g @devcontainers/cli
```

Verify you can run the CLI and see its help text:

```bash
devcontainer <command>

Commands:
  devcontainer up                   Create and run dev container
  devcontainer build [path]         Build a dev container image
  devcontainer run-user-commands    Run user commands
  devcontainer read-configuration   Read configuration
  devcontainer features             Features commands
  devcontainer templates            Templates commands
  devcontainer exec <cmd> [args..]  Execute a command on a running dev container

Options:
  --help     Show help                                                 [boolean]
  --version  Show version number                                       [boolean]
```

### <a href="#try-out" name="try-out" class="anchor"> Try out the CLI </a>

Once you have the CLI, you can try it out with a sample project, like this [Rust sample](https://github.com/microsoft/vscode-remote-try-rust).

Clone the Rust sample to your machine, and start a dev container with the CLI's `up` command:

```bash
git clone https://github.com/microsoft/vscode-remote-try-rust
devcontainer up --workspace-folder <path-to-vscode-remote-try-rust>
```

This will download the container image from a container registry and start the container. Your Rust container should now be running:

```bash
[88 ms] dev-containers-cli 0.1.0.
[165 ms] Start: Run: docker build -f /home/node/vscode-remote-try-rust/.devcontainer/Dockerfile -t vsc-vscode-remote-try-rust-89420ad7399ba74f55921e49cc3ecfd2 --build-arg VARIANT=bullseye /home/node/vscode-remote-try-rust/.devcontainer
[+] Building 0.5s (5/5) FINISHED
 => [internal] load build definition from Dockerfile                       0.0s
 => => transferring dockerfile: 38B                                        0.0s
 => [internal] load .dockerignore                                          0.0s
 => => transferring context: 2B                                            0.0s
 => [internal] load metadata for mcr.microsoft.com/vscode/devcontainers/r  0.4s
 => CACHED [1/1] FROM mcr.microsoft.com/vscode/devcontainers/rust:1-bulls  0.0s
 => exporting to image                                                     0.0s
 => => exporting layers                                                    0.0s
 => => writing image sha256:39873ccb81e6fb613975e11e37438eee1d49c963a436d  0.0s
 => => naming to docker.io/library/vsc-vscode-remote-try-rust-89420ad7399  0.0s
[1640 ms] Start: Run: docker run --sig-proxy=false -a STDOUT -a STDERR --mount type=bind,source=/home/node/vscode-remote-try-rust,target=/workspaces/vscode-remote-try-rust -l devcontainer.local_folder=/home/node/vscode-remote-try-rust --cap-add=SYS_PTRACE --security-opt seccomp=unconfined --entrypoint /bin/sh vsc-vscode-remote-try-rust-89420ad7399ba74f55921e49cc3ecfd2-uid -c echo Container started
Container started
{"outcome":"success","containerId":"f0a055ff056c1c1bb99cc09930efbf3a0437c54d9b4644695aa23c1d57b4bd11","remoteUser":"vscode","remoteWorkspaceFolder":"/workspaces/vscode-remote-try-rust"}
```

You can then run commands in this dev container:

```bash
devcontainer exec --workspace-folder <path-to-vscode-remote-try-rust> cargo run
```

This will compile and run the Rust sample, outputting:

```bash
[33 ms] dev-containers-cli 0.1.0.
   Compiling hello_remote_world v0.1.0 (/workspaces/vscode-remote-try-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 1.06s
     Running `target/debug/hello_remote_world`
Hello, VS Code Remote - Containers!
{"outcome":"success"}
```

Congrats, you've just run the Dev Container CLI and seen it in action!

These steps are also provided in the CLI repo's [README](https://github.com/devcontainers/cli/blob/main/README.md). You may also review frequently asked questions [here](https://github.com/devcontainers/spec/issues/31).

### <a href="#prebuilding" name="prebuilding" class="anchor"> Prebuilding </a> 
We recommend pre-building images with the tools you need rather than creating and building a container image each time you open your project in a dev container. Using pre-built images will result in a faster container startup, simpler configuration, and allows you to pin to a specific version of tools to improve supply-chain security and avoid potential breaks. You can automate pre-building your image by scheduling the build using a DevOps or continuous integration (CI) service like GitHub Actions.

We recommend using the [Dev Container CLI](#npm-install) (or other spec supporting utilities like the [GitHub Action](https://github.com/marketplace/actions/devcontainers-ci) or [Azure DevOps task](https://marketplace.visualstudio.com/items?itemName=devcontainers.ci)) to pre-build your images. Once you've built your image, you can push it to a container registry (like the [Azure Container Registry](https://learn.microsoft.com/azure/container-registry/container-registry-get-started-docker-cli?tabs=azure-cli), [GitHub Container Registry](https://docs.github.com/packages/working-with-a-github-packages-registry/working-with-the-container-registry#pushing-container-images), or [Docker Hub](https://docs.docker.com/engine/reference/commandline/push)) and reference it directly.

```bash
devcontainer build --workspace-folder . --push true --image-name <my_image_name>:<optional_image_version>
```

You can also check out our [in-depth guide on prebuilds](/_posts/2023-08-22-prebuild.md).

#### <a href="#labels" name="labels" class="anchor"> Metadata in image labels</a> 

You can include Dev Container configuration and Feature metadata in prebuilt images via [image labels](https://docs.docker.com/config/labels-custom-metadata/). This makes the image self-contained since these settings are automatically picked up when the image is referenced - whether directly, in a `FROM` in a referenced Dockerfile, or in a Docker Compose file. This helps prevent your Dev Container config and image contents from getting out of sync, and allows you to push updates of the same configuration to multiple repositories through a simple image reference.

This metadata label is **automatically added** when you pre-build using the [Dev Container CLI](#npm-install) (or other spec supporting utilities like the [GitHub Action](https://github.com/marketplace/actions/devcontainers-ci) or [Azure DevOps task](https://marketplace.visualstudio.com/items?itemName=devcontainers.ci)) and includes settings from `devcontainer.json` and any referenced Dev Container Features.

This allows you to have a separate **more complex** `devcontainer.json` you use to pre-build your image, and then a dramatically **simplified one** in one or more repositories. The contents of the image will be merged with this simplified devcontainer.json content at the time you create the container (see the [the spec](/implementors/spec/#merge-logic) for info on merge logic). But at its simplest, you can just reference the image directly in `devcontainer.json` for the settings to take effect:

```json
{
    "image": "mcr.microsoft.com/devcontainers/go:1"
}
```

Note that you can also opt to manually add metadata to an image label instead. These properties will be picked up even if you didn't use the Dev Container CLI to build (and can be updated by the CLI even if you do). For example, consider this Dockerfile snippet:

```Dockerfile
LABEL devcontainer.metadata='[{ \
  "capAdd": [ "SYS_PTRACE" ], \
  "remoteUser": "devcontainer", \ 
  "postCreateCommand": "yarn install" \ 
}]'
```

See the [Dev Container metadata reference](../json_reference) for information on which properties are supported.

### <a href="#domainnames" name="domainnames" class="anchor"> Domain Names </a> 

If you are behind a firewall that needs to allow specific domains used by the Dev Container CLI, here's the list of hostnames you should allow communication to go through:

* `containers.dev` - The [homepage](https://containers.dev/) for everything about dev containers. It includes all official and community-supported [Features](https://containers.dev/features) and [Templates](https://containers.dev/templates).
* `ghcr.io`, `*.azurecr.io`, `mcr.microsoft.com` - [OCI registries](https://containers.dev/implementors/features-distribution/#oci-registry) like [GitHub Container Registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry), [Azure Container Registry](https://azure.microsoft.com/en-us/products/container-registry), and [Microsoft Container Registry](https://mcr.microsoft.com/en-us/catalog?search=dev%20container) serves as the primary distribution mechanism for dev container resources. 


================================================
FILE: _implementors/spec.md
================================================
---
layout: implementors
title:  "Development Container Specification"
shortTitle: "Specification"
author: Microsoft
index: 1
---

The purpose of the **Development Container Specification** is to provide a way to enrich containers with the content and metadata necessary to enable development inside them. These container **environments** should be easy to use, create, and recreate. 

A **development container** is a container in which a user can develop an application. Tools that want to implement this specification should provide a set of features/commands that give more flexibility to users and allow **development containers** to scale to large development groups.

An **environment** is defined as a logical instance of one or more **development containers**, along with any needed side-car containers. An environment is based on one set of metadata that can be managed as a single unit. Users can create multiple **environments** from the same configuration metadata for different purposes.

# <a href="#metadata" name="metadata" class="anchor"> Metadata </a>

The Development Container Spec allows one to define a repeatable development environment for a user or team of developers that includes the execution environment the application needs. A development container defines an environment in which you develop your application before you are ready to deploy. While deployment and development containers may resemble one another, you may not want to include tools in a deployment image that you use during development and you may need to use different secrets or other settings. 

Furthermore, working inside a development container can require additional **metadata** to drive tooling or service experiences than you would normally need with a production container. Providing a structured and consistent form for this metadata is a core part of this specification.

A development container is composed of a definition (e.g. contained in a `devcontainer.json` file) that deterministically creates containers under the control of the user.

## <a href="#devcontainerjson" name="devcontainerjson" class="anchor"> `devcontainer.json` </a>

While the structure of this metadata is critical, it is also important to call out how this data can be represented on disk where appropriate. While other representations may be added over time, metadata can be stored in a JSON with Comments file called `devcontainer.json` today. Products using it should expect to find a devcontainer.json file in one or more of the following locations (in order of precedence):

- `.devcontainer/devcontainer.json`
- `.devcontainer.json`
- `.devcontainer/<folder>/devcontainer.json` (where `<folder>` is a sub-folder, one level deep)

It is valid that these files may exist in more than one location, so consider providing a mechanism for users to select one when appropriate.

## <a href="#image-metadata" name="image-metadata" class="anchor"> Image Metadata </a>

Certain dev container metadata properties can be stored in an image label as an array of metadata snippets. This allows them to be stored in prebuilt images, such that, the image and its related configuration are self-contained. These contents should then be merged with any local devcontainer.json file contents at the time the container is created. An array is used so subsequent image builds can simply append changes to the array rather than attempting to merge at that point - which improves compatibility with arbitrary image build systems.

Metadata should be representative of with the following structure, using one entry per [Dev Container Feature](../features) and `devcontainer.json` (see table below for the full list):

```json
[
	{
		"id"?: string,
		"init"?: boolean,
		"privileged"?: boolean,
		"capAdd"?: string[],
		"securityOpt"?: string[],
		"entrypoint"?: string,
		"mounts"?: [],
		...
		"customizations"?: {
			...
		}
	},
	...
]
```

To simplify adding this metadata for other tools, we also support having a single top-level object with the same properties.

The metadata is added to the image as a `devcontainer.metadata` label with a JSON string value representing the above array or single object.

### <a href="#merge-logic" name="merge-logic" class="anchor"> Merge Logic </a>

To apply the metadata together with a user's `devcontainer.json` at runtime, the following merge logic by property is used. The table also notes which properties are currently supported coming from the `devcontainer.json` and from the Feature metadata- this will change over time as we add more properties.

| Property | Type/Format | Merge Logic | devcontainer.json | devcontainer-feature.json |
| -------- | ----------- | ----------- | :---------------: | :--------------: |
| `id` | E.g., `ghcr.io/devcontainers/features/node:1` | Not merged. |   | ✓ |
| `init` | `boolean` | `true` if at least one is `true`, `false` otherwise. | ✓ | ✓ |
| `privileged` | `boolean` | `true` if at least one is `true`, `false` otherwise. | ✓ | ✓ |
| `capAdd` | `string[]` | Union of all `capAdd` arrays without duplicates. | ✓ | ✓ |
| `securityOpt` | `string[]` | Union of all `securityOpt` arrays without duplicates. | ✓ | ✓ |
| `entrypoint` | `string` | Collected list of all entrypoints. |   | ✓ |
| `mounts` | `(string \| { type, src, dst })[]` | Collected list of all mountpoints. Conflicts: Last source wins. | ✓ | ✓ |
| `onCreateCommand` | `string \| string[] \| {[key: string]: string \| string[]}` | Collected list of all onCreateCommands. | ✓ | ✓ |
| `updateContentCommand` | `string \| string[] \| {[key: string]: string \| string[]}` | Collected list of all updateContentCommands. | ✓ | ✓ |
| `postCreateCommand` | `string \| string[] \| {[key: string]: string \| string[]}` | Collected list of all postCreateCommands. | ✓ | ✓ |
| `postStartCommand` | `string \| string[] \| {[key: string]: string \| string[]}` | Collected list of all postStartCommands. | ✓ | ✓ |
| `postAttachCommand` | `string \| string[] \| {[key: string]: string \| string[]}` | Collected list of all postAttachCommands. | ✓ | ✓ |
| `waitFor` | enum | Last value wins. | ✓ |   |
| `customizations` | Object of tool-specific customizations. | Merging is left to the tools. | ✓ | ✓ |
| `containerUser` | `string` | Last value wins. | ✓ |   |
| `remoteUser` | `string` | Last value wins. | ✓ |   |
| `userEnvProbe` | `string` (enum) | Last value wins. | ✓ |   |
| `remoteEnv` | Object of strings. | Per variable, last value wins. | ✓ |   |
| `containerEnv` | Object of strings. | Per variable, last value wins. | ✓ |   |
| `overrideCommand` | `boolean` | Last value wins. | ✓ |   |
| `portsAttributes` | Map of ports to attributes. | Per port (not per port attribute), last value wins. | ✓ |   |
| `otherPortsAttributes` | Port attributes. | Last value wins (not per port attribute). | ✓ |   |
| `forwardPorts` | `(number \| string)[]` | Union of all ports without duplicates. Last one wins (when mapping changes). | ✓ |   |
| `shutdownAction` | `string` (enum) | Last value wins. | ✓ |   |
| `updateRemoteUserUID` | `boolean` | Last value wins. | ✓ |   |
| `hostRequirements` | `cpus`, `memory`, `storage`, `gpu` | Max value wins. | ✓ |   |
{: .table .table-bordered}

Variables in string values will be substituted at the time the value is applied. When the order matters, the `devcontainer.json` is considered last.

### <a href="#metadata-notes" name="metadata-notes" class="anchor"> Notes </a>

- Passing the label as a `LABEL` instruction in the Dockerfile:
	- The size limit on Dockerfiles is around 1.3MB. The line length is limited to 65k characters.
	- Using one line per Feature should allow for making full use of these limits.
- Passing the label as a command line argument:
	- There is no size limit documented for labels, but the daemon returns an error when the request header is >500kb.
	- The 500kb limit is shared, so we cannot use a second label in the same build to avoid it.
	- If/when this becomes an issue we could embed the metadata as a file in the image (e.g., with a label indicating it).

## <a href="#orchestration-options" name="orchestration-options" class="anchor"> Orchestration options </a>

A core principle of this specification is to seek to enrich existing container orchestrator formats with development container metadata where appropriate rather than replacing them. As a result, the metadata schema includes a set of optional properties for interoperating with different orchestrators. Today, the specification includes scenario-specific properties for working without a container orchestrator (by directly referencing an image or Dockerfile) and for using Docker Compose as a simple multi-container orchestrator. At the same time, this specification leaves space for further development and implementation of other orchestrator mechanisms and file formats. 

The following section describes the differences between those that are supported now. 

## <a href="#image-based" name="image-based" class="anchor"> Image based </a>

Image based configurations only reference an image that should be reachable and downloadable through `docker pull` commands. Logins and tokens required for these operations are execution environment specific. The only required parameter is `image`. The details are [here](../json_reference#image-specific).

## <a href="#dockerfile-based" name="dockerfile-based" class="anchor"> Dockerfile based </a>

These configurations are defined as using a Dockerfile to define the starting point of the development containers. As with image based configurations, it is assumed that any base images are already reachable by Docker when performing a `docker build` command. The only required parameter in this case is the relative reference to the Dockerfile in `build.dockerfile`. The details are [here](../json_reference#image-specific).

There are multiple properties that allow users to control how `docker build` works:

- `build.context` 
- `build.args`
- `build.target`
- `build.cacheFrom`

## <a href="#docker-compose-based" name="docker-compose-based" class="anchor"> Docker Compose based </a>

Docker Compose configurations use `docker-compose` (which may be Docker Compose V1 or aliased Docker Compose V2) to create and manage a set of containers required for an application. As with the other configurations, any images required for this operation are assumed to be reachable. The required parameters are:

- `dockerComposeFile`: the reference to the Docker Compose file(s) to be used.
- `service`: declares the **main** container that will be used for all other operations. Tools are assumed to also use this parameter to connect to the **development container**, although they can provide facilities to connect to the other containers as required by the user.
- `runServices`: an optional property that indicates the set of services in the `docker-compose` configuration that should be started or stopped with the environment.

It is important to note that the `image` and `dockerfile` properties are not needed since Docker Compose supports them natively in the format. 

# <a href="#other-options" name="other-options" class="anchor"> Other options </a>

In addition to the configuration options explained above, there are other settings that apply when creating development containers to facilitate their use by developers. 

A complete list of available metadata properties and their purposes can be found in the [`devcontainer.json` reference](https://aka.ms/devcontainer.json). However, we will describe the critical ones below in more detail.

## <a href="#features" name="features" class="anchor"> Features</a>

Development container "Features" are self-contained, shareable units of installation code and development container configuration. The name comes from the idea that referencing one of them allows you to quickly and easily add more tooling, runtime, or library "features" into your development container for you or your collaborators to use.

They are applied to container images as a secondary build step and can affect a number of dev container configuration settings. See the [Features documentation](../features) for more details.

## <a href="#environment-variables" name="environment-variables" class="anchor"> Environment variables </a>

Environment variables can be set at different points in the dev container lifecycle. With this in mind, development containers support two classes of environment variables:

* **Container**: These variables are part of the container when it is created and are available at all points in its lifecycle. This concept is native to containers and can be set in the container image itself, using `containerEnv` for **image** and **Dockerfile** scenarios or using orchestrator specific properties like `env` in **Docker Compose** files.
* **Remote**: These variables should be set by a development container supporting tool as part of configuring its runtime environment. Users can set these using the `remoteEnv` property and implementing tools or services may add their own for specific scenarios (e.g., secrets). These variables can change during the lifetime of the container, and are added after the container's `ENTRYPOINT` has fired.

The reason for this separation is it allows for the use of information not available at image build time and simplifies updating the environment for project/repository specific needs without modifying an image. With this in in mind, it's important to note that implementing tools should also support the [dynamic variable syntax](../json_reference/#variables-in-devcontainerjson) described in the metadata reference document.

Another notable and important environment variable related property is **`userEnvProbe`**. Implementing tools should use this property to "probe" for expected environment variables using the specified type of shell. However, it does not specify that this type of shell needs to be used for all sub-processes (given the performance impact). Instead, "probed" environment variables should be merged with remote environment variables for any processes the implementer injects after the container is created.  allows implementors to emulate developer expected behaviors around values added to their profile and rc files. 

## <a href="#mounts" name="mounts" class="anchor"> Mounts </a>

Mounts allow containers to have access to the underlying machine, share data between containers and to persist information between development containers. 

A default mount should be included so that the source code is accessible from inside the container. Source code is stored outside of the container so that a developer's in-flight edits can be extracted, or a new container created in the event a container no longer starts.

## <a href="#workspace-folder" name="workspace-folder" class="anchor"> workspaceFolder and workspaceMount </a>

The default mount point for the source code can be set with the `workspaceMount` property for image and Dockerfile scenarios or using the built in `mounts` property in Docker Compose files. This folder should point to the root of a repository (where the `.git` folder is found) so that source control operations work correctly inside the container.

The `workspaceFolder` can then be set to the default folder inside the container that should used in the container. Typically this is either the mount point in the container, or a sub-folder under it. Allowing a sub-folder to be used is particularly important for monorepos given you need the `.git` folder to interact with source control but developers are typically are interacting with a specific sub-project within the overall repository. 

See [`workspaceMount` and `workspaceFolder`](../json_reference#image-specific) for reference.

## <a href="#users" name="users" class="anchor"> Users </a>

Users control the permissions of applications executed in the containers, allowing the developer to control them. The specification takes into account two types of user definitions:

* **Container User**: The user that will be used for all operations that run inside a container. This concept is native to containers. It may be set in the container image, using the `containerUser` property for  **image** and **dockerfile** scenarios, or using an orchestratric specific property like `user` property in Docker Compose files.
* **Remote User**: Used to run the [lifecycle](#lifecycle) scripts inside the container. This is also the user tools and editors that connect to the container should use to run their processes. This concept is not native to containers. Set using the `remoteEnv` property in all cases and defaults to the container user.

This separation allows the `ENTRYPOINT` for the image to execute with different permissions than the developer and allows for developers to switch users without recreating their containers.

# <a href="#lifecycle" name="lifecycle" class="anchor"> Lifecycle </a>

A development environment goes through different lifecycle events during its use in the outer and inner loop of development.

- Configuration Validation
- Environment Creation
- Environment Stop
- Environment Resume

## <a href="#configuration-validation" name="configuration-validation" class="anchor"> Configuration Validation </a>

The exact steps required to validate configuration can vary based on exactly where the development container metadata is persisted. However, when considering a `devcontainer.json` file, the following validation should occur:

1. Validate that a workspace source folder has been provided. It is up to the implementing tool to determine what to do if no source folder is provided.
2. Search for a `devcontainer.json` file in one of the locations [above](#devcontainerjson) in the workspace source folder. 
3. If no `devcontainer.json` is found, it is up to the implementing tool or service to determine what to do. This specification does not dictate this behavior.
4. Validate that the metadata (for example `devcontainer.json`) contains all parameters required for the selected configuration type.

## <a href="#environment-creation" name="environment-creation" class="anchor"> Environment Creation </a>

The creation process goes through the steps necessary to go from the user configuration to a working **environment** that is ready to be used.

### <a href="#initialization" name="initialization" class="anchor"> Initialization </a> 

During this step, the following is executed:
- Validate access to the container orchestrator specified by the configuration.
- Execution of `initializeCommand`.

### <a href="#image-creation" name="image-creation" class="anchor"> Image Creation </a> 

The first part of environment creation is generating the final image(s) that the development containers are going to use. This step is orchestrator dependent and can consist of just pulling a Docker image, running Docker build, or `docker-compose` build. Additionally, this step is useful on its own since it permits the creation of intermediate images that can be uploaded and used by other users, thus cutting down on creation time. It is encouraged that tools implementing this specification give access to a command that just executes this step.

This step executes the following tasks:

1. [Configuration Validation](#configuration-validation) 
2. Pull/build/execute of the defined container orchestration format to create images.
3. Validate the result of these operations.

### <a href="#container-creation" name="container-creation" class="anchor"> Container Creation </a> 

After image creation, containers are created based on that image and setup.

This step executes the following tasks:

1. [Optional] Perform any required user UID/GID sync'ing (more next)
2. Create the container(s) based on the properties specified above.
3. Validate the container(s) were created successfully.

Note that container [mounts](#mounts), [environment variables](#environment-variables), and [user](#users) configuration should be applied at this point. However, remote user and environment variable configuration should **not** be.

UID/GID sync'ing is an optional task for Linux (only) and that executes if the `updateRemoteUserUID` property is set to true and a `containerUser` or `remoteUser` is specified. In this case, an image update should be made prior to creating the container to set the specified user's UID and GID to match the current local user’s UID/GID to avoid permission problems with bind mounts. Implementations **may** skip this task if they do not use bind mounts on Linux, or use a container engine that does this translation automatically.

### <a href="#post-container-creation" name="post-container-creation" class="anchor"> Post Container Creation </a>

At the end of the container creation step, a set of commands are executed inside the **main** container: 
- `onCreateCommand`, `updateContentCommand` and `postCreateCommand`. This set of commands is executed in sequence on a container the first time it's created and depending on the creation parameters received. You can learn more in the [documentation on lifecycle scripts](../json_reference/#lifecycle-scripts). By default, `postCreateCommand` is executed in the background after reporting the successful creation of the development environment.
- If the `waitFor` property is defined, then execution should block until all commands in the sequence up to the specified property have executed. This property defaults to `updateContentCommand`.

Remote [environment variables](#environment-variables) and [user](#users) configuration should be applied to all created processes in the container (inclusive of `userEnvProbe`).

### <a href="#implementation-specific-steps" name="implementation-specific-steps" class="anchor"> Implementation specific steps </a>

After these steps have been executed, any implementation specific commands can safely execute. Specifically, any processes required by the implementation to support other properties in this specification should be started at this point. These may occur in parallel to any non-blocking, background post-container creation commands (as dictated by the `waitFor` property).

Any user facing processes should have remote [environment variables](#environment-variables) and [user](#users) configuration applied (inclusive of `userEnvProbe`).

For example, in the [CLI reference implementation](https://github.com/devcontainers/cli), this is the point in which anything executed with `devcontainer exec` would run.

Typically, this is also the step where implementors would apply config or settings from the `customizations` section of the dev container metadata (e.g., VS Code installs extensions based on the `customizations.vscode.extensions` property). Examples of these can be found in the [supporting tools section](../../supporting) reference. However, applying these at this point is not strictly required or mandated by this specification.

Once these final steps have occurred, implementing tools or services may connect to the environment as they see fit.

## <a href="#environment-stop" name="environment-stop" class="anchor"> Environment Stop </a>

The intention of this step is to ensure all containers are stopped correctly based on the appropriate orchestrator specific steps to ensure no data is lost. It is up to the implementing tool or service to determine when this event should happen.

## <a href="#environment-resume" name="environment-resume" class="anchor"> Environment Resume </a>

While it is not a strict requirement to keep a development container after it has been stopped, this is the most common scenario.

To resume the environment from a stopped state:
1. Restart all related containers.
2. Follow the appropriate [implementation specific steps](#implementation-specific-steps).
3. Additionally, execute the `postStartCommand` and `postAttachCommand` in the container.

Like during the create process, remote [environment variables](#environment-variables) and [user](#users) configuration should be applied to all created processes in the container (inclusive of `userEnvProbe`).

## <a href="#parallel-exec" name="parallel-exec" class="anchor"> Parallel lifecycle script execution </a>

Dev containers support a single command for each of its lifecycle scripts. While serial execution of multiple commands can be achieved with `;`, `&&`, etc., parallel execution deserves first-class support.

All lifecycle scripts have been extended to support `object` types. The key of the `object` will be a unique name for the command, and the value will be the `string` or `array` command. Each command must exit successfully for the stage to be considered successful.

Each entry in the `object` will be run in parallel during that lifecycle step.

### Example

```json
{
  "postCreateCommand": {
    "server": "npm start",
    "db": ["mysql", "-u", "root", "-p", "my database"]
  }
}
```

# <a href="#definitions" name="definitions" class="anchor"> Definitions </a>
#### <a href="#project-workspace-folder" name="project-workspace-folder" class="anchor"> Project Workspace Folder </a>

The **project workspace folder** is where an implementing tool should begin to search for `devcontainer.json` files. If the target project on disk is using git, the **project workspace folder** is typically the root of the git repository. 



================================================
FILE: _implementors/templates-distribution.md
================================================
---
layout: implementors
title:  "Dev Container Templates distribution and discovery"
shortTitle: "Templates distribution"
author: Microsoft
index: 8
---

**TL;DR Check out the [quick start repository](https://github.com/devcontainers/template-starter) to get started on distributing your own Dev Container Templates.**

This specification defines a pattern where community members and organizations can author and self-publish [Dev Container Templates](/implementors/templates). 

Goals include:

- For Template authors, create a "self-service" way to publish a Template, either publicly or privately, that is not centrally controlled.
- Provide the ability to standardize publishing such that supporting tools may implement their own mechanism to aid Template discoverability as they see fit.

## <a href="#source-code" name="source-code" class="anchor"> Source code </a>

A Template's source code is stored in a git repository.

For ease of authorship and maintenance, [1..n] Templates can share a single git repository. This set of Templates is referred to as a "collection," and will share the same [`devcontainer-collection.json`](#devcontainer-collection) file and "namespace" (eg. `<owner>/<repo>`).

> **Note:** Templates and [Features](/implementors/features) should be placed in different git repositories. 

Source code for a set of Templates follows the example file structure below:

```
.
├── README.md
├── src
│   ├── dotnet
│   │   ├── devcontainer-template.json
│   │   ├── .devcontainer.json
│   │   ├── ...
|   ├
│   ├── docker-from-docker
│   │   ├── devcontainer-template.json
│   │   ├── .devcontainer
│   │       ├── devcontainer.json
│   │       ├── Dockerfile
│   │       └── ...
│   │   ├── ...
|   ├
│   ├── go-postgres
│   │   ├── devcontainer-template.json
│   │   ├── .devcontainer
│   │       ├── devcontainer.json
│   │       ├── docker-compose.yml
│   │       ├── Dockerfile
│   │       └── ...
│   │   ├── ...
```

...where `src` is a directory containing a sub-folder with the name of the Template (e.g. `src/dotnet` or `src/docker-from-docker`) with at least a file named `devcontainer-template.json` that contains the Template metadata, and a `.devcontainer.json` (or `.devcontainer/devcontainer.json`) that the supporting tools will drop into an existing project or folder.

Each sub-directory should be named such that it matches the `id` field of the `devcontainer-template.json`.  Other files can also be included in the Templates's sub-directory, and will be included during the [packaging step](#packaging) alongside the two required files.  Any files that are not part of the Templates's sub-directory (e.g. outside of `src/dotnet`) will not included in the [packaging step](#packaging).

## <a href="#versioning" name="versioning" class="anchor">Versioning </a>

Each Template is individually [versioned according to the semver specification](https://semver.org/). The `version` property in the respective `devcontainer-template.json` file is parsed to determine if the Template should be republished.

Tooling that handles publishing Templates will not republish Templates if that exact version has already been published; however, tooling must republish major and minor versions in accordance with the semver specification.

## <a href="#packaging" name="packaging" class="anchor"> Packaging </a>

Templates are distributed as tarballs. The tarball contains the entire contents of the Template sub-directory, including the `devcontainer-template.json`, `.devcontainer.json` (or `.devcontainer/devcontainer.json`), and any other files in the directory.

The tarball is named `devcontainer-template-<id>.tgz`, where `<id>` is the Templates's `id` field.

A reference implementation for packaging and distributing Templates is provided as a [GitHub Action](https://github.com/devcontainers/action).

### <a href="#devcontainer-collection" name="devcontainer-collection" class="anchor"> devcontainer-collection.json </a>

The `devcontainer-collection.json` is an auto-generated metadata file.

| Property | Type | Description |
| :--- | :--- | :--- |
| `sourceInformation` | object | Metadata from the implementing packaging tool. |
| `templates` | array | The list of Templates that are contained in this collection.|
{: .table .table-bordered}

Each Template's `devcontainer-template.json` metadata file is appended into the `templates` top-level array.

## <a href="#distribution" name="distribution" class="anchor"> Distribution </a>

There are several supported ways to distribute Templates.  Distribution is handled by the implementing packaging tool such as the **[Dev Container CLI](https://github.com/devcontainers/cli)** or **[Dev Container Publish GitHub Action](https://github.com/marketplace/actions/dev-container-publish)**.

A user can add a Template in to their projects as defined by the [supporting tools](/supporting#supporting-tools-and-services).

### <a href="#oci-registry" name="oci-registry" class="anchor">OCI Registry</a>

An OCI registry that implements the [OCI Artifact Distribution Specification](https://github.com/opencontainers/distribution-spec) serves as the primary distribution mechanism for Templates.

Each packaged Template is pushed to the registry following the naming convention `<registry>/<namespace>/<id>[:version]`, where version is the major, minor, and patch version of the Template, according to the semver specification.

> **Note:** The `namespace` is a unique identifier for the collection of Templates and must be different than the collection of [Features](/implementors/features). There are no strict rules for the `namespace`; however, one pattern is to set `namespace` equal to source repository's `<owner>/<repo>`. 

A custom media type `application/vnd.devcontainers` and `application/vnd.devcontainers.layer.v1+tar` are used as demonstrated below.

For example, the `go` Template in the `devcontainers/templates` namespace at version `1.2.3` would be pushed to the ghcr.io OCI registry.

> **Note:** The example below uses [`oras`](https://oras.land/) for demonstration purposes.  A supporting tool should directly implement the required functionality from the aforementioned OCI artifact distribution specification.

```bash
# ghcr.io/devcontainers/templates/go:1
REGISTRY=ghcr.io
NAMESPACE=devcontainers/templates
TEMPLATE=go

ARTIFACT_PATH=devcontainer-template-go.tgz

for VERSION in 1  1.2  1.2.3  latest
do
        oras push ${REGISTRY}/${NAMESPACE}/${TEMPLATE}:${VERSION} \
                --config /dev/null:application/vnd.devcontainers \
                        ./${ARTIFACT_PATH}:application/vnd.devcontainers.layer.v1+tar
done

```

The "namespace" is the globally identifiable name for the collection of Templates. (eg: `owner/repo` for the source code's git repository).

The auto-generated `devcontainer-collection.json` is pushed to the registry with the same `namespace` as above and no accompanying `template` name. The collection file is always tagged as `latest`.

```bash
# ghcr.io/devcontainers/templates
REGISTRY=ghcr.io
NAMESPACE=devcontainers/templates

oras push ${REGISTRY}/${NAMESPACE}:latest \
        --config /dev/null:application/vnd.devcontainers \
                            ./devcontainer-collection.json:application/vnd.devcontainers.collection.layer.v1+json
```

## <a href="#guide-to-publishing-templates" name="guide-to-publishing-templates" class="anchor">Guide to publishing Templates</a>

The Dev Container CLI can be used to publish [Template](https://containers.dev/implementors/templates/) artifacts to an OCI registry (that supports the [artifacts specification](https://oras.land/implementors/)).

To see all the available options, run `devcontainers templates publish --help`.

## <a href="#example" name="example" class="anchor">Example</a>

Given a directory that is organized according to the [Templates distribution specification](https://containers.dev/implementors/templates-distribution/) - for example:

```
├── src
│   ├── color
│   │   ├── devcontainer-template.json
│   │   └──| .devcontainer
│   │      └── devcontainer.json
│   ├── hello
│   │   ├── devcontainer-template.json
│   │   └──| .devcontainer
│   │      ├── devcontainer.json
│   │      └── Dockerfile
|   ├── ...
│   │   ├── devcontainer-template.json
│   │   └──| .devcontainer
│   │      └── devcontainer.json
├── test
│   ├── color
│   │   └── test.sh
│   ├── hello
│   │   └── test.sh
│   └──test-utils
│      └── test-utils.sh
...
```

The following command will publish each Template above (`color,hello`) to the registry `ghcr.io` with the following namespace (prefix) `devcontainers/templates`.

```
[/tmp]$  GITHUB_TOKEN="$CR_PAT" devcontainer templates publish -r ghcr.io -n devcontainers/templates ./src
```

To later apply a published Template (in the example below, the `color` template) with the CLI, the following `apply` command would be used:

```
[/tmp]$  devcontainer templates apply \
                 -t 'ghcr.io/devcontainers/templates/color' \
                 -a '{"favorite": "red"}'
```

### <a href="#authentication-methods" name="authentication-methods" class="anchor">Authentication Methods</a>

> NOTE: OS-specific docker credential helpers (Docker Desktop credential helper) are not currently recognized by the CLI.  
- Adding a $HOME/.docker/config.json with your credentials following [this commonly defined format](https://www.systutorials.com/docs/linux/man/5-docker-config-json/).
   - Your `docker login` command may write this file for you depending on your operating system.
- Using our custom env variable DEVCONTAINERS_OCI_AUTH
    - eg: `DEVCONTAINERS_OCI_AUTH=service1|user1|token1,service2|user2|token2`

For publishing to `ghcr.io`
- Using the `devcontainers/action` GitHub action to handle the `GITHUB_TOKEN` credential for you.
- Providing a GITHUB_TOKEN with permission to `write:packages`.



================================================
FILE: _implementors/templates.md
================================================
---
layout: implementors
title:  "Dev Container Templates reference"
shortTitle: "Templates"
author: Microsoft
index: 7
---

**Development Container Templates** are source files packaged together that encode configuration for a complete development environment. A Template can be used in a new or existing project, and a [supporting tool](/supporting) will use the configuration from the Template to build a development container.

The configuration is placed in a [`.devcontainer.json`](/implementors/json_reference#devcontainerjson) which can also reference other files within the Template. Alternatively, `.devcontainer/devcontainer.json` can also be used if the container needs to reference other files, such as a `Dockerfile` or `docker-compose.yml`. A Template can also provide additional source files (eg: boilerplate code or a [lifecycle script](/implementors/json_reference/#lifecycle-scripts)).

Template metadata is captured by a `devcontainer-template.json` file in the root folder of the Template.

## <a href="#folder-structure" name="folder-structure" class="anchor"> Folder Structure</a>

A single Template is a folder with at least a `devcontainer-template.json` and [`devcontainer.json`](/implementors/json_reference#devcontainerjson).  Additional files are permitted and are packaged along side the required files.

```
+-- template
|    +-- devcontainer-template.json
|    +-- .devcontainer.json
|    +-- (other files)
```

## <a href="#devcontainer-template-properties" name="devcontainer-template-properties" class="anchor">devcontainer-template.json properties</a>

The `devcontainer-template.json` file defines information about the Template to be used by any [supporting tools](/supporting#supporting-tools-and-services).

The properties of the file are as follows:

| Property | Type | Description |
| :--- | :--- | :--- |
| `id` | string | ID of the Template. The `id` should be unique in the context of the repository/published package where the Template exists and must match the name of the directory where the `devcontainer-template.json` resides. |
| `version` | string | The semantic version of the Template. |
| `name` | string | Name of the Template. |
| `description` | string | Description of the Template. |
| `documentationURL` | string | Url that points to the documentation of the Template. |
| `licenseURL` | string | Url that points to the license of the Template. |
| [`options`](#options) | object | A map of options that the supporting tools should use to populate different configuration options for the Template. |
| `platforms` | array | Languages and platforms supported by the Template. |
| `publisher` | string | Name of the publisher/maintainer of the Template. |
| `keywords` | array | List of strings relevant to a user that would search for this Template. |
| [`optionalPaths`](#optionalPaths) | array | An array of files or directories that tooling may consider "optional" when applying a Template. Directories are indicated with a trailing `/*`, (eg: `.github/*`).
{: .table .table-bordered}

### <a href="#options" name="options" class="anchor">  The `options` property</a>
The `options` property contains a map of option IDs and their related configuration settings. These `options` are used by the supporting tools to prompt the user to choose from different Template configuration options. The tools would replace the option ID with the selected value in all the files (within the sub-directory of the Template). This replacement would happen before dropping the `.devcontainer.json` (or `.devcontainer/devcontainer.json`) and other files (within the sub-directory of the Template) required to containerize your project. See [option resolution](#option-resolution) for more details. For example:

```json
{
  "options": {
    "optionId": {
      "type": "string",
      "description": "Description of the option",
      "proposals": ["value1", "value2"],
      "default": "value1"
    }
  }
}
```

| Property | Type | Description |
| :--- | :--- | :--- |
| `optionId` | string | ID of the option used by the supporting tools to replace the selected value in the files within the sub-directory of the Template. |
| `optionId.type` | string | Type of the option. Valid types are currently: `boolean`, `string` |
| `optionId.description` | string | Description for the option. |
| `optionId.proposals` | array | A list of suggested string values. Free-form values **are** allowed. Omit when using `optionId.enum`. |
| `optionId.enum` | array | A strict list of allowed string values. Free-form values are **not** allowed. Omit when using `optionId.proposals`. |
| `optionId.default` | string | Default value for the option. |
{: .table .table-bordered}

> `Note`: The `options` must be unique for every `devcontainer-template.json`

### <a href="#optionalPaths" name="optionalPaths" class="anchor">  The `optionalPaths` property</a>

Before applying a Template, tooling must inspect the `optionalPaths` property of a Template and prompt the user on whether each file or folder should be included in the resulting output workspace folder.  A path is relative to the root of the Template source directory.

- For a single file, provide the full relative path (without any leading or trailing path delimiters).  
- For a directory, provide the full relative path with a trailing slash and asterisk (`/*`) appended to the path.  The directory and its children will be recursively ignored.

Examples are shown below:

```jsonc
{
    "id": "cpp",
    "version": "3.0.0",
    "name": "C++",
    "description": "Develop C++ applications",
    "optionalPaths": [
         "GETTING-STARTED.md",                 // Single file
         "example-project-1/MyProject.csproj", // Single file in nested directory
         ".github/*"                           // Entire recursive contents of directory
     ]
}
```


### <a href="#referencing-a-template" name="referencing-a-template" class="anchor"> Referencing a Template </a>

The `id` format (`<oci-registry>/<namespace>/<template>[:<semantic-version>]`) dictates how a [supporting tool](/supporting) will locate and download a given Template from an OCI registry. For example:

- `ghcr.io/user/repo/go`
- `ghcr.io/user/repo/go:1`
- `ghcr.io/user/repo/go:latest`

The registry must implement the [OCI Artifact Distribution Specification](https://github.com/opencontainers/distribution-spec). Some implementors can be [found here](https://oras.land/implementors/).

## <a href="#versioning" name="versioning" class="anchor"> Versioning </a>

Each Template is individually [versioned according to the semver specification](https://semver.org/).  The `version` property in the respective `devcontainer-template.json` file is updated to increment the Template's version.

Tooling that handles releasing Templates will not republish Templates if that exact version has already been published; however, tooling must republish major and minor versions in accordance with the semver specification.

## <a href="#release" name="release" class="anchor"> Release </a>

_For information on distributing Templates, see the [Templates distribution doc](/implementors/templates-distribution)._

### <a href="#option-resolution" name="option-resolution" class="anchor"> Option Resolution </a>

A Template's `options` property is used by a supporting tool to prompt for different configuration options. A supporting tool will parse the `options` object provided by the user. If a value is selected for a Template, it will be replaced in the files (within the sub-directory of the Template).

### <a href="#option-resolution-example" name="option-resolution-example" class="anchor"> Option resolution example </a>

Consider a `java` Template with the following folder structure:

```
+-- java
|    +-- devcontainer-template.json
|    +-- .devcontainer.json
```

Suppose the `java` Template has the following `options` parameters declared in the `devcontainer-template.json` file:

```json
// ...
"options": {
    "imageVariant": {
        "type": "string",
        "description": "Specify version of java.",
        "proposals": [
          "17-bullseye",
          "17-buster",
          "11-bullseye",
          "11-buster",
          "17",
          "11"
        ],
    "default": "17-bullseye"
    },
    "nodeVersion": {
        "type": "string", 
        "proposals": [
          "latest",
          "16",
          "14",
          "10",
          "none"
        ],
        "default": "latest",
        "description": "Specify version of node, or 'none' to skip node installation."
    },
    "installMaven": {
        "type": "boolean", 
        "description": "Install Maven, a management tool for Java.",
        "default": "false"
    },
}
```

and it has the following `.devcontainer.json` file:

```json
{
     "name": "Java",
     "image": "mcr.microsoft.com/devcontainers/java:0-${templateOption:imageVariant}",
     "features": {
          "ghcr.io/devcontainers/features/node:1": {
               "version": "${templateOption:nodeVersion}",
               "installMaven": "${templateOption:installMaven}"
          }
     },
//	...
}
```

A user tries to add the `java` Template to their project using the [supporting tools](/supporting#supporting-tools-and-services) and selects `17-bullseye` when prompted for `"Specify version of Go"` and the `default` values when prompted for `"Specify version of node, or 'none' to skip node installation"` and `"Install Maven, a management tool for Java"`.

The supporting tool could then use a string replacer for all the files within the sub-directory of the Template. In this example, `.devcontainer.json` needs to be modified and hence, the inputs can provided to it as follows:

```json
{
  imageVariant:"17-bullseye",
  nodeVersion: "latest",
  installMaven: "false"
}
```

The modified `.devcontainer.json` will be as follows:

```json
{
     "name": "Go",
     "image": "mcr.microsoft.com/devcontainers/go:0-17-bullseye",
     "features": {
          "ghcr.io/devcontainers/features/node:1": {
               "version": "latest",
               "installMaven": "false"
	  }
     },
     ...
}
```

The modified `.devcontainer.json` would be dropped into any existing folder as a starting point for containerizing your project.



================================================
FILE: _includes/cookie_notice.html
================================================
<div id='cookie-banner'></div>


================================================
FILE: _includes/footer.html
================================================
<footer class="footer">
    <script>
        function manageConsent() {
            if (WcpConsent.siteConsent.isConsentRequired) {
                WcpConsent.siteConsent.manageConsent();
            }
        }
    </script>

    <div class="container">
        <div class="row">
            <div class="col-sm-10">
                <ul class="links">
                    <li>
                        <a class="github-button" href="https://github.com/devcontainers/spec" data-icon="octicon-star" data-show-count="true" aria-label="Star devcontainers/spec on GitHub">Star</a>
                    </li>
                    <li>
                        <a class="github-button" href="https://github.com/devcontainers/spec/subscription" aria-label="Watch devcontainers/spec on GitHub">Watch</a>
                    </li>
                </ul>
            </div>
            <div class="col-sm-2">
                <ul class="links">
                    <li style="display: none;" >
                        <a id="footer-cookie-link" style="cursor: pointer; padding-right:20px" onclick="manageConsent()"
                            aria-label="Manage cookies">Manage cookies</a>
                    </li>
                    <li>
                        <div class="copyright">
                            <a id="footer-microsoft-link" class="logo" href="https://www.microsoft.com">
                                <img src="{{site.baseurl}}/img/microsoft-logo-inverted.png" height="20" alt="Microsoft">
                            </a>
                            <span>© {{ 'now' | date: "%Y" }} Microsoft</span>
                        </div>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>



================================================
FILE: _includes/head.html
================================================
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>{% if page.title %}{{ page.title }}{% else %}{{ site.title }}{% endif %}</title>
    <meta name="description" content="{% if page.excerpt %}{{ page.excerpt | strip_html | strip_newlines | truncate: 160 }}{% else %}{{ site.description }}{% endif %}">


    <!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous" -->
    <link rel="stylesheet" href="{{ "/css/bootswatch/cosmo/bootstrap.min.css" | prepend: site.baseurl }}">
    <link rel="stylesheet" href="{{ "/css/fontawesome-all.min.css" | prepend: site.baseurl }}">
    <link rel="stylesheet" href="{{ "/css/main.css" | prepend: site.baseurl }}">
    <link rel="shortcut icon" href="{{ "/img/favicon.ico" | prepend: site.baseurl }}">
    <meta name="theme-color" content="#{{ site.theme_color }}">

    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseurl | prepend: site.url }}">
    <link rel="alternate" type="application/rss+xml" title="{{ site.title }}" href="{{ "/feed.xml" | prepend: site.baseurl | prepend: site.url }}" />
</head>


================================================
FILE: _includes/js_files.html
================================================
<script>
  var baseurl = '{{ site.baseurl }}'
</script>

<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>

<!-- Microsoft EU cookie compliance library -->
<script src="https://wcpstatic.microsoft.com/mscc/lib/v2/wcp-consent.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-62780441-30"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" integrity="sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" integrity="sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ" crossorigin="anonymous"></script>
<script async defer src="https://buttons.github.io/buttons.js"></script>
<script src="{{ site.baseurl }}/js/page.js"></script>


================================================
FILE: _includes/topnav.html
================================================
<header class="navbar navbar-expand-lg navbar-dark bg-primary -navbar">
    <div class="container navbar-container">
        <a class="navbar-brand" href="{{ site.baseurl }}/">
            <h1>Development Containers</h1>
        </a>

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
        </button>

        <div class="navbar-collapse collapse" id="navbarSupportedContent" role="navigation" aria-label="Top Level">
            {% assign sorted = site.implementors | sort: 'index' %}
            <ul class="navbar-nav ml-auto">
                <li {% if page.sectionid=='howItWorks' %} class="nav-item active" {% else %} class="nav-item" {% endif %}>
                    <a class="nav-link" href='{{ "/overview" | prepend: site.baseurl }}'>Overview</a>
                </li>
                <!--<li {% if page.sectionid=='implementors' %} class="nav-item active" {% else %} class="nav-item" {% endif %}>
                    <a class="nav-link" href="{{ sorted.first.url | prepend: site.baseurl }}">Implementations</a>
                </li>-->
                <li {% if page.sectionid=='metadata' %} class="nav-item active" {% else %} class="nav-item" {% endif %}>
                    <a class="nav-link" href="{{ "/implementors/json_reference" | prepend: site.baseurl }}">Reference</a>
                </li>
                <li {% if page.sectionid=='implementors' %} class="nav-item active" {% else %} class="nav-item" {% endif %}>
                    <a class="nav-link" href="{{ sorted.first.url | prepend: site.baseurl }}">Specification</a>
                </li>
                <li {% if page.sectionid=='supporting' %} class="nav-item active" {% else %} class="nav-item" {% endif %}>
                    <a class="nav-link" href='{{ "/supporting" | prepend: site.baseurl }}'>Supporting Tools</a>
                </li>
                <li {% if page.sectionid=='guides' %} class="nav-item active" {% else %} class="nav-item" {% endif %}>
                    <a class="nav-link" href='{{ "/guides" | prepend: site.baseurl }}'>Guides</a>
                </li>
                <li {% if page.sectionid=='features' %} class="nav-item active" {% else %} class="nav-item" {% endif %}>
                    <a class="nav-link" href='{{ "/features" | prepend: site.baseurl }}'>Available Features</a>
                </li>
                <li {% if page.sectionid=='features' %} class="nav-item active" {% else %} class="nav-item" {% endif %}>
                    <a class="nav-link" href='{{ "/templates" | prepend: site.baseurl }}'>Available Templates</a>
                </li>
                <li {% if page.sectionid=='collections' %} class="nav-item active" {% else %} class="nav-item" {% endif %}>
                    <a class="nav-link" href='{{ "/collections" | prepend: site.baseurl }}'>Collections</a>
                </li>
            </ul>
        </div>

    </div>
</header>


================================================
FILE: _layouts/default.html
================================================
<!DOCTYPE html>
<html lang="en">

{% include head.html %}

<body>
    {% include cookie_notice.html %}
    {% include topnav.html %}

    <div class="page-content">
        <div class="wrapper">
            {{ content }}
        </div>
    </div>

    {% include footer.html %}
    {% include js_files.html %}
</body>

</html>


================================================
FILE: _layouts/implementors.html
================================================
---
layout: default
---

<div class="container">
    <div class="row single-page">
        <div class="col-lg-2 d-none d-lg-block dap-sidebar">
            <div class="card">
                <ul class="nav flex-column list-unstyled">
                    {% assign sorted = site.implementors | sort: 'index' %}
                    {% for post in sorted %}
                    <li {% if page.title==post.title %} class="nav-item active" {% else %} class="nav-item" {% endif %}>
                        <a class="nav-link" href="{{ post.url | prepend: site.baseurl }}">
                            {{ post.shortTitle }}
                        </a>
                    </li>
                    {% endfor %}
                </ul>
            </div>
        </div>

        <div class="col-md-12 col-lg-10" role="navigation" aria-label="Main">
            <nav id="small-nav" class="docs-nav d-lg-none">
                <h4>Topics</h4>
                <select id="small-nav-dropdown">
                    {% assign sorted = site.implementors | sort: 'index' %}
                    {% for post in sorted %}
                    <option value="{{ post.url | prepend: site.baseurl }}" {% if page.title==post.title %}selected{% endif %} >{{ post.shortTitle }}</option>
                    {% endfor %}
                </select>
            </nav>

            <h1>Specification</h1>
            <h2>{{ page.title }}</h2>
            <div  id="markdown-content-container">{{ content }}</div>
        </div>

        <!--<div class="col-lg-2 d-none d-xl-block">-->

        </div>
    </div>
</div>


================================================
FILE: _layouts/post.html
================================================
---
layout: singlePage
---
<div class="container">
    <p>{{ page.date | date_to_string }} -
        {% assign i = 0 %}
        {% for a in page.author %}
            <a href="{{ page.authorUrl[i] }}">{{ page.author[i] }}</a>
            {% assign i = i | plus:1 %}
        {% endfor %}
    </p>

    {{ content }}
</div>



================================================
FILE: _layouts/singlePage.html
================================================
---
layout: default
---

<div class="container">
    <div class="row single-page">
        <div class="col-lg-1 d-none d-xl-block">
        </div>
        <div class="col-md-12 col-lg-10">
            <h1>{{ page.title }}</h1>
            <div id="markdown-content-container">{{ content }}</div>
        </div>
        <div class="col-lg-1 d-none d-xl-block">
        </div>
    </div>
</div>


================================================
FILE: _layouts/specification.html
================================================
---
layout: default
---

<div class="container">
    <div class="row single-page">
        <div class="d-none col-lg-2 d-lg-block">
        </div>

        <div class="col-lg-7" role="navigation" aria-label="Main">
            <h1>{{ page.schemaTitle }}</h1>

            <div class="d-block d-lg-none dap-sidebar">
                {% for toc-l1 in site.data.specification-toc %}
                <div class="card">
                    <div id="outlineAccordion-inline" data-children=".item">
                        {% for toc-l2 in toc-l1.children %}
                        <div class="item">
                            <a class="nav-link" data-toggle="collapse" data-parent="#outlineAccordion-inline" href="#{{ toc-l2.anchor }}-inline" aria-expanded="true">
                                {{ toc-l2.title }}
                            </a>
                            <div id="{{ toc-l2.anchor }}-inline" class="collapse" role="tabpanel">
                                <ul class="nav toc flex-column" style="padding-left: 0.5rem">
                                    {% for toc-l3 in toc-l2.children %}
                                    <li class="nav-item">
                                        <a class="nav-link toc-link" href="#{{ toc-l3.anchor }}">
                                            {{ toc-l3.title }}
                                        </a>
                                    </li>
                                    {% endfor %}
                                </ul>
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
                {% endfor %}
            </div>

            <div id="markdown-content-container">{{ content }}</div>
        </div>

        <div class="d-none col-lg-3 d-lg-block dap-sidebar">
            {% for toc-l1 in site.data.specification-toc %}
            <div class="card">
                <div id="outlineAccordion-side" data-children=".item">
                    {% for toc-l2 in toc-l1.children %}
                    <div class="item">
                        <a class="nav-link" data-toggle="collapse" data-parent="#outlineAccordion-side" href="#{{ toc-l2.anchor }}-side" aria-expanded="true">
                            {{ toc-l2.title }}
                        </a>
                        <div id="{{ toc-l2.anchor }}-side" class="collapse" role="tabpanel">
                            <ul class="nav toc flex-column" style="padding-left: 0.5rem">
                                {% for toc-l3 in toc-l2.children %}
                                <li class="nav-item">
                                    <a class="nav-link toc-link" href="#{{ toc-l3.anchor }}">
                                        {{ toc-l3.title }}
                                    </a>
                                </li>
                                {% endfor %}
                            </ul>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
            {% endfor %}
        </div>
    </div>
</div>


================================================
FILE: _layouts/table.html
================================================
---
layout: default
---

<div class="container">
    <div class="row single-page">
        <style type="text/css">
            .tg {
                border-collapse: collapse;
                border-spacing: 0;
                margin-left: auto;
                margin-right: auto;
            }

            .tg td {
                border-color: black;
                border-style: solid;
                border-width: 1px;
                font-family: Arial, sans-serif;
                font-size: 14px;
                overflow: hidden;
                padding: 10px 5px;
                word-break: normal;
            }

            .tg th {
                border-color: black;
                border-style: solid;
                border-width: 1px;
                font-family: Arial, sans-serif;
                font-size: 14px;
                font-weight: normal;
                overflow: hidden;
                padding: 10px 5px;
                word-break: normal;
            }

            .tg .tg-0lax {
                text-align: left;
                vertical-align: top
            }

        </style>
        <div style="margin-left: auto;margin-right: auto;">
        <table class="tg">
            <thead>
                {{ content }}
            </thead>
        </table>
    </div>
    </div>
</div>



================================================
FILE: _posts/2022-11-01-author-a-feature.md
================================================
---
layout: post
title:  "Authoring a Dev Container Feature"
author:
    - "@joshspicer"
authorUrl:
    - https://github.com/joshspicer
---

Development container ["Features"](/features) are self-contained, shareable units of installation code and development container configuration. We [define a pattern](/implementors/features-distribution) for authoring and self-publishing Features.

In this document, we'll outline a "quickstart" to help you get up-and-running with creating and sharing your first Feature. You may review an example along with guidance in our [devcontainers/feature-starter](https://github.com/devcontainers/feature-starter) repo as well. 

> Note: While this walkthrough will illustrate the use of GitHub and the GitHub Container Registry, you can use your own source control system and publish to any [OCI Artifact supporting](https://oras.land/docs/compatible_oci_registries#registries-supporting-oci-artifacts) container registry instead.

## <a href="#create-repo" name="create-repo" class="anchor"> Create a repo </a>

Start off by creating a repository to host your Feature. In this guide, we'll use a public GitHub repository. 

For the simplest getting started experience, you may use our example [feature-starter](https://github.com/devcontainers/feature-starter) repo. You may select the green `Use this template` button on the repo's page.

You may also [create your own repo on GitHub](https://docs.github.com/en/get-started/quickstart/create-a-repo) if you'd prefer.

## <a href="#create-folder" name="create-folder" class="anchor"> Create a folder </a>

Once you've forked the feature-starter repo (or created your own), you'll want to create a folder for your Feature. You may create one within the [`src`](https://github.com/devcontainers/feature-starter/tree/main/src) folder.

If you'd like to create multiple Features, you may add multiple folders within `src`.

## <a href="#add-files" name="add-files" class="anchor"> Add files </a>

At a minimum, a Feature will include a `devcontainer-feature.json` and an `install.sh` entrypoint script.

There are many possible properties for `devcontainer-feature.json`, which you may review in the [Features spec](/features#devcontainer-feature-json-properties).

Below is a hello world example `devcontainer-feature.json` and `install.sh`. You may review the [devcontainers/features](https://github.com/devcontainers/features/blob/main/src) repo for more examples.

[devcontainer-feature.json](https://github.com/devcontainers/feature-starter/blob/main/src/hello/devcontainer-feature.json):

```json
{
    "name": "Hello, World!",
    "id": "hello",
    "version": "1.0.2",
    "description": "A hello world feature",
    "options": {
        "greeting": {
            "type": "string",
            "proposals": [
                "hey",
                "hello",
                "hi",
                "howdy"
            ],
            "default": "hey",
            "description": "Select a pre-made greeting, or enter your own"
        }
    }
}
```

[install.sh](https://github.com/devcontainers/feature-starter/blob/main/src/hello/install.sh):

```bash
#!/bin/sh
set -e

echo "Activating feature 'hello'"

GREETING=${GREETING:-undefined}
echo "The provided greeting is: $GREETING"

cat > /usr/local/bin/hello \
<< EOF
#!/bin/sh
RED='\033[0;91m'
NC='\033[0m' # No Color
echo "\${RED}${GREETING}, \$(whoami)!\${NC}"
EOF

chmod +x /usr/local/bin/hello
```

## <a href="#publishing" name="publishing" class="anchor"> Publishing </a>

The `feature-starter` repo contains a GitHub Action [workflow](https://github.com/devcontainers/feature-starter/blob/main/.github/workflows/release.yaml) that will publish each feature to GHCR. By default, each feature will be prefixed with the `<owner/<repo>` namespace. Using the hello world example from above, it can be referenced in a `devcontainer.json` with: `ghcr.io/devcontainers/feature-starter/color:1`.

> Note: You can use the `devcontainer features publish` command from the [Dev Container CLI](https://github.com/devcontainers/cli) if you are not using GitHub Actions.

The provided GitHub Action will also publish a third "metadata" package with just the namespace, eg: `ghcr.io/devcontainers/feature-starter.  This is useful for supporting tools to [crawl](#add-to-index) metadata about available Features in the collection without downloading _all the Features individually_.

By default, GHCR packages are marked as private. To stay within the free tier, Features need to be marked as public.

This can be done by navigating to the Feature's "package settings" page in GHCR, and setting the visibility to `public`. The URL may look something like:

```
https://github.com/users/<owner>/packages/container/<repo>%2F<featureName>/settings
```

<img style="max-width:70%;height:auto" alt="Changing package visibility to public" src="/img/make-package-public.png"/>

## <a href="#add-to-index" name="add-to-index" class="anchor"> Adding Features to the Index </a>

If you'd like your Features to appear in our [public index](/features) so that other community members can find them, you can do the following:

* Go to [github.com/devcontainers/devcontainers.github.io](https://github.com/devcontainers/devcontainers.github.io), which is the GitHub repo backing [containers.dev](https://containers.dev/)
* Open a PR to modify the [collection-index.yml](https://github.com/devcontainers/devcontainers.github.io/blob/gh-pages/_data/collection-index.yml) file
* Features housed in other OCI Artifact container registries can be included as long as they can be downloaded without a login.

Feature collections are scanned to populate a Feature index on the [containers.dev site](/features) and allow them to appear in Dev Container creation UX in [supporting tools](https://containers.dev/supporting) like [VS Code Dev Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) and [GitHub Codespaces](https://github.com/features/codespaces).



================================================
FILE: _posts/2022-12-16-dockerfile.md
================================================
---
layout: post
title:  "Using Images, Dockerfiles, and Docker Compose"
author:
  - "@chuxel"
authorUrl:
  - https://github.com/chuxel
---

When creating a development container, you have a variety of different ways to customize your environment like ["Features"](/features) or [lifecycle scripts](/implementors/json_reference/#lifecycle-scripts). However, if you are familiar with containers, you may want to use a [Dockerfile](/guide/dockerfile#dockerfile) or [Docker Compose / Compose](/guide/dockerfile#docker-compose) to customize your environment. This article will walk through how to use these formats with the Dev Container spec.

## <a href="#dockerfile" name="dockerfile" class="anchor">  Using a Dockerfile </a>

To keep things simple, many [Dev Container Templates](/templates) use container image references.

```json
{
    "image": "mcr.microsoft.com/devcontainers/base:ubuntu"
}
```

However, [Dockerfiles](https://docs.docker.com/engine/reference/builder/) are a great way to extend images, add additional native OS packages, or make minor edits to the OS image. You can reuse any Dockerfile, but let's walk through how to create one from scratch.

First, add a file named `Dockerfile` next to your `devcontainer.json`. For example:

```Dockerfile
FROM mcr.microsoft.com/devcontainers/base:ubuntu
# Install the xz-utils package
RUN apt-get update && apt-get install -y xz-utils
```

Next, remove the `image` property from `devcontainer.json` (if it exists) and add the `build` and `dockerfile` properties instead:

```json
{
    "build": {
        // Path is relative to the devcontainer.json file.
        "dockerfile": "Dockerfile"
    }
}
```

That's it! When you start up your Dev Container, the Dockerfile will be automatically built with no additional work. See [Dockerfile scenario reference](/implementors/json_reference/#image-specific) for more information on other related devcontainer.json properties.

### <a href="#dockerfile-image-iteration" name="dockerfile-image-iteration" class="anchor"> Iterating on an image that includes Dev Container metadata </a>

Better yet, you can can use a Dockerfile as a part of authoring an image you can share with others. You can even **add Dev Container settings and metadata right into the image itself**. This avoids having to duplicate config and settings in multiple devcontainer.json files and keeps them in sync with your images! 

See the guide on **[pre-building]({% post_url 2023-08-22-prebuild %})** to learn more!

## <a href="#docker-compose" name="docker-compose" class="anchor">  Using Docker Compose </a>

[Docker Compose](https://docs.docker.com/compose/) is a great way to define a multi-container development environment. Rather than adding things like databases or redis to your Dockerfile, you can reference existing images for these services and focus your Dev Container's content on tools and utilities you need for development.

### <a href="#docker-compose-image" name="docker-compose-image" class="anchor"> Using an image with Docker Compose </a>

As mentioned in the Dockerfile section, to keep things simple, many [Dev Container Templates](/templates) use container image references.

```json
{
    "image": "mcr.microsoft.com/devcontainers/base:ubuntu"
}
```

Let's create a `docker-compose.yml` file next to your `devcontainer.json` that references the same image and includes a PostgreSQL database:

```yaml
version: '3.8'
services:
  devcontainer:
    image: mcr.microsoft.com/devcontainers/base:ubuntu
    volumes:
      - ../..:/workspaces:cached
    network_mode: service:db
    command: sleep infinity

  db:
    image: postgres:latest
    restart: unless-stopped
    volumes:
      - postgres-data:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: postgres
      POSTGRES_USER: postgres
      POSTGRES_DB: postgres

volumes:
  postgres-data:
```

In this example:
-  `../..:/workspaces:cached` mounts the workspace folder from the local source tree into the Dev Container.
- `network_mode: service:db` puts the Dev Container on the same network as the database, so that it can access it on `localhost`.
- The `db` section uses the [Postgres](https://hub.docker.com/_/postgres) image with a few settings.

Next, let's configure devcontainer.json to use it.

```json
{
    "dockerComposeFile": "docker-compose.yml",
    "service": "devcontainer",
    "workspaceFolder": "/workspaces/${localWorkspaceFolderBasename}"
}
```

In this example:
- `service` indicates which service in the `docker-compose.yml` file is the Dev Container.
- `dockerComposeFile` indicates where to find the `docker-compose.yml` file.
- `workspaceFolder` indicates where to mount the workspace folder. This corresponds to a sub-folder under the mount point from `../..:/workspaces:cached` in the `docker-compose.yml` file.

That's it!

### <a href="#docker-compose-dockerfile" name="docker-compose-dockerfile" class="anchor"> Using a Dockerfile with Docker Compose </a>

You can also combine these scenarios and use Dockerfile with Docker Compose. This time we'll update `docker-compose.yml` to reference the Dockerfile by replacing `image` with a similar `build` section:

```yaml
version: '3.8'
services:
  devcontainer:
    build: 
      context: .
      dockerfile: Dockerfile
    volumes:
      - ../..:/workspaces:cached      
    network_mode: service:db
    command: sleep infinity

  db:
    image: postgres:latest
    restart: unless-stopped
    volumes:
      - postgres-data:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: postgres
      POSTGRES_USER: postgres
      POSTGRES_DB: postgres

volumes:
  postgres-data:
```

Finally, as in the Dockerfile example, you can use this same setup to create a Dev Container image that you can share with others. You can also add Dev Container settings and metadata right into the image itself. 

See the guide on **[pre-building]({% post_url 2023-08-22-prebuild %})** to learn more!



================================================
FILE: _posts/2023-02-15-gitlab-ci.md
================================================
---
layout: post
title:  "Working with GitLab CI"
author:
  - "@raginjason"
authorUrl:
  - https://github.com/raginjason
---

For simple use cases you can use your development container (dev container) for CI without much issue. Once you begin using more advanced dev container functionality such as [Features](/features), you will need dev container tooling in your CI pipeline. While GitHub CI has the [devcontainers-ci GitHub Action](https://github.com/marketplace/actions/devcontainers-ci), there is no such analog in GitLab CI. To achieve the goal of using your dev container in GitLab CI, the container must be pre-built.

This document will guide you on how to build a dev container with GitLab CI, push that dev container to the GitLab Container Registry, and finally reference that dev container in your main project for both local development and GitLab CI.

For the purpose of this document, we will assume the main project is named `my-project` and lives under the `my-user` path. The example here uses a few [Features](/features), which is what forces the container to be pre-built.

## <a href="#dev-container-project" name="dev-container-project" class="anchor">The Development Container GitLab project</a>

Create a project in GitLab where the stand-alone dev container project will live. As the main project is assumed to be named `my-project`, let's assume the dev container project name will be `my-project-dev-container`

### <a href="#dev-container-json" name="dev-container-json" class="anchor">Development Container .devcontainer/devcontainer.json</a>
 
The example here is a CDK project for Python makes use of both the [AWS CLI](https://github.com/devcontainers/features/tree/main/src/aws-cli) and the community-maintained [AWS CDK](http://github.com/devcontainers-contrib/features/tree/main/src/aws-cdk) Features.

`.devcontainer/devcontainer.json`:

```json
{
  "build": {
    "context": "..",
    "dockerfile": "Dockerfile"
  },
  "features": {
    "ghcr.io/devcontainers/features/aws-cli:1": {},
    "ghcr.io/devcontainers-contrib/features/aws-cdk:2": {}
  },
  "customizations": {
    "vscode": {
      "settings": {
        "python.formatting.provider": "black"
      }
    }
  }
}
```

### <a href="#dev-container-dockerfile" name="dev-container-dockerfile" class="anchor">Development Container Dockerfile</a>

As this is a Python project working with CDK, the `Dockerfile` will begin by using the latest Python dev container image and then install some basic packages via `pip`.

`Dockerfile`:

```Dockerfile
FROM mcr.microsoft.com/devcontainers/python:latest

RUN pip3 --disable-pip-version-check --no-cache-dir install aws_cdk_lib constructs jsii pylint \
    && rm -rf /tmp/pip-tmp
```

### <a href="#dev-container-gitlab-ci" name="dev-container-gitlab-ci" class="anchor">Development Container .gitlab-ci.yml</a>

Since there is no GitLab CI equivalent to [devcontainers-ci GitHub Action](https://github.com/marketplace/actions/devcontainers-ci), we will need to install the devcontainers CLI manually. The following will:

1. Install the packages that the devcontainers CLI requires
2. Install the devcontainers CLI itself
3. Login to GitLab Container Repository
4. Build the dev container and push it to the GitLab Container Repository

`.gitlab-ci.yml`:

```yaml
image: docker:latest

variables:
  DOCKER_TLS_CERTDIR: "/certs"

services:
  - docker:dind

before_script:
  - apk add --update nodejs npm python3 make g++
  - npm install -g @devcontainers/cli

build:
  stage: build
  script:
    - docker login -u gitlab-ci-token -p ${CI_JOB_TOKEN} ${CI_REGISTRY}
    - devcontainer build --workspace-folder . --push true --image-name ${CI_REGISTRY_IMAGE}:latest
```

## <a href="#main-project" name="main-project" class="anchor">The Main GitLab project</a>

### <a href="#main-project-devcontainer-json" name="main-project-devcontainer-json" class="anchor">Main .devcontainer/devcontainer.json</a>

`.devcontainer/devcontainer.json`:

```json
{
  "image": "registry.gitlab.com/my-user/my-project-dev-container"
}
```

### <a href="#main-project-gitlab-ci-json" name="main-project-gitlab-ci-json" class="anchor">Main .gitlab.ci.yml</a>

Assuming the dev container project name is based off the main project name, the `${CI_REGISTRY_NAME}` variable can be used. This configuration performs some basic sanity checks and linting once merge requests are submitted.

`.gitlab-ci.json`:

```yaml
image: ${CI_REGISTRY_IMAGE}-dev-container:latest

before_script:
  - python --version
  - cdk --version

stages:
  - Build
  - Lint

py_compile:
  stage: Build
  script:
    - find . -type f -name "*.py" -print | xargs -n1 python3 -m py_compile
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

cdk synth:
  stage: Build
  script:
    - JSII_DEPRECATED=fail cdk --app "python3 app.py" synth
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

Pylint:
  stage: Lint
  script:
    - pylint *
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

Black code format:
  stage: Lint
  script:
    - black --check --diff .
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
```

## <a href="#conclusion" name="conclusion" class="anchor">Conclusion</a>

It's worth noting that the best practice would be to pin the versions of the various packages installed by `pip`, `apk`, `npm` and the like. Version pinning was omitted from this guide so that it can be executed as-is without issue.

The above provides a starting point for a dev container that's used for both local development and in GitLab CI. It can easily be customized for other languages and tool chains. Take it and make it your own, happy coding!


================================================
FILE: _posts/2023-06-14-feature-authoring-best-practices.md
================================================
---
layout: post
title:  "Best Practices: Authoring a Dev Container Feature"
author:
  - "@joshspicer"
authorUrl:
  - https://github.com/joshspicer
---

Last November I wrote about the basics around [authoring a Dev Container Feature](/guide/author-a-feature). Since then, [hundreds](https://containers.dev/features) of Features have been written by the community. The flexibility of Features has enabled a wide variety of use cases, from installing a single tool to setting up specific aspects of a project's development environment that can be shared across repositories.  To that effect, many different patterns for Feature authorship have emerged, and the core team has learned a lot about what works well and what doesn't.

## Utilize the `test` command

Bundled with the [devcontainer cli](https://github.com/devcontainers/cli) is the `devcontainer features test` command.  This command is designed to help Feature authors test their Feature in a variety of scenarios.  It is highly recommended that Feature authors use this command to test their Feature before publishing. Some documentation on the `test` command can be found [here](https://github.com/devcontainers/cli/blob/main/docs/features/test.md), and an example can be found in the [Feature quick start repo](https://github.com/devcontainers/feature-starter). This repo is updated periodically as new functionality is added to the reference implementation.

## Feature idempotency

The most useful Features are idempotent. This means that if a Feature is installed multiple times with different options (something that will come into play with [Feature Dependencies](https://github.com/devcontainers/spec/blob/main/proposals/feature-dependencies.md)), the Feature should be able to handle this gracefully. This is especially important for option-rich Features that you anticipate others may depend on in the future.

> 🔧 There is an open spec proposal for installing the same Feature twice in a given `devcontainer.json` [(devcontainers/spec#44)](https://github.com/devcontainers/spec/issues/44).  While the syntax to do so in a given `devcontainer.json` is not yet defined, Feature dependencies will effectively allow for this.

For Features that install a versioned tool (eg: version x of `go` and version y of `ruby` ), a robust Feature should be able to install multiple versions of the tool.  If your tool has a version manager (java's `SDKMAN`, ruby's `rvm`) it is usually as simple as installing the version manager and then running a command to install the desired version of that tool.

For instances where there isn't an existing version manager available, a well-designed Feature should consider installing distict versions of itself to a well known location.  A pattern that many Features utilize successfully is writing each version of each tool to a central folder and symlinking the "active" version to a folder on the PATH.

Features can redefine the PATH variable with `containerEnv`, like so:

```bash
# devcontainer-feature.json
"containerEnv": {
    "PATH": "/usr/local/myTool/bin:${PATH}"
}
```

> 🔧 A spec proposal is open for simplifying the process of adding a path to the $PATH variable: [(devcontainers/spec#251)](https://github.com/devcontainers/spec/issues/251).

To make testing for idempotency easy, [this change to the reference implementation](https://github.com/devcontainers/cli/pull/553) introduces a new mode to the `devcontainer features test` command that will attempt to install a Feature multiple times.  This is useful for testing that a Feature is idempotent, and also for testing that a Feature is able to logically "juggle" multiple versions of a tool.

## Writing your install script


> 🔧 Many of the suggestions in this section may benefit from the [Feature library/code reuse proposal](https://github.com/devcontainers/spec/blob/main/proposals/features-library.md).

This section includes some tips for the contents of the `install.sh` entrypoint script.

### Detect Platform/OS

> 🔧 A spec proposal is open for detecting the platform/OS and providing better warnings [(devcontainers/spec#58)](https://github.com/devcontainers/spec/issues/58).

Features are often designed to work on a subset of possible base images.  For example, the majority of Features in the [`devcontainers/features`](https://github.com/devcontainers/features) repo are designed to work broadly with debian-derived images.  The limitation is often simply due to the wide array of base images available, and the fact that many Features will use an OS-specific package manager.  To make it easy for users to understand which base images a Feature is designed to work with, it is recommended that Features include a check for the OS and provide a helpful error message if the OS is not supported.

One possible way to implement this check is shown below.

```bash
# Source /etc/os-release to get OS info
# Looks something like:
#     PRETTY_NAME="Debian GNU/Linux 11 (bullseye)"
#     NAME="Debian GNU/Linux"
#     VERSION_ID="11"
#     VERSION="11 (bullseye)"
#     VERSION_CODENAME=bullseye
#     ID=debian
#     HOME_URL="https://www.debian.org/"
#     SUPPORT_URL="https://www.debian.org/support"
#     BUG_REPORT_URL="https://bugs.debian.org/"
. /etc/os-release
# Store host architecture
architecture="$(dpkg --print-architecture)"

DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES="buster bullseye focal bionic xenial"
if [[ "${DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES}" != *"${VERSION_CODENAME}"* ]]; then
    print_error "Unsupported  distribution version '${VERSION_CODENAME}'. To resolve, either: (1) set feature option '\"moby\": false' , or (2) choose a compatible OS distribution"
    print_error "Supported distributions include:  ${DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES}"
    exit 1
fi
```

If you are targeting distros that may not have your desired scripting language installed (eg: `bash` is often not installed on `alpine` images), you can either use plain `/bin/sh` - which is available virtually everywhere - or you can verify (and install) the scripting language in a small bootstrap script as shown below.

```sh
#!/bin/sh 

# ... 
# ...

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# If we're using Alpine, install bash before executing
. /etc/os-release
if [ "${ID}" = "alpine" ]; then
    apk add --no-cache bash
fi

exec /bin/bash "$(dirname $0)/main.sh" "$@"
exit $?
```

Validating functionality against several base images can be done by using the `devcontainer features test` command with the `--base-image` flag, or with a [scenario](https://github.com/devcontainers/cli/blob/main/docs/features/test.md#scenarios).  For example,  one could add a [workflow like this to their repo](https://github.com/devcontainers/features/blob/d934503a050ba84e6b42a006aacd891c4088eb62/.github/workflows/test-all.yaml#L9-L52).

```yaml
name: "Test Features matrixed with a set of base images"
on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    continue-on-error: true
    strategy:
      matrix:
        features: [
            "anaconda",
            "aws-cli",
            "azure-cli",
            # ...
        ]
        baseImage:
          [
            "ubuntu:bionic",
            "ubuntu:focal",
            "ubuntu:jammy",
            "debian:11",
            "debian:12",
            "mcr.microsoft.com/devcontainers/base:ubuntu",
            "mcr.microsoft.com/devcontainers/base:debian",
          ]
    steps:
      - uses: actions/checkout@v3

      - name: "Install latest devcontainer CLI"
        run: npm install -g @devcontainers/cli
        {% raw %}
      - name: "Generating tests for '${{ matrix.features }}' against '${{ matrix.baseImage }}'"
        run: devcontainer features test  --skip-scenarios -f ${{ matrix.features }} -i ${{ matrix.baseImage }}
        {% endraw %} 
```

### Detect the non-root user

Feature installation scripts are run as `root`.  In contrast, many dev containers have a `remoteUser` set (either implicitly through [image metadata](https://containers.dev/implementors/spec/#image-metadata) or directly in the `devcontainer.json`).  In a Feature's installation script, one should be mindful of the final user and account for instances where the user is not `root`.

Feature authors should take advantage of the [`_REMOTE_USER` and similar variables](https://containers.dev/implementors/features/#user-env-var) injected during the build.

```bash
# Install tool in effective remoteUser's bin folder
mkdir -p "$_REMOTE_USER_HOME/bin"
curl $TOOL_DOWNLOAD_LINK -o "$_REMOTE_USER_HOME/bin/$TOOL"
chown $_REMOTE_USER:$_REMOTE_USER "$_REMOTE_USER_HOME/bin/$TOOL"
chmod 755 "$_REMOTE_USER_HOME/bin/$TOOL"
```

### Implement redundant paths/strategies

Most Features in [the index today](https://containers.dev/features) have some external/upstream dependency.  Very often these upstream dependencies can change (ie: versioning pattern, rotated GPG key, etc...) that may cause a Feature to fail to install.  To mitigate this, one strategy is to implement multiple paths to install a given tool (if available).  For example, a Feature that installs `go` might try to install it from the upstream package manager, and if not fall back to a GitHub release.

Writing several [scenario tests](https://github.com/devcontainers/cli/blob/main/docs/features/test.md#scenarios) that force the Feature to go down distinct installation paths will help you catch cases where a given path no longer works.


================================================
FILE: _posts/2023-08-22-prebuild.md
================================================
---
layout: post
title:  "Speed Up Your Workflow with Prebuilds"
author:
  - "@bamurtaugh"
  - "@craiglpeters"
authorUrl:
  - "https://github.com/bamurtaugh"
  - "https://github.com/craiglpeters"

---

Getting dev containers up and running for your projects is exciting - you've unlocked environments that include all the dependencies your projects need to run, and you can spend so much more time on coding rather than configuration. 

Once your dev container has everything it needs, you might start thinking more about ways to optimize it. For instance, it might take a while to build. Maybe it takes 5 minutes. Maybe it takes an hour! 

You can get back to working fast and productively after that initial container build, but what if you need to work on another machine and build the container again? Or what if some of your teammates want to use the container on their machines and will need to build it too? It'd be great to make the build time faster for everyone, every time.

After configuring your dev container, a great next step is to **prebuild your image**. 

In this guide, we'll explore what it means to prebuild an image and the benefits of doing so, such as speeding up your workflow, simplifying your environment, and pinning to specific versions of tools.

We have a variety of tools designed to help you with prebuilds. In this guide, we'll explore two different repos as examples of how our team uses different combinations of these tools:
* The prebuilt image for the [Kubernetes repo](https://github.com/craiglpeters/kubernetes-devcontainer) developed by one of our spec maintainers [Craig](https://github.com/craiglpeters) 
* The prebuilt images we host in the [devcontainers/images](https://github.com/devcontainers/images/tree/main/src) repo as part of the dev container spec


## <a href="#what-is-a-prebuild" name="what-is-a-prebuild" class="anchor"> What is prebuilding? </a>

We should first define: What is prebuilding?

If you're already using dev containers, you're likely already familiar with the idea of building a container, where you package everything your app needs to run into a single unit. 

You need to build your container once it has all the dependencies it needs, and rebuild anytime you add new dependencies. Since you may not need to rebuild often, it might be alright if it takes a while for that initial build. But if you or your teammates need to use that container on another machine, you'll need to wait for it to build again in those new environments.

> **Note:** The [dev container CLI doc](/implementors/reference#prebuilding) is another great resource on prebuilding.

### <a href="#prebuilt-codespaces" name="prebuilt-codespaces" class="anchor"> Prebuilt Codespaces </a>

You may have heard (or will hear about) [GitHub Codespaces prebuilds](https://docs.github.com/en/codespaces/prebuilding-your-codespaces/about-github-codespaces-prebuilds). Codespaces prebuilds are similar to prebuilt container images, with some additional focus on the other code in your repo.

GitHub Codespaces prebuilds help to speed up the creation of new codespaces for large or complex repositories. A prebuild assembles the main components of a codespace for a particular combination of repository, branch, and `devcontainer.json` file.

By default, whenever you push changes to your repository, GitHub Codespaces uses GitHub Actions to automatically update your prebuilds.

You can learn more about codespaces prebuilds and how to manage them in the [codespaces docs](https://docs.github.com/en/codespaces/prebuilding-your-codespaces/about-github-codespaces-prebuilds).

## <a href="#how-to" name="how-to" class="anchor"> How do I prebuild my image? </a>

We try to make prebuilding an image and using a prebuilt image as easy as possible. Let's walk through the couple of steps to get started.

**Prebuilding an image:**
* Install the [Dev Container CLI](/implementors/reference):

     ```bash
     npm install -g @devcontainers/cli
     ```

* Build your image and push it to a container registry (like the [Azure Container Registry](https://learn.microsoft.com/azure/container-registry/container-registry-get-started-docker-cli?tabs=azure-cli), [GitHub Container Registry](https://docs.github.com/packages/working-with-a-github-packages-registry/working-with-the-container-registry#pushing-container-images), or [Docker Hub](https://docs.docker.com/engine/reference/commandline/push)):

     ```bash
     devcontainer build --workspace-folder . --push true --image-name <my_image_name>:<optional_image_version>
     ```

* You can automate pre-building your image by scheduling the build using a DevOps or continuous integration (CI) service like GitHub Actions. We've created a [GitHub Action](https://github.com/marketplace/actions/dev-container-build-and-run-action) and [Azure DevOps task](https://marketplace.visualstudio.com/items?itemName=devcontainers.ci) to help with this.

**Using a prebuilt image:**
* Determine the published URL of the prebuilt image you want to use
* Reference it in your `devcontainer.json`, Dockerfile, or Docker Compose file
     * In our previous guide on ["Using Images, Dockerfiles, and Docker Compose,"](/guide/dockerfile) we also showed how you can use prebuilt images, Dockerfiles, or Docker Compose files for your configurations

### <a href="#prebuild-examples" name="prebuild-examples" class="anchor"> Prebuild Examples </a>

As mentioned above, let's walk through a couple examples of these steps, one using Craig's [Kubernetes repo](https://github.com/craiglpeters/kubernetes-devcontainer), and the other using our [devcontainers/images](https://github.com/devcontainers/images/tree/main/src) repo.

**Kubernetes**
* It's a fork of the main [Kubernetes repo](https://github.com/kubernetes/kubernetes) and contributes a prebuilt dev container for use in the main Kubernetes repo or any other forks
* The dev container it's prebuilding is defined in the [.github/.devcontainer folder](https://github.com/craiglpeters/kubernetes-devcontainer/tree/master/.github/.devcontainer)
* Any time a change is made to the dev container, the repo currently uses the dev container [GitHub Action](https://github.com/craiglpeters/kubernetes-devcontainer/actions/workflows/devcontainer-build-and-push.yml) to build the image and push it to GHCR
     * You can check out its latest prebuilt image in the [`Packages` tab](https://github.com/users/craiglpeters/packages/container/package/kubernetes-devcontainer) of its GitHub Repo. In this tab, you can see its GHCR URL is `ghcr.io/craiglpeters/kubernetes-devcontainer:latest`
* The main Kubernetes repo and any fork of it can now define a `.devcontainer` folder and [reference this prebuilt image](https://github.com/craiglpeters/kubernetes-devcontainer/blob/master/.devcontainer/devcontainer.json#L7) through: `"image": "ghcr.io/craiglpeters/kubernetes-devcontainer:latest"`

**Dev container spec images**
* This repo prebuilds a variety of dev containers, each of which is defined in their individual folders in the [src folder](https://github.com/devcontainers/images/tree/main/src)
     * As an example, the Python image is defined in the [src/python/.devcontainer](https://github.com/devcontainers/images/tree/main/src/python/.devcontainer) folder 
* Any time a change is made to the dev container, the repo uses a [GitHub Action](https://github.com/devcontainers/images/actions/workflows/push.yml) to build the image and push it to MCR
     * Using the Python image as an example again, its MCR URL is `mcr.microsoft.com/devcontainers/python`
* Any projects can now reference this prebuilt image through: `"image": "mcr.microsoft.com/devcontainers/python"`

## <a href="#where" name="where" class="anchor"> Where do the dependencies come from? </a>

If your `devcontainer.json` is as simple as just an `image` property referencing a prebuilt image, you may wonder: How can I tell what dependencies will be installed for my project? And how can I modify them?

Let's walk through the Kubernetes prebuild as an example of how you can determine which dependencies are installed and where:
* **Start at your end user dev container**
     * We start at the [`.devcontainer/devcontainer.json`](https://github.com/craiglpeters/kubernetes-devcontainer/blob/master/.devcontainer/devcontainer.json) designed for end use in the Kubernetes repo and other forks of it
          * It sets a few properties, such as `hostRequirements`, `onCreateCommand`, and `otherPortsAttributes`
          * We see it references a prebuilt image, which will include dependencies that don't need to be explicitly mentioned in this end user dev container. Let's next go explore the dev container defining this prebuilt image
* **Explore the dev container defining your prebuilt image**
     * We next open the config that defines the prebuilt image. This is contained in the [`.github/.devcontainer` folder](https://github.com/craiglpeters/kubernetes-devcontainer/tree/master/.github/.devcontainer)
     * We see there's a [`devcontainer.json`](https://github.com/craiglpeters/kubernetes-devcontainer/blob/master/.github/.devcontainer/devcontainer.json). It's much more detailed than the end user dev container we explored above and includes a variety of [Features](/implementors/features)
* **Explore content in the prebuilt dev container's config**
     * Each Feature defines additional functionality
     * We can explore what each of them installs in their associated repo. Most appear to be defined in the [devcontainers/features repo](https://github.com/devcontainers/features/tree/main/src) as part of the dev container spec
* **Modify and rebuild as desired**
     * If I'd like to add more content to my dev container, I can either modify my end user dev container (i.e. the one designed for the main Kubernetes repo), or modify the config defining the prebuilt image (i.e. the content in Craig's dev container)
          * For universal changes that anyone using the prebuilt image should get, update the prebuilt image
          * For more project or user specific changes (i.e. a language I need in my project but other forks won't necessarily need, or user settings I prefer for my editor environment), update the end user dev container
     * Features are a great way to add dependencies in a clear, easily packaged way

## <a href="#benefits" name="benefits" class="anchor"> Benefits </a>

There are a variety of benefits (some of which we've already explored) to creating and using prebuilt images:
* Faster container startup
     * Pull an already built dev container config rather than having to build it freshly on any new machine
* Simpler configuration
     * Your `devcontainer.json` can be as simple as just an `image` property
* Pin to a specific version of tools
     * This can improve supply-chain security and avoid breaks  

## <a href="#tips" name="tips" class="anchor"> Tips and Tricks </a>

* We explored the prebuilt images we host as part of the spec in [devcontainers/images](https://github.com/devcontainers/images/tree/main/src). These can form a great base for other dev containers you'd like to create for more complex scenarios
* The spec has a concept of Development container "Templates" which are source files packaged together that encode configuration for a complete development environment
     * A Template may be as simple as a `devcontainer.json` referencing a prebuilt image, and a `devcontainer-template.json`
     * You can learn more about Templates in our [Templates documentation](../implementors/templates)
     * You can adopt and iterate on [existing Templates](../templates.html) from the spec and community, or you can [create and share your own](../implementors/templates-distribution)
* You can include Dev Container configuration and Feature metadata in prebuilt images via [image labels](https://docs.docker.com/config/labels-custom-metadata/). This makes the image self-contained since these settings are automatically picked up when the image is referenced - whether directly, in a `FROM` in a referenced Dockerfile, or in a Docker Compose file. You can learn more in our [reference docs](/implementors/reference#labels)
* You can use multi-stage Dockerfiles to create a prod container from your dev container
     * You'd typically start with your prod image, then add to it
     * Features provide a quick way to add development and CI specific layers that you wouldn't use in production
     * For more information and an example, check out our [discussion on multi-stage builds](https://github.com/orgs/devcontainers/discussions/4#discussioncomment-4152158)

## <a href="#feedback" name="feedback" class="anchor"> Feedback and Closing </a>

We hope this guide will help you optimize your dev container workflows! We can't wait to hear your tips, tricks, and feedback. How are you prebuilding your images? Would anything in the spec or tooling make the process easier for you?

If you haven't already, we recommend joining our dev container [community Slack channel](https://aka.ms/dev-container-community) where you can connect with the dev container spec maintainers and community at large. If you have any feature requests or experience any issues as you use the above tools, please feel free to also open an issue in the corresponding repo in the [dev containers org](https://github.com/devcontainers) on GitHub.



================================================
FILE: _posts/2024-01-23-dependabot.md
================================================
---
layout: post
title:  "General Availability of Dependabot Integration"
author:
    - "@joshspicer"
authorUrl:
    - https://github.com/joshspicer
---

We are excited to announce that starting today, in collaboration with the Dependabot Team, the `devcontainers` package ecosystem is now generally available! 
 Dependabot will now be able to update your public Dev Container [Features](https://containers.dev/features), keeping them up-to-date with the latest published versions.

 To opt-in, add a `.github/dependabot.yml` to a repository containing one or more `devcontainer.json` configuration files:

 ```yaml
# To get started with Dependabot version updates, you'll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for all configuration options:
# https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates

version: 2
updates:
  - package-ecosystem: "devcontainers" # See documentation for possible values
    directory: "/"
    schedule:
      interval: weekly
 ```

Once configured, Dependabot will begin to create pull requests to update your Dev Container Features:


<div style="display: flex; justify-content: center;">
    <img style="max-width: 100%; height: auto;" src="/img/dependabot-pr.png" alt="Dependabot PR">
</div>

An example diff generated by Dependabot is shown below:

```diff
---
 .devcontainer-lock.json              | 8 ++++----
 .devcontainer.json                   | 2 +-
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/.devcontainer-lock.json b/.devcontainer-lock.json
index 324582b..a3868d9 100644
--- a/.devcontainer-lock.json
+++ b/.devcontainer-lock.json
@@ -1,9 +1,9 @@
 {
   "features": {
-    "ghcr.io/devcontainers/features/docker-in-docker:1": {
-      "version": "1.0.9",
-      "resolved": "ghcr.io/devcontainers/features/docker-in-docker@sha256:b4c04ba88371a8ec01486356cce10eb9fe8274627d8d170aaec87ed0d333080d",
-      "integrity": "sha256:b4c04ba88371a8ec01486356cce10eb9fe8274627d8d170aaec87ed0d333080d"
+    "ghcr.io/devcontainers/features/docker-in-docker:2": {
+      "version": "2.7.1",
+      "resolved": "ghcr.io/devcontainers/features/docker-in-docker@sha256:f6a73ee06601d703db7d95d03e415cab229e78df92bb5002e8559bcfc047fec6",
+      "integrity": "sha256:f6a73ee06601d703db7d95d03e415cab229e78df92bb5002e8559bcfc047fec6"
     }
   }
 }
\ No newline at end of file
diff --git a/.devcontainer.json b/.devcontainer.json
index e9d9af5..9eb9165 100644
--- a/.devcontainer.json
+++ b/.devcontainer.json
@@ -1,6 +1,6 @@
 {
     "image": "mcr.microsoft.com/devcontainers/base:jammy",
     "features": {
-        "ghcr.io/devcontainers/features/docker-in-docker:1": {}
+        "ghcr.io/devcontainers/features/docker-in-docker:2": {}
     }
 }
```

 This updater ensures publicly-accessible Features are pinned to the latest version in the associated `devcontainer.json` file.  If a dev container has an associated lockfile, that file will also be updated. For more information on lockfiles, see this [specification](https://github.com/devcontainers/spec/blob/main/docs/specs/devcontainer-lockfile.md).

Features in any [valid dev container location](https://containers.dev/implementors/spec/#devcontainerjson) will be updated in a single pull request.

Dependabot version updates are free to use for all repositories on GitHub.com.  For more information [see the Dependabot version update documentation](https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/about-dependabot-version-updates#supported-repositories-and-ecosystem).



================================================
FILE: css/main.scss
================================================
---
# Only the main Sass file needs front matter (the dashes are enough)
---
@charset "utf-8";

img[alt=without_DAP] { width: 60%; height: 60%; }
img[alt=with_DAP] { width: 75%; height: 75%; }
img[alt=init-launch] { width: 80%; height: 80%; }
img[alt=stop-continue-terminate] { width: 80%; height: 80%; }
img[alt=breakpoint] { width: 80%; height: 80%; }

html {
	position: relative;
	min-height: 100%;
}

body {
	letter-spacing: .25px;
	text-rendering: optimizeLegibility;
}

.single-page {
	padding: 40px 0;
}

.bg-primary {
	background-color: #{{ site.theme_color }} !important;
  }

.header-container {
  color: #fff;

  @media (min-width: 576px) {
  	margin-bottom: 80px;
  }

  h1 {
	margin-top: 15px;
	font-weight: bold;
  }

  .intro {
	  text-align: center;
  }

  .intro-text {
	  margin: 0 auto;
	  max-width: 450px;
	  text-align: center;
  }
}

h2 {
	margin-bottom: 20px;
}

.toc {
	font-size: 85%
}

.toc-title {
	padding-left: 0.5rem
}

.toc-h1 {
	padding-top: 0.5rem;
	padding-left: 0.5rem;
	margin-bottom: 0;
}

.toc-link {
	padding: 0.125rem 0.5rem;
	color: #707070
}

.anchor {
	display: block;
}

pre[class=highlight] {
	padding: 9.5px;
	overflow: auto;
	font-size: 85%;
	line-height: 1.45;
	background-color: #f6f8fa;
	border: 1px solid #ccc;
	border-radius: 4px;
	background: #f6f8fa
}

.highlight .hll {
	background-color: #EFEFEF
}

.highlight .c {
	color: #525151
}

.highlight .err {
	color: #525151
}

.highlight .k {
	color: #8959A8
}

.highlight .l {
	color: #85450A
}

.highlight .n {
	color: #525151
}

.highlight .o {
	color: #545454
}

.highlight .p {
	color: #525151
}

.highlight .cm {
	color: #525151
}

.highlight .cp {
	color: #525151
}

.highlight .c1 {
	color: #525151
}

.highlight .cs {
	color: #525151
}

.highlight .gd {
	color: #C82829
}

.highlight .ge {
	font-style: italic
}

.highlight .gh {
	color: #545454;
	font-weight: bold
}

.highlight .gi {
	color: #5B7201
}

.highlight .gp {
	color: #5B7201;
	font-weight: bold
}

.highlight .gs {
	font-weight: bold
}

.highlight .gu {
	color: #3E999F;
	font-weight: bold
}

.highlight .kc {
	color: #8959A8
}

.highlight .kd {
	color: #8959A8
}

.highlight .kn {
	color: #3E999F
}

.highlight .kp {
	color: #4271AE
}

.highlight .kr {
	color: #8959A8
}

.highlight .kt {
	color: #EAB700
}

.highlight .ld {
	color: #5B7201
}

.highlight .m {
	color: #85450A
}

.highlight .s {
	color: #5B7201
}

.highlight .na {
	color: #4271AE
}

.highlight .nb {
	color: #4271AE
}

.highlight .nc {
	color: #EAB700
}

.highlight .no {
	color: #EAB700
}

.highlight .nd {
	color: #3E999F
}

.highlight .ni {
	color: #545454
}

.highlight .ne {
	color: #C82829
}

.highlight .nf {
	color: #4271AE
}

.highlight .nl {
	color: #545454
}

.highlight .nn {
	color: #EAB700
}

.highlight .nx {
	color: #4271AE
}

.highlight .py {
	color: #545454
}

.highlight .nt {
	color: #3E999F
}

.highlight .nv {
	color: #C82829
}

.highlight .ow {
	color: #3E999F
}

.highlight .w {
	color: #545454
}

.highlight .mf {
	color: #85450A
}

.highlight .mh {
	color: #85450A
}

.highlight .mi {
	color: #85450A
}

.highlight .mo {
	color: #85450A
}

.highlight .sb {
	color: #5B7201
}

.highlight .sc {
	color: #545454
}

.highlight .sd {
	color: #525151
}

.highlight .s2 {
	color: #5B7201
}

.highlight .se {
	color: #85450A
}

.highlight .sh {
	color: #5B7201
}

.highlight .si {
	color: #85450A
}

.highlight .sx {
	color: #5B7201
}

.highlight .sr {
	color: #5B7201
}

.highlight .s1 {
	color: #5B7201
}

.highlight .ss {
	color: #5B7201
}

.highlight .bp {
	color: #545454
}

.highlight .vc {
	color: #C82829
}

.highlight .vg {
	color: #C82829
}

.highlight .vi {
	color: #C82829
}

.highlight .il {
	color: #85450A
}

.more-info {
	padding: 100px 0;

	p {
		padding: 0;
	}
}

.footer {
	padding: 15px 0;
	color: #000;
	background: #e9ecef;

	@media (min-width: 576px) {
		padding: 50px 0;
	}

	img {
		width: 100px;
	}

	a#footer-microsoft-link {
		display: block;
	}

	ul {
		margin: 0;
		padding: 0;
	}

	.message {
		display: inline-block;
		padding-right: 10px;
	}

	.links {
		padding-bottom: 10px;

		@media (min-width: 576px) {
			padding: 0;
		}

		li {
			list-style: none;
			padding-bottom: 10px;

			@media (min-width: 576px) {
				display: inline-block;
				padding: 0;
			}
		}
	}

	iframe {
		position: relative;
		top: 5px;
	}
}

@media (min-width: 992px) {
	.dap-navbar {
		position: -webkit-sticky;
		position: sticky;
		top: 0;
		z-index: 1071;
	}

	.dap-sidebar {
		position: -webkit-sticky;
		position: sticky;
		top: 100px;
		z-index: 1000;
		height: calc(100vh - 110px);
		overflow: auto;
	}

	h3 .anchor, h4 .anchor, h5 .anchor {
		scroll-margin-top: 60px;
	}
}

@media (max-width: 991px) {
	.dap-sidebar {
		margin-top: 1rem;
		margin-bottom: 1rem;
	}
}

.navbar-brand h1 {
    font-size: 18px;
    font-weight: bold;
    margin: 0;
}

.nav .nav-link {
	color: #{{ site.theme_color }} !important;
  }

.nav .nav-link:hover {
	color: #1034a8 !important;
}

a {
	color: #{{ site.theme_color }};
}

a:hover {
	color: #1034a8
}

.navbar-dark .navbar-nav .nav-link:hover {
    color: rgba(255,255,255,0.5);
}

.navbar-dark .navbar-nav .nav-link {
	color: white;
}

.docs-nav {
	h4 {
		display: inline-block;
		font-size: 14px;
	}
}

.dap-sidebar .card {
	padding-top: 1px;
}

h2 a, h3 a, h4 a, a h3 {
	padding-top: 2px;
	padding-bottom: 2px;
}

h1 a {
	padding-top: 3px;
	padding-bottom: 3px;
}


================================================
FILE: js/page.js
================================================
$('#small-nav-dropdown').change(function() {
  window.location = $(this)
    .find('option:selected')
    .val()
})

const site_tag = 'UA-62780441-30';
function loadAnalytics(gtag) {
  // set cookie to expire in 12 x 28 days
  gtag('config', site_tag, { 'anonymize_ip': true, 'cookie_expires': 29030400 })
}

function onConsentChanged() {
  function gtag() {
    window.dataLayer.push(arguments)
  }

  if (!consentRequired() || WcpConsent.siteConsent.getConsentFor(WcpConsent.consentCategories.Analytics)) {
    // Load GA
    loadAnalytics(gtag)
  }
}

function consentRequired() {
  return WcpConsent.siteConsent.isConsentRequired;
}

$(function() {
  // Load GA upfront because we classify it as essential cookie
  window.dataLayer = window.dataLayer || []
  function gtag() {
    dataLayer.push(arguments)
  }
  gtag('js', new Date())

  window.WcpConsent && WcpConsent.init("en-US", "cookie-banner", function (err, _siteConsent) {
  }, onConsentChanged, WcpConsent.themes.light);

  const cookieManager = document.querySelector('#footer-cookie-link');
  if (consentRequired() && cookieManager && cookieManager.parentElement) {
    cookieManager.parentElement.style.display = '';
  }

  // initialize consent
  onConsentChanged();
})


================================================
FILE: static/.keep
================================================
[Empty file]


================================================
FILE: .codesandbox/tasks.json
================================================
{
  // These tasks will run in order when initializing your CodeSandbox project.
  "setupTasks": [
    {
      "name": "Install dependencies",
      "command": "bundle install"
    }
  ],

  // These tasks can be run from CodeSandbox. Running one will open a log in the app.
  "tasks": {
    "bundle exec jekyll serve": {
      "name": "bundle exec jekyll serve",
      "command": "bundle exec jekyll serve --host 0.0.0.0",
      "runAtStart": true,
      "preview": {
        "port": 4000
      }
    },
    "ruby:typecheck": {
      "name": "Typecheck",
      "command": "solargraph typecheck"
    }
  }
}



================================================
FILE: .devcontainer/devcontainer.json
================================================
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/jekyll
{
	"name": "Jekyll",
	// Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
	"image": "mcr.microsoft.com/devcontainers/jekyll:1-bullseye",

	// Features to add to the dev container. More info: https://containers.dev/features.
	"features": {
		"ghcr.io/devcontainers/features/node:1": {
		  "version": "latest"
		}
	},

	// Use 'forwardPorts' to make a list of ports inside the container available locally.
	"forwardPorts": [
		// Jekyll server
		4000,
		// Live reload server
		35729
	]

	// Uncomment the next line to run commands after the container is created.
	// "postCreateCommand": "jekyll --version"

	// Configure tool-specific properties.
	// "customizations": {},

	// Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
	// "remoteUser": "root"
}



================================================
FILE: .devcontainer/fetch-index.sh
================================================
#!/bin/bash

pushd /tmp
    curl -LO https://github.com/oras-project/oras/releases/download/v0.13.0/oras_0.13.0_linux_amd64.tar.gz
    mkdir -p oras-install/
    tar -zxf oras_0.13.0_*.tar.gz -C oras-install/
    mv oras-install/oras /usr/local/bin/
    rm -rf oras_0.13.0_*.tar.gz oras-install/
popd

cd /workspaces/devcontainers.github.io/_data
oras pull ghcr.io/devcontainers/index:latest
cp devcontainer-index.json ../static/


================================================
FILE: .github/pull_request_template.md
================================================
<!--
     📖 Before submitting a Pull Request, please ensure you've read the Contributing Guide: https://containers.dev/implementors/contributing/
-->

## What type of PR is this?

- [ ] Add a new dev container collection
- [ ] Update to an existing dev container collection
- [ ] Documentation/spec update
- [ ] Other containers.dev site update (UX, layout, etc)

## Related Issues

<!--
For pull requests that relate or close an issue, please include them
below. For example: "closes #1234" would connect the current pull
request to issue 1234. When we merge the pull request, Github will
automatically close the issue.
-->

- Related Issue #
- Closes #

## Description

_Please replace this line with a description of your PR._

### Collection checklist
_If your PR contributes a new collection, please utilize this checklist:_
- [ ] Collection name
- [ ] Maintainer name
- [ ] Maintainer contact link (i.e. link to a GitHub repo, email)
- [ ] Repository URL
- [ ] OCI Reference
- [ ] I acknowledge that this collection provides new functionality, distinct from the existing collections part of this index.


================================================
FILE: .github/workflows/publish.yml
================================================
name: Publish to GitHub Pages

on:
  push:
    branches: ["gh-pages"]
  workflow_dispatch:
  schedule:
    # Run Daily at 9:00 AM UTC
    # Pick up updates to crawled Features
    - cron:  '0 9 * * *'

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow one concurrent deployment
concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Install Oras
        run: |
          curl -LO https://github.com/oras-project/oras/releases/download/v0.13.0/oras_0.13.0_linux_amd64.tar.gz
          mkdir -p oras-install/
          tar -zxf oras_0.13.0_*.tar.gz -C oras-install/
          mv oras-install/oras /usr/local/bin/
          rm -rf oras_0.13.0_*.tar.gz oras-install/

      - name: Fetch devcontainer-control-manifest.json
        run: |
          cd _data
          oras pull ghcr.io/devcontainers/control-manifest:latest
          cp devcontainer-control-manifest.json ../static/

      - name: Fetch devcontainer-index.json
        run: |
          cd _data
          oras pull ghcr.io/devcontainers/index:latest
          cp devcontainer-index.json ../static/

      - name: Setup Pages
        uses: actions/configure-pages@v1

      - name: Build with Jekyll
        uses: actions/jekyll-build-pages@v1
        with:
          source: ./
          destination: ./_site

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3

  # Deployment job
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4


