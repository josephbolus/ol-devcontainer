Directory structure:
â””â”€â”€ devcontainers-features/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ CODEOWNERS
    â”œâ”€â”€ CONTRIBUTING.md
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ anaconda/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ aws-cli/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â”œâ”€â”€ NOTES.md
    â”‚   â”‚   â””â”€â”€ scripts/
    â”‚   â”‚       â””â”€â”€ fetch-latest-completer-scripts.sh
    â”‚   â”œâ”€â”€ azure-cli/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ common-utils/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â”œâ”€â”€ main.sh
    â”‚   â”‚   â”œâ”€â”€ NOTES.md
    â”‚   â”‚   â””â”€â”€ scripts/
    â”‚   â”‚       â”œâ”€â”€ bash_theme_snippet.sh
    â”‚   â”‚       â”œâ”€â”€ devcontainers.zsh-theme
    â”‚   â”‚       â””â”€â”€ rc_snippet.sh
    â”‚   â”œâ”€â”€ conda/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ desktop-lite/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ docker-in-docker/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ docker-outside-of-docker/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ dotnet/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â”œâ”€â”€ NOTES.md
    â”‚   â”‚   â””â”€â”€ scripts/
    â”‚   â”‚       â”œâ”€â”€ dotnet-helpers.sh
    â”‚   â”‚       â”œâ”€â”€ fetch-latest-dotnet-install.sh
    â”‚   â”‚       â””â”€â”€ string-helpers.sh
    â”‚   â”œâ”€â”€ git/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ git-lfs/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ github-cli/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ go/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ hugo/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ java/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â”œâ”€â”€ NOTES.md
    â”‚   â”‚   â””â”€â”€ wrapper.sh
    â”‚   â”œâ”€â”€ kubectl-helm-minikube/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ nix/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â”œâ”€â”€ nix-entrypoint.sh
    â”‚   â”‚   â”œâ”€â”€ NOTES.md
    â”‚   â”‚   â”œâ”€â”€ post-install-steps.sh
    â”‚   â”‚   â””â”€â”€ utils.sh
    â”‚   â”œâ”€â”€ node/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ nvidia-cuda/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ oryx/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ php/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ powershell/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ python/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ ruby/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ rust/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â”œâ”€â”€ sshd/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
    â”‚   â”‚   â”œâ”€â”€ install.sh
    â”‚   â”‚   â””â”€â”€ NOTES.md
    â”‚   â””â”€â”€ terraform/
    â”‚       â”œâ”€â”€ README.md
    â”‚       â”œâ”€â”€ devcontainer-feature.json
    â”‚       â”œâ”€â”€ install.sh
    â”‚       â””â”€â”€ NOTES.md
    â”œâ”€â”€ test/
    â”‚   â”œâ”€â”€ _global/
    â”‚   â”‚   â”œâ”€â”€ all_the_clis.sh
    â”‚   â”‚   â”œâ”€â”€ node_java_rust.sh
    â”‚   â”‚   â””â”€â”€ scenarios.json
    â”‚   â”œâ”€â”€ anaconda/
    â”‚   â”‚   â”œâ”€â”€ install_anaconda_almalinux8.sh
    â”‚   â”‚   â”œâ”€â”€ install_anaconda_almalinux9.sh
    â”‚   â”‚   â”œâ”€â”€ install_anaconda_bookworm.sh
    â”‚   â”‚   â”œâ”€â”€ install_anaconda_bullseye.sh
    â”‚   â”‚   â”œâ”€â”€ install_anaconda_fedora.sh
    â”‚   â”‚   â”œâ”€â”€ install_anaconda_jammy.sh
    â”‚   â”‚   â”œâ”€â”€ install_anaconda_noble.sh
    â”‚   â”‚   â”œâ”€â”€ install_anaconda_noble_without_user.sh
    â”‚   â”‚   â”œâ”€â”€ install_anaconda_rockylinux8.sh
    â”‚   â”‚   â”œâ”€â”€ install_anaconda_rockylinux9.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ aws-cli/
    â”‚   â”‚   â”œâ”€â”€ checkBashCompletion.sh
    â”‚   â”‚   â”œâ”€â”€ less_installed.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ azure-cli/
    â”‚   â”‚   â”œâ”€â”€ install_bicep.sh
    â”‚   â”‚   â”œâ”€â”€ install_bicep_trixie.sh
    â”‚   â”‚   â”œâ”€â”€ install_extensions.sh
    â”‚   â”‚   â”œâ”€â”€ install_extensions_bookworm.sh
    â”‚   â”‚   â”œâ”€â”€ install_extensions_trixie.sh
    â”‚   â”‚   â”œâ”€â”€ install_using_python_with_python_3_11_bullseye.sh
    â”‚   â”‚   â”œâ”€â”€ install_with_python.sh
    â”‚   â”‚   â”œâ”€â”€ install_with_python_3_12_bookworm.sh
    â”‚   â”‚   â”œâ”€â”€ install_with_python_3_13_trixie.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ common-utils/
    â”‚   â”‚   â”œâ”€â”€ alma-8-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ alma-8.sh
    â”‚   â”‚   â”œâ”€â”€ alma-9-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ alma-9.sh
    â”‚   â”‚   â”œâ”€â”€ alma-minimal-8.sh
    â”‚   â”‚   â”œâ”€â”€ alma-minimal-9.sh
    â”‚   â”‚   â”œâ”€â”€ alpine-3-14.sh
    â”‚   â”‚   â”œâ”€â”€ alpine-3-15.sh
    â”‚   â”‚   â”œâ”€â”€ alpine-3-18.sh
    â”‚   â”‚   â”œâ”€â”€ alpine-base-zsh-default.sh
    â”‚   â”‚   â”œâ”€â”€ alpine.sh
    â”‚   â”‚   â”œâ”€â”€ already-run.sh
    â”‚   â”‚   â”œâ”€â”€ alternate-values.sh
    â”‚   â”‚   â”œâ”€â”€ Azure-linux-CU.sh
    â”‚   â”‚   â”œâ”€â”€ bionic.sh
    â”‚   â”‚   â”œâ”€â”€ bookworm.sh
    â”‚   â”‚   â”œâ”€â”€ bullseye.sh
    â”‚   â”‚   â”œâ”€â”€ centos-7.sh
    â”‚   â”‚   â”œâ”€â”€ config-subdirectory.sh
    â”‚   â”‚   â”œâ”€â”€ configure_zsh_as_default_shell.sh
    â”‚   â”‚   â”œâ”€â”€ configure_zsh_no_template_first_step.sh
    â”‚   â”‚   â”œâ”€â”€ configure_zsh_no_template_second_step.sh
    â”‚   â”‚   â”œâ”€â”€ devcontainer-custom-home.sh
    â”‚   â”‚   â”œâ”€â”€ devcontainer-custom-user-default-home.sh
    â”‚   â”‚   â”œâ”€â”€ devcontainer-info.sh
    â”‚   â”‚   â”œâ”€â”€ devcontainer-ruby-zshrc.sh
    â”‚   â”‚   â”œâ”€â”€ fedora.sh
    â”‚   â”‚   â”œâ”€â”€ focal.sh
    â”‚   â”‚   â”œâ”€â”€ jammy.sh
    â”‚   â”‚   â”œâ”€â”€ mariner.sh
    â”‚   â”‚   â”œâ”€â”€ no-terminal-title-by-default.sh
    â”‚   â”‚   â”œâ”€â”€ noble.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-8-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-8.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-9-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-9.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ terminal-title-on-xterm.sh
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â”œâ”€â”€ username-default.sh
    â”‚   â”‚   â”œâ”€â”€ username-detected.sh
    â”‚   â”‚   â”œâ”€â”€ devcontainer-custom-home/
    â”‚   â”‚   â”‚   â””â”€â”€ Dockerfile
    â”‚   â”‚   â”œâ”€â”€ devcontainer-info/
    â”‚   â”‚   â”‚   â”œâ”€â”€ Dockerfile
    â”‚   â”‚   â”‚   â””â”€â”€ meta.env
    â”‚   â”‚   â””â”€â”€ devcontainer-ruby-zshrc/
    â”‚   â”‚       â””â”€â”€ Dockerfile
    â”‚   â”œâ”€â”€ conda/
    â”‚   â”‚   â”œâ”€â”€ install_conda.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ desktop-lite/
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â”œâ”€â”€ test_vnc_resolution_as_container_env_var.sh
    â”‚   â”‚   â”œâ”€â”€ test_vnc_resolution_as_remote_env_var.sh
    â”‚   â”‚   â”œâ”€â”€ test_xtigervnc_novnc_started.sh
    â”‚   â”‚   â”œâ”€â”€ test_xtigervnc_novnc_started_noVNC_old_launch_script.sh
    â”‚   â”‚   â””â”€â”€ test_xtigervnc_novnc_started_trixie.sh
    â”‚   â”œâ”€â”€ docker-in-docker/
    â”‚   â”‚   â”œâ”€â”€ azureDnsAutoDetectionDisabled.sh
    â”‚   â”‚   â”œâ”€â”€ azureDnsAutoDetectionEnabled.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build_2.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build_fallback_buildx.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build_fallback_compose.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build_no_compose.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build_older.sh
    â”‚   â”‚   â”œâ”€â”€ docker_buildx.sh
    â”‚   â”‚   â”œâ”€â”€ docker_compose_v1.sh
    â”‚   â”‚   â”œâ”€â”€ docker_compose_v2.sh
    â”‚   â”‚   â”œâ”€â”€ docker_python_bookworm.sh
    â”‚   â”‚   â”œâ”€â”€ docker_specific_moby_buildx.sh
    â”‚   â”‚   â”œâ”€â”€ docker_with_on_create_command.sh
    â”‚   â”‚   â”œâ”€â”€ dockerDefaultAddressPool.sh
    â”‚   â”‚   â”œâ”€â”€ Dockerfile
    â”‚   â”‚   â”œâ”€â”€ dockerIp6tablesDisabledTest.sh
    â”‚   â”‚   â”œâ”€â”€ install_on_debian_trixie.sh
    â”‚   â”‚   â”œâ”€â”€ pin_docker-ce_version_moby_false.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â””â”€â”€ install_moby_on_debian_trixie.sh -> install_on_debian_trixie.sh
    â”‚   â”œâ”€â”€ docker-outside-of-docker/
    â”‚   â”‚   â”œâ”€â”€ docker_build.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build_compose_fallback.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build_no_buildx.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build_no_compose.sh
    â”‚   â”‚   â”œâ”€â”€ docker_dash_compose_v1.sh
    â”‚   â”‚   â”œâ”€â”€ docker_dash_compose_v2.sh
    â”‚   â”‚   â”œâ”€â”€ docker_init.sh
    â”‚   â”‚   â”œâ”€â”€ docker_install_compose_switch.sh
    â”‚   â”‚   â”œâ”€â”€ docker_not_install_compose_switch.sh
    â”‚   â”‚   â”œâ”€â”€ docker_python_bookworm.sh
    â”‚   â”‚   â”œâ”€â”€ docker_specific_moby_buildx.sh
    â”‚   â”‚   â”œâ”€â”€ Dockerfile
    â”‚   â”‚   â”œâ”€â”€ install_on_debian_trixie.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build_moby.sh -> docker_build.sh
    â”‚   â”‚   â”œâ”€â”€ docker_build_no_buildx_moby.sh -> docker_build_no_buildx.sh
    â”‚   â”‚   â”œâ”€â”€ docker_dash_compose_v1_moby.sh -> docker_dash_compose_v1.sh
    â”‚   â”‚   â”œâ”€â”€ docker_dash_compose_v2_moby.sh -> docker_dash_compose_v2.sh
    â”‚   â”‚   â”œâ”€â”€ docker_init_debian.sh -> docker_init.sh
    â”‚   â”‚   â”œâ”€â”€ docker_init_moby.sh -> docker_init.sh
    â”‚   â”‚   â”œâ”€â”€ docker_init_ubuntu_22.sh -> docker_init.sh
    â”‚   â”‚   â””â”€â”€ install_moby_on_debian_trixie.sh -> install_on_debian_trixie.sh
    â”‚   â”œâ”€â”€ dotnet/
    â”‚   â”‚   â”œâ”€â”€ dotnet_env.sh
    â”‚   â”‚   â”œâ”€â”€ dotnet_helpers.sh
    â”‚   â”‚   â”œâ”€â”€ install_aspnetcore_runtime_only.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_daily.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_exact_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_global_tool.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_latest_when_version_is_empty.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_lts.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_multiple_versions.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_preview.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_runtime_only.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_specific_release.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_specific_release_and_feature_band.sh
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_workloads.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â””â”€â”€ projects/
    â”‚   â”‚       â”œâ”€â”€ multitargeting/
    â”‚   â”‚       â”‚   â”œâ”€â”€ Class1.cs
    â”‚   â”‚       â”‚   â””â”€â”€ example_classlib.csproj
    â”‚   â”‚       â”œâ”€â”€ net10.0/
    â”‚   â”‚       â”‚   â”œâ”€â”€ example_project.csproj
    â”‚   â”‚       â”‚   â””â”€â”€ Program.cs
    â”‚   â”‚       â”œâ”€â”€ net5.0/
    â”‚   â”‚       â”‚   â”œâ”€â”€ example_project.csproj
    â”‚   â”‚       â”‚   â””â”€â”€ Program.cs
    â”‚   â”‚       â”œâ”€â”€ net6.0/
    â”‚   â”‚       â”‚   â”œâ”€â”€ example_project.csproj
    â”‚   â”‚       â”‚   â””â”€â”€ Program.cs
    â”‚   â”‚       â”œâ”€â”€ net7.0/
    â”‚   â”‚       â”‚   â”œâ”€â”€ example_project.csproj
    â”‚   â”‚       â”‚   â””â”€â”€ Program.cs
    â”‚   â”‚       â”œâ”€â”€ net8.0/
    â”‚   â”‚       â”‚   â”œâ”€â”€ example_project.csproj
    â”‚   â”‚       â”‚   â””â”€â”€ Program.cs
    â”‚   â”‚       â”œâ”€â”€ net9.0/
    â”‚   â”‚       â”‚   â”œâ”€â”€ example_project.csproj
    â”‚   â”‚       â”‚   â””â”€â”€ Program.cs
    â”‚   â”‚       â””â”€â”€ netcoreapp3.1/
    â”‚   â”‚           â”œâ”€â”€ example_project.csproj
    â”‚   â”‚           â””â”€â”€ Program.cs
    â”‚   â”œâ”€â”€ git/
    â”‚   â”‚   â”œâ”€â”€ install_git_from_ppa_bionic.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_ppa_jammy.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_alma-8.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_alma-9.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_alpine.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_bionic.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_bullseye.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_buster.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_centos-7.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_fedora.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_jammy.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_mariner.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_noble.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_rocky-8.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_src_rocky-9.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_system_alma-8.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_system_alma-9.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_system_alpine.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_system_centos-7.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_system_fedora.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_system_mariner.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_system_rocky-8.sh
    â”‚   â”‚   â”œâ”€â”€ install_git_from_system_rocky-9.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ git-lfs/
    â”‚   â”‚   â”œâ”€â”€ autoPullDisabled.sh
    â”‚   â”‚   â”œâ”€â”€ autoPullEnabled.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â””â”€â”€ use_github.sh
    â”‚   â”œâ”€â”€ github-cli/
    â”‚   â”‚   â”œâ”€â”€ install_git_cli_from_release.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ go/
    â”‚   â”‚   â”œâ”€â”€ install_go_alma-8-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ install_go_alma-8.sh
    â”‚   â”‚   â”œâ”€â”€ install_go_alma-9-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ install_go_alma-9.sh
    â”‚   â”‚   â”œâ”€â”€ install_go_centos-7.sh
    â”‚   â”‚   â”œâ”€â”€ install_go_fedora.sh
    â”‚   â”‚   â”œâ”€â”€ install_go_mariner.sh
    â”‚   â”‚   â”œâ”€â”€ install_go_tool_in_postCreate.sh
    â”‚   â”‚   â”œâ”€â”€ install_go_tool_in_postCreate_rhel.sh
    â”‚   â”‚   â”œâ”€â”€ install_go_twice.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ hugo/
    â”‚   â”‚   â”œâ”€â”€ install_hugo_extended.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ java/
    â”‚   â”‚   â”œâ”€â”€ alma-8-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ alma-8.sh
    â”‚   â”‚   â”œâ”€â”€ alma-9-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ alma-9.sh
    â”‚   â”‚   â”œâ”€â”€ centos-7.sh
    â”‚   â”‚   â”œâ”€â”€ fedora.sh
    â”‚   â”‚   â”œâ”€â”€ install_additional_java.sh
    â”‚   â”‚   â”œâ”€â”€ install_additional_java_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_ant_and_gradle_and_maven_and_groovy.sh
    â”‚   â”‚   â”œâ”€â”€ install_ant_and_gradle_and_maven_and_groovy_for_user.sh
    â”‚   â”‚   â”œâ”€â”€ install_ant_and_gradle_and_maven_and_groovy_for_user_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_ant_and_gradle_and_maven_and_groovy_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_ant_and_gradle_and_maven_and_groovy_with_specific_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_ant_and_gradle_and_maven_and_groovy_with_specific_version_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_from_non_default_distro.sh
    â”‚   â”‚   â”œâ”€â”€ install_from_non_default_distro_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_latest_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_lts_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_non_conventional_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_non_conventional_version_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ mariner.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-8-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-8.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-9-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-9.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ kubectl-helm-minikube/
    â”‚   â”‚   â”œâ”€â”€ checkBashCompletion.sh
    â”‚   â”‚   â”œâ”€â”€ install_kubectl_with_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_kubectl_without_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_only_helm_fallback.sh
    â”‚   â”‚   â”œâ”€â”€ install_only_kubectl.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ nix/
    â”‚   â”‚   â”œâ”€â”€ extra-config.sh
    â”‚   â”‚   â”œâ”€â”€ flake.sh
    â”‚   â”‚   â”œâ”€â”€ multi-user-install.sh
    â”‚   â”‚   â”œâ”€â”€ os-alpine.sh
    â”‚   â”‚   â”œâ”€â”€ os-debian.sh
    â”‚   â”‚   â”œâ”€â”€ os-fedora.sh
    â”‚   â”‚   â”œâ”€â”€ os-rockylinux.sh
    â”‚   â”‚   â”œâ”€â”€ os-ubuntu.sh
    â”‚   â”‚   â”œâ”€â”€ packages-use-attr-path.sh
    â”‚   â”‚   â”œâ”€â”€ packages.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ single-user-install.sh
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â””â”€â”€ version.sh
    â”‚   â”œâ”€â”€ node/
    â”‚   â”‚   â”œâ”€â”€ alma-8-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ alma-8.sh
    â”‚   â”‚   â”œâ”€â”€ alma-9-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ alma-9.sh
    â”‚   â”‚   â”œâ”€â”€ centos-7.sh
    â”‚   â”‚   â”œâ”€â”€ debian_yarn_from_corepack.sh
    â”‚   â”‚   â”œâ”€â”€ fedora.sh
    â”‚   â”‚   â”œâ”€â”€ install_additional_node.sh
    â”‚   â”‚   â”œâ”€â”€ install_additional_node_on_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_node_16_on_bionic.sh
    â”‚   â”‚   â”œâ”€â”€ install_node_22_on_jammy.sh
    â”‚   â”‚   â”œâ”€â”€ install_node_on_universal_image.sh
    â”‚   â”‚   â”œâ”€â”€ install_nvm_0.39.sh
    â”‚   â”‚   â”œâ”€â”€ install_nvm_0.39_on_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ mariner.sh
    â”‚   â”‚   â”œâ”€â”€ non_root_user.sh
    â”‚   â”‚   â”œâ”€â”€ nvm_test_fallback.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-8-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-8.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-9-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ rocky-9.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â”œâ”€â”€ version_none.sh
    â”‚   â”‚   â”œâ”€â”€ version_none_on_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ zsh_default.sh
    â”‚   â”‚   â””â”€â”€ zsh_default_on_rhel_family.sh
    â”‚   â”œâ”€â”€ nvidia-cuda/
    â”‚   â”‚   â”œâ”€â”€ install_all_options.sh
    â”‚   â”‚   â”œâ”€â”€ install_cuda_12_3_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_cuda_12_4_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_cuda_12_5_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_cudnn_nvxt_version.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ oryx/
    â”‚   â”‚   â”œâ”€â”€ install_dotnet_and_oryx.sh
    â”‚   â”‚   â”œâ”€â”€ install_older_dotnet_and_oryx.sh
    â”‚   â”‚   â”œâ”€â”€ install_prev_dotnet_and_oryx.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â”œâ”€â”€ test_python_project.sh
    â”‚   â”‚   â””â”€â”€ sample-python/
    â”‚   â”‚       â”œâ”€â”€ requirements.txt
    â”‚   â”‚       â””â”€â”€ src/
    â”‚   â”‚           â””â”€â”€ solve.py
    â”‚   â”œâ”€â”€ php/
    â”‚   â”‚   â”œâ”€â”€ install_additional_php.sh
    â”‚   â”‚   â”œâ”€â”€ install_only_composer.sh
    â”‚   â”‚   â”œâ”€â”€ install_php_8.sh
    â”‚   â”‚   â”œâ”€â”€ install_php_8_2.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â””â”€â”€ test_php_fallback.sh
    â”‚   â”œâ”€â”€ powershell/
    â”‚   â”‚   â”œâ”€â”€ install_modules.sh
    â”‚   â”‚   â”œâ”€â”€ install_modules_version.sh
    â”‚   â”‚   â”œâ”€â”€ install_powershell_fallback_test.sh
    â”‚   â”‚   â”œâ”€â”€ powershell_alma_linux.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â””â”€â”€ validate_powershell_installation.sh
    â”‚   â”œâ”€â”€ python/
    â”‚   â”‚   â”œâ”€â”€ alma-8-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ alma-8.sh
    â”‚   â”‚   â”œâ”€â”€ alma-9-minimal.sh
    â”‚   â”‚   â”œâ”€â”€ alma-9.sh
    â”‚   â”‚   â”œâ”€â”€ alternatives_switchable_versions.sh
    â”‚   â”‚   â”œâ”€â”€ centos-7.sh
    â”‚   â”‚   â”œâ”€â”€ fedora.sh
    â”‚   â”‚   â”œâ”€â”€ install_additional_jupyterlab.sh
    â”‚   â”‚   â”œâ”€â”€ install_additional_jupyterlab_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_additional_python.sh
    â”‚   â”‚   â”œâ”€â”€ install_additional_python_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_alternate_tools.sh
    â”‚   â”‚   â”œâ”€â”€ install_alternate_tools_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_cpython_fallback_prev_version_test.sh
    â”‚   â”‚   â”œâ”€â”€ install_jupyterlab.sh
    â”‚   â”‚   â”œâ”€â”€ install_jupyterlab_debian.sh
    â”‚   â”‚   â”œâ”€â”€ install_jupyterlab_existing_sudoers_file.sh
    â”‚   â”‚   â”œâ”€â”€ install_jupyterlab_from_python_image.sh
    â”‚   â”‚   â”œâ”€â”€ install_jupyterlab_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_jupyterlab_ubuntu.sh
    â”‚   â”‚   â”œâ”€â”€ install_os_provided_python_deb.sh
    â”‚   â”‚   â”œâ”€â”€ install_os_provided_python_mariner.sh
    â”‚   â”‚   â”œâ”€â”€ install_os_provided_python_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_python310_setuptools_vulnerability.sh
    â”‚   â”‚   â”œâ”€â”€ install_python310_skipVulnerabilityPatching_true.sh
    â”‚   â”‚   â”œâ”€â”€ install_python311_setuptools_vulnerability.sh
    â”‚   â”‚   â”œâ”€â”€ install_python_3_12.sh
    â”‚   â”‚   â”œâ”€â”€ install_python_shared_lib_deb.sh
    â”‚   â”‚   â”œâ”€â”€ install_python_shared_lib_rhel_family.sh
    â”‚   â”‚   â”œâ”€â”€ install_via_oryx.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â””â”€â”€ update_alternatives_switchable_versions.sh
    â”‚   â”œâ”€â”€ ruby/
    â”‚   â”‚   â”œâ”€â”€ install_additional_ruby.sh
    â”‚   â”‚   â”œâ”€â”€ install_additional_ruby_trixie.sh
    â”‚   â”‚   â”œâ”€â”€ install_ruby_trixie_base.sh
    â”‚   â”‚   â”œâ”€â”€ ruby_debian.sh
    â”‚   â”‚   â”œâ”€â”€ ruby_fallback_test.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ test.sh
    â”‚   â”‚   â””â”€â”€ install_ruby_trixie_base/
    â”‚   â”‚       â””â”€â”€ Dockerfile
    â”‚   â”œâ”€â”€ rust/
    â”‚   â”‚   â”œâ”€â”€ rust_at_pinned_version.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_almalinux_8.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_almalinux_9.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_centos.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_custom_components.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_default_components.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_empty_components.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_extended_components.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_fedora.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_mariner.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_minimal_components.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_rockylinux_8.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_rockylinux_9.sh
    â”‚   â”‚   â”œâ”€â”€ rust_with_target.sh
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â”œâ”€â”€ sshd/
    â”‚   â”‚   â”œâ”€â”€ scenarios.json
    â”‚   â”‚   â”œâ”€â”€ sshd_with_default_gateway_ports.sh
    â”‚   â”‚   â”œâ”€â”€ sshd_with_pinned_gateway_ports_clientspecified.sh
    â”‚   â”‚   â””â”€â”€ test.sh
    â”‚   â””â”€â”€ terraform/
    â”‚       â”œâ”€â”€ custom_download_server.sh
    â”‚       â”œâ”€â”€ custom_download_server_with_sentinel.sh
    â”‚       â”œâ”€â”€ install_in_ubuntu_noble.sh
    â”‚       â”œâ”€â”€ install_in_ubuntu_noble_sentinel.sh
    â”‚       â”œâ”€â”€ install_in_ubuntu_trixie.sh
    â”‚       â”œâ”€â”€ install_in_ubuntu_trixie_sentinel.sh
    â”‚       â”œâ”€â”€ install_sentinel.sh
    â”‚       â”œâ”€â”€ install_terraform_docs.sh
    â”‚       â”œâ”€â”€ install_tfsec.sh
    â”‚       â”œâ”€â”€ older_tflint.sh
    â”‚       â”œâ”€â”€ scenarios.json
    â”‚       â”œâ”€â”€ terraform_docs_fallback_test.sh
    â”‚       â”œâ”€â”€ terraform_fallback_test.sh
    â”‚       â”œâ”€â”€ terragrunt_fallback_test.sh
    â”‚       â”œâ”€â”€ test.sh
    â”‚       â”œâ”€â”€ tflint_fallback_test.sh
    â”‚       â””â”€â”€ tfsec_fallback_test.sh
    â”œâ”€â”€ .devcontainer/
    â”‚   â””â”€â”€ devcontainer.json
    â””â”€â”€ .github/
        â””â”€â”€ workflows/
            â”œâ”€â”€ docker-in-docker-stress-test.yaml
            â”œâ”€â”€ linter-automated.yaml
            â”œâ”€â”€ linter-manual.yaml
            â”œâ”€â”€ release.yaml
            â”œâ”€â”€ test-all.yaml
            â”œâ”€â”€ test-manual.yaml
            â”œâ”€â”€ test-pr.yaml
            â”œâ”€â”€ update-aws-cli-completer-scripts.yml
            â”œâ”€â”€ update-documentation.yml
            â”œâ”€â”€ update-dotnet-install-script.yml
            â””â”€â”€ validate-metadata-files.yml

================================================
FILE: README.md
================================================
# Development Container Features

<table style="width: 100%; border-style: none;"><tr>
<td style="width: 140px; text-align: center;"><a href="https://github.com/devcontainers"><img width="128px" src="https://raw.githubusercontent.com/microsoft/fluentui-system-icons/78c9587b995299d5bfc007a0077773556ecb0994/assets/Cube/SVG/ic_fluent_cube_32_filled.svg" alt="devcontainers organization logo"/></a></td>
<td>
<strong>Development Container 'Features'</strong><br />
<i>A set of simple and reusable Features. Quickly add a language/tool/CLI to a development container.
</td>
</tr></table>

'Features' are self-contained units of installation code and development container configuration. Features are designed
to install atop a wide-range of base container images.

Missing a CLI or language in your otherwise _perfect_ container image? Add the relevant Feature to the `features`
property of a [`devcontainer.json`](https://containers.dev/implementors/json_reference/#general-properties). A
[tool supporting the dev container specification](https://containers.dev/supporting) is required to build a development
container.

You may learn about Features at [containers.dev](https://containers.dev/implementors/features/), which is the website for the dev container specification.

## Usage

To reference a Feature from this repository, add the desired Features to a `devcontainer.json`. Each Feature has a `README.md` that shows how to reference the Feature and which options are available for that Feature.

The example below installs the `go` and `docker-in-docker` declared in the [`./src`](./src) directory of this
repository.

See the relevant Feature's README for supported options.

```jsonc
"name": "my-project-devcontainer",
"image": "mcr.microsoft.com/devcontainers/base:ubuntu",  // Any generic, debian-based image.
"features": {
    "ghcr.io/devcontainers/features/go:1": {
        "version": "1.18"
    },
    "ghcr.io/devcontainers/features/docker-in-docker:1": {
        "version": "latest",
        "moby": true
    }
}
```

The `:latest` version annotation is added implicitly if omitted. To pin to a specific package version
([example](https://github.com/devcontainers/features/pkgs/container/features/go/versions)), append it to the end of the
Feature. Features follow semantic versioning conventions, so you can pin to a major version `:1`, minor version `:1.0`, or patch version `:1.0.0` by specifying the appropriate label.

```jsonc
"features": {
    "ghcr.io/devcontainers/features/go:1.0.0": {
        "version": "1.18"
    }
}
```

The [devcontainer CLI reference implementation](https://github.com/devcontainers/cli) (or a
[supporting tool](https://containers.dev/supporting)) can be used to build a project's dev container declaring
Features.

```bash
git clone <my-project-with-devcontainer>
devcontainer build --workspace-folder <path-to-my-project-with-devcontainer>
```

## Repo Structure

```
.
â”œâ”€â”€ README.md
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ dotnet
â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
â”‚   â”‚   â””â”€â”€ install.sh
â”‚   â”œâ”€â”€ go
â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
â”‚   â”‚   â””â”€â”€ install.sh
|   â”œâ”€â”€ ...
â”‚   â”‚   â”œâ”€â”€ devcontainer-feature.json
â”‚   â”‚   â””â”€â”€ install.sh
â”œâ”€â”€ test
â”‚   â”œâ”€â”€ dotnet
â”‚   â”‚   â””â”€â”€ test.sh
â”‚   â”œâ”€â”€ go
|   |   â”œâ”€â”€ scenarios.json
|   |   â”œâ”€â”€ test_scenario_1.json
â”‚   |   â””â”€â”€ test.sh
|   â”œâ”€â”€ ...
â”‚   â”‚   â””â”€â”€ test.sh
...
```

-   [`src`](src) - A collection of subfolders, each declaring a Feature. Each subfolder contains at least a
    `devcontainer-feature.json` and an `install.sh` script.
-   [`test`](test) - Mirroring `src`, a folder-per-feature with at least a `test.sh` script. The
    [`devcontainer` CLI](https://github.com/devcontainers/cli) will execute
    [these tests in CI](https://github.com/devcontainers/features/blob/main/.github/workflows/test-all.yaml).

## Contributions

### Creating your own collection of Features

The [Feature distribution specification](https://containers.dev/implementors/features-distribution/) outlines a pattern for community members and organizations to self-author Features in repositories they control.

A template repo [`devcontainers/feature-template`](https://github.com/devcontainers/feature-template) and [GitHub Action](https://github.com/devcontainers/action) are available to help bootstrap self-authored Features.

We are eager to hear your feedback on self-authoring!  Please provide comments and feedback on [spec issue #70](https://github.com/devcontainers/spec/issues/70).

### Contributing to this repository

This repository will accept improvement and bug fix contributions related to the
[current set of maintained Features](./src).

ğŸ¤ You can read more about how to contribute in [`CONTRIBUTING.md`]. â¤ï¸

[`CONTRIBUTING.md`]: CONTRIBUTING.md



================================================
FILE: CODEOWNERS
================================================
* @devcontainers/maintainers



================================================
FILE: CONTRIBUTING.md
================================================
**Thanks for taking the time to contribute! â¤ï¸**

All types of contributions are encouraged and valued, no matter if it's a bug
report ğŸ›, a feature request ğŸ’¡, or a Pull Request ğŸš€.

- **â“ I have a question:** Ask in [our dev container community Slack channel]
- **ğŸ› I found a bug:** [Open an Issue]
- **ğŸ’¡ I have an idea:** [Open an Issue]
- **ğŸ’» I want to code:** See below

If you like the project, but just don't have time to contribute, that's OK too!
You can also star the project â­, rave about it online ğŸ’¬, or add a link to us
ğŸ”— in your project's readme.

âš ï¸ You must never report security ğŸ”’ related issues, vulnerabilities or bugs
including sensitive information to the issue tracker, or elsewhere in public.
Instead, please [report them to the Microsoft Security Response Center]. You can
read more about our security policy in [`SECURITY.md`].

## Contributing code

ğŸ‘¨â€ğŸ’¼ This repository is a collection of dev container Features managed by dev
container spec maintainers. This repository will **only accept improvements and
bug fixes** for the [current set of maintained Features].

ğŸš€ If you're looking to create a new Feature, then we encourage adding it to a
separate repository of your control. The [devcontainers/feature-starter]
repository has more guidance on self authoring Features.

ğŸ’¡ Once you've self authored the Features and if you'd like to share them with
the community, then we'd recommend [adding it to the index].

ğŸ‘·â€ If you've identified an issue and you want to fix it, here's how you can get
started:

1. ğŸ”€ Fork the repo
2. ğŸ’» Open the repo in your editor
3. ğŸ‘¨â€ğŸ’» Add your changes to your workspace
4. âœ¨ [Test your changes using `devcontainer features test`] to make sure
   everything still works
5. ğŸ†š Bump the version of the feature you changed according to [semver]
6. ğŸ”– Commit & push your changes
7. ğŸ” Open a PR to get your changes merged
8. ğŸš€ Profit!

ğŸ‘©â€âš–ï¸ When contributing code to this project, you may be asked to agree to our
[Contributor License Agreement].

<!-- prettier-ignore-start -->
[our dev container community Slack channel]: https://aka.ms/devcontainer_community
[open an issue]: https://github.com/devcontainers/features/issues/new
[current set of maintained Features]: https://github.com/devcontainers/features/tree/main/src
[devcontainers/feature-starter]: https://github.com/devcontainers/feature-starter#readme
[adding it to the index]: https://github.com/devcontainers/feature-starter#adding-features-to-the-index
[report them to the Microsoft Security Response Center]: https://msrc.microsoft.com/create-report
[`SECURITY.md`]: https://github.com/devcontainers/spec/blob/main/SECURITY.md
[contributor license agreement]: https://opensource.microsoft.com/cla/
[Test your changes using `devcontainer features test`]: https://github.com/devcontainers/cli/blob/main/docs/features/test.md
[semver]: https://semver.org/
<!-- prettier-ignore-end -->



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2022 Microsoft Corporation.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/anaconda/README.md
================================================

# Anaconda (anaconda)



## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/anaconda:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter an anaconda version. | string | latest |

## Using Conda

This Feature includes [the `conda` package manager](https://docs.conda.io/projects/conda/en/latest/index.html). Additional packages installed using Conda will be downloaded from Anaconda or another repository if you configure one. To reconfigure Conda in this container to access an alternative repository, please see information on [configuring Conda channels here](https://docs.conda.io/projects/conda/en/latest/user-guide/concepts/channels.html ).

Access to the Anaconda repository is covered by the [Anaconda Terms of Service](https://legal.anaconda.com/policies/en/?name=terms-of-service), which may require some organizations to obtain a commercial license from Anaconda. **However**, when used with GitHub Codespaces or GitHub Actions, **all users are permitted** to use the Anaconda Repository through the service, including organizations normally required by Anaconda to obtain a paid license for commercial activities. Note that third-party packages may be licensed by their publishers in ways that impact your intellectual property, and are used at your own risk.

## Installing a different version of Python

As covered in the [user FAQ](https://docs.anaconda.com/anaconda/user-guide/faq) for Anaconda, you can install different versions of Python than the one in this image by running the following from a terminal:

```bash
conda install python=3.7
```


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.
Also RHEL based linux distributions such as almalinux, rockylinux, fedora are supported now.
`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/anaconda/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/anaconda/devcontainer-feature.json
================================================
{
    "id": "anaconda",
    "version": "1.1.0",
    "name": "Anaconda",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/anaconda",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest"
            ],
            "default": "latest",
            "description": "Select or enter an anaconda version."
        }
    },
    "containerEnv": {
        "CONDA_DIR": "/usr/local/conda",
        "PATH": "/usr/local/conda/bin:${PATH}"
    },
    "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes Anaconda and the conda package manager pre-installed and available on the `PATH` for data science and Python development. Additional packages installed using Conda will be downloaded from Anaconda or another repository configured by the user. A user can install different versions of Python than the one in this dev container by running a command like: conda install python=3.7"
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/anaconda/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/anaconda.md
# Maintainer: The VS Code and Codespaces Teams


VERSION="${VERSION:-"latest"}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="${UPDATE_RC:-"true"}"
CONDA_DIR="${CONDA_DIR:-"/usr/local/conda"}"

set -euo pipefail
export DEBIAN_FRONTEND=noninteractive

# Detect package manager and set install command
detect_package_manager() {
    if command -v apt-get > /dev/null; then
        PKG_MANAGER="apt-get"
        PKG_UPDATE="apt-get update -y"
        PKG_INSTALL="apt-get -y install --no-install-recommends"
        PKG_CLEAN="apt-get -y clean"
        PKG_LISTS="/var/lib/apt/lists/*"
        PKG_QUERY="dpkg -s"
    elif command -v apk > /dev/null; then
        PKG_MANAGER="apk"
        PKG_UPDATE="apk update"
        PKG_INSTALL="apk add --no-cache"
        PKG_CLEAN="rm -rf /var/cache/apk/*"
        PKG_LISTS="/var/cache/apk/*"
        PKG_QUERY="apk info -e"
    elif command -v dnf > /dev/null; then
        PKG_MANAGER="dnf"
        PKG_UPDATE="dnf -y makecache"
        PKG_INSTALL="dnf -y install"
        PKG_CLEAN="dnf clean all"
        PKG_LISTS="/var/cache/dnf/*"
        PKG_QUERY="rpm -q"
    elif command -v microdnf > /dev/null; then
        PKG_MANAGER="microdnf"
        PKG_UPDATE="microdnf update"
        PKG_INSTALL="microdnf install -y"
        PKG_CLEAN="microdnf clean all"
        PKG_LISTS="/var/cache/yum/*"
        PKG_QUERY="rpm -q"
    elif command -v tdnf > /dev/null; then
        PKG_MANAGER="tdnf"
        PKG_UPDATE="tdnf makecache"
        PKG_INSTALL="tdnf install -y"
        PKG_CLEAN="tdnf clean all"
        PKG_LISTS="/var/cache/tdnf/*"
        PKG_QUERY="rpm -q"
    elif command -v yum > /dev/null; then
        PKG_MANAGER="yum"
        PKG_UPDATE="yum -y makecache"
        PKG_INSTALL="yum -y install"
        PKG_CLEAN="yum clean all"
        PKG_LISTS="/var/cache/yum/*"
        PKG_QUERY="rpm -q"
    else
        echo "No supported package manager found (apt-get, apk, dnf, microdnf, tdnf, yum)."
        exit 1
    fi
}

detect_package_manager

# Clean up
eval "$PKG_CLEAN"

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u "${CURRENT_USER}" > /dev/null 2>&1; then
            USERNAME="${CURRENT_USER}"
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

architecture="$(uname -m)"
# Normalize arm64 to aarch64 for consistency
if [ "${architecture}" = "arm64" ]; then
    architecture="aarch64"
fi

if [ "${architecture}" != "x86_64" ] && [ "${architecture}" != "aarch64" ]; then
    echo "(!) Architecture $architecture unsupported"
    exit 1
fi

updaterc() {
    if [ "${UPDATE_RC}" = "true" ]; then
        echo "Updating /etc/bash.bashrc and /etc/zsh/zshrc..."
        if [[ "$(cat /etc/bash.bashrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/bash.bashrc
        fi
        if [ -f "/etc/zsh/zshrc" ] && [[ "$(cat /etc/zsh/zshrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/zsh/zshrc
        fi
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    for pkg in "$@"; do
        # Use PKG_QUERY variable to check if package is installed
        if ! eval "$PKG_QUERY $pkg" > /dev/null 2>&1; then
            # Package not installed, check if we need to update package lists
            if [ "$PKG_MANAGER" = "apt-get" ]; then
                # For apt-get, check if package lists are empty
                if [ "$(find "$PKG_LISTS" | wc -l)" = "0" ]; then
                    echo "Running $PKG_UPDATE..."
                    eval "$PKG_UPDATE"
                fi
            else
                # For other package managers, always update before installing
                echo "Running $PKG_UPDATE..."
                eval "$PKG_UPDATE"
            fi
            
            # Install the package
            echo "Installing package: $pkg"
            eval "$PKG_INSTALL $pkg"
        else
            echo "Package $pkg is already installed"
        fi
    done
}

sudo_if() {
    COMMAND="$*"
    if [ "$(id -u)" -eq 0 ] && [ "$USERNAME" != "root" ]; then
        if command -v runuser > /dev/null; then
            runuser -l "$USERNAME" -c "$COMMAND"
        elif command -v su > /dev/null; then
            su - "$USERNAME" -c "$COMMAND"
        elif command -v sudo > /dev/null; then
            sudo -u "$USERNAME" -i bash -c "$COMMAND"
        else
            # Fallback: execute as root (not ideal but works in containers)
            echo "Warning: No user switching command available, running as root"
            eval "$COMMAND"
        fi
    else
        eval "$COMMAND"
    fi
}

run_as_user() {
    local user="$1"
    shift
    local cmd="$*"
    
    if command -v runuser > /dev/null; then
        if [ "$PKG_MANAGER" = "apk" ]; then
            runuser "$user" -c "$cmd"
        else
            runuser -l "$user" -c "$cmd"
        fi
    elif command -v su > /dev/null; then
        if [ "$PKG_MANAGER" = "apk" ]; then
            su "$user" -c "$cmd"
        else
            su --login -c "$cmd" "$user"
        fi
    elif command -v sudo > /dev/null; then
        if [ "$PKG_MANAGER" = "apk" ]; then
            sudo -u "$user" sh -c "$cmd"
        else
            sudo -u "$user" -i bash -c "$cmd"
        fi
    else
        echo "Warning: No user switching command available, running as root"
        eval "$cmd"
    fi
}

# Install Conda if it's missing
if ! conda --version &> /dev/null ; then
    if ! cat /etc/group | grep -e "^conda:" > /dev/null 2>&1; then
        groupadd -r conda
    fi
    usermod -a -G conda "${USERNAME}"

    # Install dependencies
    if [ "$PKG_MANAGER" = "apt-get" ]; then
        check_packages wget ca-certificates libgtk-3-0
    elif [ "$PKG_MANAGER" = "apk" ]; then
        check_packages wget ca-certificates gtk+3.0
    else
        check_packages wget ca-certificates gtk3
    fi

    mkdir -p $CONDA_DIR

    chown -R "${USERNAME}:conda" "${CONDA_DIR}"
    chmod -R g+r+w "${CONDA_DIR}"    

    echo "Installing Anaconda..."

    CONDA_VERSION=$VERSION
    if [ "${VERSION}" = "latest" ] || [ "${VERSION}" = "lts" ]; then
        CONDA_VERSION="2024.10-1"
    fi

    if [ "${architecture}" = "x86_64" ]; then
        run_as_user "${USERNAME}" "export http_proxy=${http_proxy:-} && export https_proxy=${https_proxy:-} \
            && wget -q https://repo.anaconda.com/archive/Anaconda3-${CONDA_VERSION}-Linux-x86_64.sh -O /tmp/anaconda-install.sh \
            && /bin/bash /tmp/anaconda-install.sh -u -b -p ${CONDA_DIR}"
    elif [ "${architecture}" = "aarch64" ]; then
        run_as_user "${USERNAME}" "export http_proxy=${http_proxy:-} && export https_proxy=${https_proxy:-} \
            && wget -q https://repo.anaconda.com/archive/Anaconda3-${CONDA_VERSION}-Linux-aarch64.sh -O /tmp/anaconda-install.sh \
            && /bin/bash /tmp/anaconda-install.sh -u -b -p ${CONDA_DIR}"
    fi
    
    if [ "${VERSION}" = "latest" ] || [ "${VERSION}" = "lts" ]; then
        PATH=$PATH:${CONDA_DIR}/bin
        conda update -y conda
    fi

    chown -R "${USERNAME}:conda" "${CONDA_DIR}"
    chmod -R g+r+w "${CONDA_DIR}"


    rm /tmp/anaconda-install.sh
    updaterc "export CONDA_DIR=${CONDA_DIR}/bin"
fi

# Display a notice on conda when not running in GitHub Codespaces
mkdir -p /usr/local/etc/vscode-dev-containers
cat << 'EOF' > /usr/local/etc/vscode-dev-containers/conda-notice.txt
When using "conda" from outside of GitHub Codespaces, note the Anaconda repository contains
restrictions on commercial use that may impact certain organizations. See https://aka.ms/ghcs-conda

EOF

notice_script="$(cat << 'EOF'
if [ -t 1 ] && [ "${IGNORE_NOTICE}" != "true" ] && [ "${TERM_PROGRAM}" = "vscode" ] && [ "${CODESPACES}" != "true" ] && [ ! -f "$HOME/.config/vscode-dev-containers/conda-notice-already-displayed" ]; then
    cat "/usr/local/etc/vscode-dev-containers/conda-notice.txt"
    mkdir -p "$HOME/.config/vscode-dev-containers"
    ((sleep 10s; touch "$HOME/.config/vscode-dev-containers/conda-notice-already-displayed") &)
fi
EOF
)"

if [ -f "/etc/zsh/zshrc" ]; then
    echo "${notice_script}" | tee -a /etc/zsh/zshrc
fi

if [ -f "/etc/bash.bashrc" ]; then
    echo "${notice_script}" | tee -a /etc/bash.bashrc
fi

# Final clean up
eval "$PKG_CLEAN"
echo "Done!"



================================================
FILE: src/anaconda/NOTES.md
================================================
## Using Conda

This Feature includes [the `conda` package manager](https://docs.conda.io/projects/conda/en/latest/index.html). Additional packages installed using Conda will be downloaded from Anaconda or another repository if you configure one. To reconfigure Conda in this container to access an alternative repository, please see information on [configuring Conda channels here](https://docs.conda.io/projects/conda/en/latest/user-guide/concepts/channels.html ).

Access to the Anaconda repository is covered by the [Anaconda Terms of Service](https://legal.anaconda.com/policies/en/?name=terms-of-service), which may require some organizations to obtain a commercial license from Anaconda. **However**, when used with GitHub Codespaces or GitHub Actions, **all users are permitted** to use the Anaconda Repository through the service, including organizations normally required by Anaconda to obtain a paid license for commercial activities. Note that third-party packages may be licensed by their publishers in ways that impact your intellectual property, and are used at your own risk.

## Installing a different version of Python

As covered in the [user FAQ](https://docs.anaconda.com/anaconda/user-guide/faq) for Anaconda, you can install different versions of Python than the one in this image by running the following from a terminal:

```bash
conda install python=3.7
```


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

Also RHEL based linux distributions such as almalinux, rockylinux, fedora are supported now.
Please do note that Alpine and cbl-mariner aren't supported due system level restrictions with the anaconda installer.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/aws-cli/README.md
================================================

# AWS CLI (aws-cli)

Installs the AWS CLI along with needed dependencies. Useful for base Dockerfiles that often are missing required install dependencies like gpg.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/aws-cli:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter an AWS CLI version. | string | latest |

## Customizations

### VS Code Extensions

- `AmazonWebServices.aws-toolkit-vscode`

Available versions of the AWS CLI can be found here: https://github.com/aws/aws-cli/blob/v2/CHANGELOG.rst.

## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/aws-cli/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/aws-cli/devcontainer-feature.json
================================================
{
    "id": "aws-cli",
    "version": "1.1.2",
    "name": "AWS CLI",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/aws-cli",
    "description": "Installs the AWS CLI along with needed dependencies. Useful for base Dockerfiles that often are missing required install dependencies like gpg.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest"
            ],
            "default": "latest",
            "description": "Select or enter an AWS CLI version."
        }
    },
    "customizations": {
        "vscode": {
            "extensions": [
                "AmazonWebServices.aws-toolkit-vscode"
            ],
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes the AWS CLI along with needed dependencies pre-installed and available on the `PATH`, along with the AWS Toolkit extensions for AWS development."
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/aws-cli/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/awscli.md
# Maintainer: The VS Code and Codespaces Teams

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

VERSION=${VERSION:-"latest"}

AWSCLI_GPG_KEY=FB5DB77FD5C118B80511ADA8A6310ACC4672475C
AWSCLI_GPG_KEY_MATERIAL="-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBF2Cr7UBEADJZHcgusOJl7ENSyumXh85z0TRV0xJorM2B/JL0kHOyigQluUG
ZMLhENaG0bYatdrKP+3H91lvK050pXwnO/R7fB/FSTouki4ciIx5OuLlnJZIxSzx
PqGl0mkxImLNbGWoi6Lto0LYxqHN2iQtzlwTVmq9733zd3XfcXrZ3+LblHAgEt5G
TfNxEKJ8soPLyWmwDH6HWCnjZ/aIQRBTIQ05uVeEoYxSh6wOai7ss/KveoSNBbYz
gbdzoqI2Y8cgH2nbfgp3DSasaLZEdCSsIsK1u05CinE7k2qZ7KgKAUIcT/cR/grk
C6VwsnDU0OUCideXcQ8WeHutqvgZH1JgKDbznoIzeQHJD238GEu+eKhRHcz8/jeG
94zkcgJOz3KbZGYMiTh277Fvj9zzvZsbMBCedV1BTg3TqgvdX4bdkhf5cH+7NtWO
lrFj6UwAsGukBTAOxC0l/dnSmZhJ7Z1KmEWilro/gOrjtOxqRQutlIqG22TaqoPG
fYVN+en3Zwbt97kcgZDwqbuykNt64oZWc4XKCa3mprEGC3IbJTBFqglXmZ7l9ywG
EEUJYOlb2XrSuPWml39beWdKM8kzr1OjnlOm6+lpTRCBfo0wa9F8YZRhHPAkwKkX
XDeOGpWRj4ohOx0d2GWkyV5xyN14p2tQOCdOODmz80yUTgRpPVQUtOEhXQARAQAB
tCFBV1MgQ0xJIFRlYW0gPGF3cy1jbGlAYW1hem9uLmNvbT6JAlQEEwEIAD4WIQT7
Xbd/1cEYuAURraimMQrMRnJHXAUCXYKvtQIbAwUJB4TOAAULCQgHAgYVCgkICwIE
FgIDAQIeAQIXgAAKCRCmMQrMRnJHXJIXEAChLUIkg80uPUkGjE3jejvQSA1aWuAM
yzy6fdpdlRUz6M6nmsUhOExjVIvibEJpzK5mhuSZ4lb0vJ2ZUPgCv4zs2nBd7BGJ
MxKiWgBReGvTdqZ0SzyYH4PYCJSE732x/Fw9hfnh1dMTXNcrQXzwOmmFNNegG0Ox
au+VnpcR5Kz3smiTrIwZbRudo1ijhCYPQ7t5CMp9kjC6bObvy1hSIg2xNbMAN/Do
ikebAl36uA6Y/Uczjj3GxZW4ZWeFirMidKbtqvUz2y0UFszobjiBSqZZHCreC34B
hw9bFNpuWC/0SrXgohdsc6vK50pDGdV5kM2qo9tMQ/izsAwTh/d/GzZv8H4lV9eO
tEis+EpR497PaxKKh9tJf0N6Q1YLRHof5xePZtOIlS3gfvsH5hXA3HJ9yIxb8T0H
QYmVr3aIUes20i6meI3fuV36VFupwfrTKaL7VXnsrK2fq5cRvyJLNzXucg0WAjPF
RrAGLzY7nP1xeg1a0aeP+pdsqjqlPJom8OCWc1+6DWbg0jsC74WoesAqgBItODMB
rsal1y/q+bPzpsnWjzHV8+1/EtZmSc8ZUGSJOPkfC7hObnfkl18h+1QtKTjZme4d
H17gsBJr+opwJw/Zio2LMjQBOqlm3K1A4zFTh7wBC7He6KPQea1p2XAMgtvATtNe
YLZATHZKTJyiqA==
=vYOk
-----END PGP PUBLIC KEY BLOCK-----"

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

export DEBIAN_FRONTEND=noninteractive

check_packages curl ca-certificates gpg dirmngr unzip bash-completion less

verify_aws_cli_gpg_signature() {
    local filePath=$1
    local sigFilePath=$2
    local awsGpgKeyring=aws-cli-public-key.gpg

    echo "${AWSCLI_GPG_KEY_MATERIAL}" | gpg --dearmor > "./${awsGpgKeyring}"
    gpg --batch --quiet --no-default-keyring --keyring "./${awsGpgKeyring}" --verify "${sigFilePath}" "${filePath}"
    local status=$?

    rm "./${awsGpgKeyring}"

    return ${status}
}

install() {
    local scriptZipFile=awscli.zip
    local scriptSigFile=awscli.sig

    # See Linux install docs at https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html
    if [ "${VERSION}" != "latest" ]; then
        local versionStr=-${VERSION}
    fi
    architecture=$(dpkg --print-architecture)
    case "${architecture}" in
        amd64) architectureStr=x86_64 ;;
        arm64) architectureStr=aarch64 ;;
        *)
            echo "AWS CLI does not support machine architecture '$architecture'. Please use an x86-64 or ARM64 machine."
            exit 1
    esac
    local scriptUrl=https://awscli.amazonaws.com/awscli-exe-linux-${architectureStr}${versionStr}.zip
    curl "${scriptUrl}" -o "${scriptZipFile}"
    curl "${scriptUrl}.sig" -o "${scriptSigFile}"

    verify_aws_cli_gpg_signature "$scriptZipFile" "$scriptSigFile"
    if (( $? > 0 )); then
        echo "Could not verify GPG signature of AWS CLI install script. Make sure you provided a valid version."
        exit 1
    fi

    unzip "${scriptZipFile}"
    ./aws/install

    # kubectl bash completion
    mkdir -p /etc/bash_completion.d
    cp ./scripts/vendor/aws_bash_completer /etc/bash_completion.d/aws

    # kubectl zsh completion
    if [ -e "${USERHOME}/.oh-my-zsh" ]; then
        mkdir -p "${USERHOME}/.oh-my-zsh/completions"
        cp ./scripts/vendor/aws_zsh_completer.sh "${USERHOME}/.oh-my-zsh/completions/_aws"
        chown -R "${USERNAME}" "${USERHOME}/.oh-my-zsh"
    fi

    rm -rf ./aws
}

echo "(*) Installing AWS CLI..."

install

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"



================================================
FILE: src/aws-cli/NOTES.md
================================================
Available versions of the AWS CLI can be found here: https://github.com/aws/aws-cli/blob/v2/CHANGELOG.rst.

## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/aws-cli/scripts/fetch-latest-completer-scripts.sh
================================================
#!/bin/bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/devcontainers/features/tree/main/src/aws-cli
# Maintainer: The Dev Container spec maintainers
#
# Run this script to replace aws_bash_completer and aws_zsh_completer.sh with the latest and greatest available version
# 
COMPLETER_SCRIPTS=$(dirname "${BASH_SOURCE[0]}")
BASH_COMPLETER_SCRIPT="$COMPLETER_SCRIPTS/vendor/aws_bash_completer"
ZSH_COMPLETER_SCRIPT="$COMPLETER_SCRIPTS/vendor/aws_zsh_completer.sh"

wget https://raw.githubusercontent.com/aws/aws-cli/v2/bin/aws_bash_completer -O "$BASH_COMPLETER_SCRIPT"
chmod +x "$BASH_COMPLETER_SCRIPT"

wget https://raw.githubusercontent.com/aws/aws-cli/v2/bin/aws_zsh_completer.sh -O "$ZSH_COMPLETER_SCRIPT"
chmod +x "$ZSH_COMPLETER_SCRIPT"



================================================
FILE: src/azure-cli/README.md
================================================

# Azure CLI (azure-cli)

Installs the Azure CLI along with needed dependencies. Useful for base Dockerfiles that often are missing required install dependencies like gpg.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/azure-cli:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter an Azure CLI version. (Available versions may vary by Linux distribution.) | string | latest |
| extensions | Optional comma separated list of Azure CLI extensions to install in profile. | string | - |
| installBicep | Optionally install Azure Bicep | boolean | false |
| bicepVersion | Select or enter a Bicep version. ('latest' or a specic version such as 'v0.31.92') | string | latest |
| installUsingPython | Install Azure CLI using Python instead of pipx | boolean | false |

## Customizations

### VS Code Extensions

- `ms-vscode.azurecli`



## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/azure-cli/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/azure-cli/devcontainer-feature.json
================================================
{
  "id": "azure-cli",
  "version": "1.2.8",
  "name": "Azure CLI",
  "documentationURL": "https://github.com/devcontainers/features/tree/main/src/azure-cli",
  "description": "Installs the Azure CLI along with needed dependencies. Useful for base Dockerfiles that often are missing required install dependencies like gpg.",
  "options": {
    "version": {
      "type": "string",
      "proposals": [
        "latest"
      ],
      "default": "latest",
      "description": "Select or enter an Azure CLI version. (Available versions may vary by Linux distribution.)"
    },
    "extensions": {
      "type": "string",
      "default": "",
      "description": "Optional comma separated list of Azure CLI extensions to install in profile."
    },
    "installBicep": {
      "type": "boolean",
      "description": "Optionally install Azure Bicep",
      "default": false
    },
    "bicepVersion": {
      "type": "string",
      "proposals": [
        "latest"
      ],
      "default": "latest",
      "description": "Select or enter a Bicep version. ('latest' or a specic version such as 'v0.31.92')"
    },
    "installUsingPython": {
      "type": "boolean",
      "description": "Install Azure CLI using Python instead of pipx",
      "default": false
    }
  },
  "customizations": {
    "vscode": {
      "extensions": [
        "ms-vscode.azurecli"
      ],
      "settings": {
        "github.copilot.chat.codeGeneration.instructions": [
          {
            "text": "This dev container includes the Azure CLI along with needed dependencies pre-installed and available on the `PATH`, along with the Azure CLI extension for Azure development."
          }
        ]
      }
    }
  },
  "installsAfter": [
    "ghcr.io/devcontainers/features/common-utils"
  ]
}


================================================
FILE: src/azure-cli/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/azcli.md
# Maintainer: The VS Code and Codespaces Teams

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

AZ_VERSION=${VERSION:-"latest"}
AZ_EXTENSIONS=${EXTENSIONS}
AZ_INSTALLBICEP=${INSTALLBICEP:-false}
AZ_BICEPVERSION=${BICEPVERSION:-latest}
INSTALL_USING_PYTHON=${INSTALLUSINGPYTHON:-false}
MICROSOFT_GPG_KEYS_URI="https://packages.microsoft.com/keys/microsoft.asc"
AZCLI_ARCHIVE_ARCHITECTURES="amd64 arm64"
AZCLI_ARCHIVE_VERSION_CODENAMES="stretch bookworm buster bullseye bionic focal jammy noble trixie"

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

if [ -z "${_REMOTE_USER}" ]; then
    echo -e 'Feature script must be executed by a tool that implements the dev container specification. See https://containers.dev/ for more information.'
    exit 1
fi

echo "Effective REMOTE_USER: ${_REMOTE_USER}"

apt_get_update()
{
    echo "Running apt-get update..."
    apt-get update -y
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
            echo "Running apt-get update..."
            apt-get update -y
        fi
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Soft version matching that resolves a version for a given package in the *current apt-cache*
# Return value is stored in first argument (the unprocessed version)
apt_cache_version_soft_match() {
    
    # Version
    local variable_name="$1"
    local requested_version=${!variable_name}
    # Package Name
    local package_name="$2"
    # Exit on no match?
    local exit_on_no_match="${3:-true}"

    # Ensure we've exported useful variables
    . /etc/os-release
    local architecture="$(dpkg --print-architecture)"
    
    dot_escaped="${requested_version//./\\.}"
    dot_plus_escaped="${dot_escaped//+/\\+}"
    # Regex needs to handle debian package version number format: https://www.systutorials.com/docs/linux/man/5-deb-version/
    version_regex="^(.+:)?${dot_plus_escaped}([\\.\\+ ~:-]|$)"
    set +e # Don't exit if finding version fails - handle gracefully
        fuzzy_version="$(apt-cache madison ${package_name} | awk -F"|" '{print $2}' | sed -e 's/^[ \t]*//' | grep -E -m 1 "${version_regex}")"
    set -e
    if [ -z "${fuzzy_version}" ]; then
        echo "(!) No full or partial for package \"${package_name}\" match found in apt-cache for \"${requested_version}\" on OS ${ID} ${VERSION_CODENAME} (${architecture})."

        if $exit_on_no_match; then
            echo "Available versions:"
            apt-cache madison ${package_name} | awk -F"|" '{print $2}' | grep -oP '^(.+:)?\K.+'
            exit 1 # Fail entire script
        else
            echo "Continuing to fallback method (if available)"
            return 1;
        fi
    fi

    # Globally assign fuzzy_version to this value
    # Use this value as the return value of this function
    declare -g ${variable_name}="=${fuzzy_version}"
    echo "${variable_name} ${!variable_name}"
}

install_using_apt() {
    # Install dependencies
    check_packages apt-transport-https curl ca-certificates gnupg2 dirmngr
    # Import key safely (new 'signed-by' method rather than deprecated apt-key approach) and install
    curl -sSL ${MICROSOFT_GPG_KEYS_URI} | gpg --dearmor > /usr/share/keyrings/microsoft-archive-keyring.gpg
    echo "deb [arch=${architecture} signed-by=/usr/share/keyrings/microsoft-archive-keyring.gpg] https://packages.microsoft.com/repos/azure-cli/ ${VERSION_CODENAME} main" > /etc/apt/sources.list.d/azure-cli.list
    apt-get update

    if [ "${AZ_VERSION}" = "latest" ] || [ "${AZ_VERSION}" = "lts" ] || [ "${AZ_VERSION}" = "stable" ]; then
        # Empty, meaning grab the "latest" in the apt repo
        AZ_VERSION=""
    else
        # Sets AZ_VERSION to our desired version, if match found.
        apt_cache_version_soft_match AZ_VERSION "azure-cli" false
        if [ "$?" != 0 ]; then
            return 1
        fi
    fi

    if ! (apt-get install -yq azure-cli${AZ_VERSION}); then
        rm -f /etc/apt/sources.list.d/azure-cli.list
        return 1
    fi
}

install_using_pip_strategy() {
    local ver=""
    if [ "${AZ_VERSION}" = "latest" ] || [ "${AZ_VERSION}" = "lts" ] || [ "${AZ_VERSION}" = "stable" ]; then
        # Empty, meaning grab the "latest" in the apt repo
        ver=""
    else
        ver="==${AZ_VERSION}"
    fi

    if [ "${INSTALL_USING_PYTHON}" = "true" ]; then
        install_with_complete_python_installation "${ver}" || install_with_pipx "${ver}" || return 1
    else
        install_with_pipx "${ver}" || install_with_complete_python_installation "${ver}" || return 1
    fi
}

install_with_pipx() {
    echo "(*) Attempting to install globally with pipx..."
    local ver="$1"
    export 
    local 

    if ! type pipx > /dev/null 2>&1; then
        echo "(*) Installing pipx..."
        check_packages pipx
        pipx ensurepath # Ensures PIPX_BIN_DIR is on the PATH
    fi

    PIPX_HOME="/usr/local/pipx" \
    PIPX_BIN_DIR=/usr/local/bin \
    pipx install azure-cli${ver}

    echo "(*) Finished installing globally with pipx."
}

install_with_complete_python_installation() {
    local ver="$1"
    echo "(*) No pre-built binaries available in apt-cache. Installing via pip3."
    if ! dpkg -s python3-minimal python3-pip libffi-dev python3-venv > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install python3-minimal python3-pip libffi-dev python3-venv
    fi
    export PIPX_HOME=/usr/local/pipx
    mkdir -p ${PIPX_HOME}
    export PIPX_BIN_DIR=/usr/local/bin
    export PYTHONUSERBASE=/tmp/pip-tmp
    export PIP_CACHE_DIR=/tmp/pip-tmp/cache
    pipx_bin=pipx
    if ! type pipx > /dev/null 2>&1; then
        pip3 install --disable-pip-version-check --no-cache-dir --user pipx
        pipx_bin=/tmp/pip-tmp/bin/pipx
    fi

    set +e
        ${pipx_bin} install --pip-args '--no-cache-dir --force-reinstall' -f azure-cli${ver}

        # Fail gracefully
        if [ "$?" != 0 ]; then
            echo "Could not install azure-cli${ver} via pip3"
            rm -rf /tmp/pip-tmp
            return 1
        fi
    set -e
}

export DEBIAN_FRONTEND=noninteractive

# See if we're on x86_64 or AARCH64 and if so, install via apt-get, otherwise use pip3
echo "(*) Installing Azure CLI..."
. /etc/os-release
architecture="$(dpkg --print-architecture)"
CACHED_AZURE_VERSION="${AZ_VERSION}" # In case we need to fallback to pip and the apt path has modified the AZ_VERSION variable.
if [ "${INSTALL_USING_PYTHON}" != "true" ]; then
    if [[ "${AZCLI_ARCHIVE_ARCHITECTURES}" = *"${architecture}"* ]] && [[  "${AZCLI_ARCHIVE_VERSION_CODENAMES}" = *"${VERSION_CODENAME}"* ]]; then
        install_using_apt || use_pip="true"
    fi
else
    use_pip="true"
fi

if [ "${use_pip}" = "true" ]; then 
    AZ_VERSION=${CACHED_AZURE_VERSION}
    install_using_pip_strategy

    if [ "$?" != 0 ]; then
        echo "Please provide a valid version for your distribution ${ID} ${VERSION_CODENAME} (${architecture})."
        echo
        echo "Valid versions in current apt-cache"
        apt-cache madison azure-cli | awk -F"|" '{print $2}' | grep -oP '^(.+:)?\K.+'
        exit 1
    fi
fi

# If Azure CLI extensions are requested, loop through and install 
if [ ${#AZ_EXTENSIONS[@]} -gt 0 ]; then
    echo "Installing Azure CLI extensions: ${AZ_EXTENSIONS}"
    extensions=(`echo ${AZ_EXTENSIONS} | tr ',' ' '`)
    for i in "${extensions[@]}"
    do
        echo "Installing ${i}"
        su ${_REMOTE_USER} -c "az extension add --name ${i} -y" || continue
    done
fi

if [ "${AZ_INSTALLBICEP}" = "true" ]; then
    # Install dependencies
    check_packages apt-transport-https curl 
    
    # Properly install Azure Bicep based on current architecture
    # The `az bicep install` command installs the linux-x64 binary even on arm64 devcontainers
    # The `az bicep install --target-platform` could be a solution; however, linux-arm64 is not an allowed value for this argument yet
    # Manually installing Bicep and moving to the appropriate directory where az expects it to be
    
    if [ "${AZ_BICEPVERSION}" = "latest" ]; then
        bicep_download_path="https://github.com/Azure/bicep/releases/latest/download"
    else
        bicep_download_path="https://github.com/Azure/bicep/releases/download/${AZ_BICEPVERSION}"
    fi

    if [ "${architecture}" = "arm64" ]; then
        curl -Lo bicep ${bicep_download_path}/bicep-linux-arm64
    else 
        curl -Lo bicep ${bicep_download_path}/bicep-linux-x64
    fi
    
    chmod +x ./bicep
    mv ./bicep /usr/local/bin/bicep

    # Add a symlink so bicep can be accessed as a standalone executable or as part of az
    mkdir -p ${_REMOTE_USER_HOME}/.azure/bin
    chown -hR ${_REMOTE_USER}:${_REMOTE_USER} ${_REMOTE_USER_HOME}/.azure
    ln -s /usr/local/bin/bicep ${_REMOTE_USER_HOME}/.azure/bin/bicep
fi

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"



================================================
FILE: src/azure-cli/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/common-utils/README.md
================================================

# Common Utilities (common-utils)

Installs a set of common command line utilities, Oh My Zsh!, and sets up a non-root user.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/common-utils:2": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| installZsh | Install ZSH? | boolean | true |
| configureZshAsDefaultShell | Change default shell to ZSH? | boolean | false |
| installOhMyZsh | Install Oh My Zsh!? | boolean | true |
| installOhMyZshConfig | Allow installing the default dev container .zshrc templates? | boolean | true |
| upgradePackages | Upgrade OS packages? | boolean | true |
| username | Enter name of a non-root user to configure or none to skip | string | automatic |
| userUid | Enter UID for non-root user | string | automatic |
| userGid | Enter GID for non-root user | string | automatic |
| nonFreePackages | Add packages from non-free Debian repository? (Debian only) | boolean | false |

## OS Support

This Feature should work on recent versions of Debian/Ubuntu, RedHat Enterprise Linux, Fedora, RockyLinux, and Alpine Linux.

## Using with dev container images

This Feature is used in many of the [dev container images](https://github.com/search?q=repo%3Adevcontainers%2Fimages+%22ghcr.io%2Fdevcontainers%2Ffeatures%2Fcommon-utils%22&type=code), as a result
these images have already allocated UID & GID 1000. Attempting to add this Feature with  UID 1000 and/or GID 1000 on top of such a dev container image will result in an error when building the dev container.

## Customizing the command prompt

By default, this script provides a custom command prompt that includes information about the git repository for the current folder. However, with certain large repositories, this can result in a slow command prompt due to the performance of needed git operations.

For performance reasons, a "dirty" indicator that tells you whether or not there are uncommitted changes is disabled by default. You can opt to turn this on for smaller repositories by entering the following in a terminal or adding it to your `postCreateCommand`:

```bash
git config devcontainers-theme.show-dirty 1
```

To completely disable the git portion of the prompt for the current folder's repository, you can use this configuration setting instead:

```bash
git config devcontainers-theme.hide-status 1
```

For `zsh`, the default theme is a [standard Oh My Zsh! theme](https://ohmyz.sh/). You may pick a different one by modifying the `ZSH_THEME` variable in `~/.zshrc`.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/common-utils/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/common-utils/devcontainer-feature.json
================================================
{
    "id": "common-utils",
    "version": "2.5.4",
    "name": "Common Utilities",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/common-utils",
    "description": "Installs a set of common command line utilities, Oh My Zsh!, and sets up a non-root user.",
    "options": {
        "installZsh": {
            "type": "boolean",
            "default": true,
            "description": "Install ZSH?"
        },
        "configureZshAsDefaultShell": {
            "type": "boolean",
            "default": false,
            "description": "Change default shell to ZSH?"
        },
        "installOhMyZsh": {
            "type": "boolean",
            "default": true,
            "description": "Install Oh My Zsh!?"
        },
        "installOhMyZshConfig": {
            "type": "boolean",
            "default": true,
            "description": "Allow installing the default dev container .zshrc templates?"
        },
        "upgradePackages": {
            "type": "boolean",
            "default": true,
            "description": "Upgrade OS packages?"
        },
        "username": {
            "type": "string",
            "proposals": [
                "devcontainer",
                "vscode",
                "codespace",
                "none",
                "automatic"
            ],
            "default": "automatic",
            "description": "Enter name of a non-root user to configure or none to skip"
        },
        "userUid": {
            "type": "string",
            "proposals": [
                "1001",
                "automatic"
            ],
            "default": "automatic",
            "description": "Enter UID for non-root user"
        },
        "userGid": {
            "type": "string",
            "proposals": [
                "1001",
                "automatic"
            ],
            "default": "automatic",
            "description": "Enter GID for non-root user"
        },
        "nonFreePackages": {
            "type": "boolean",
            "default": false,
            "description": "Add packages from non-free Debian repository? (Debian only)"
        }
    }
}



================================================
FILE: src/common-utils/install.sh
================================================
#!/bin/sh
#-------------------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://github.com/devcontainers/features/blob/main/LICENSE for license information.
#-------------------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/devcontainers/features/tree/main/src/common-utils
# Maintainer: The Dev Container spec maintainers

set -e

INSTALL_ZSH="${INSTALLZSH:-"true"}"
CONFIGURE_ZSH_AS_DEFAULT_SHELL="${CONFIGUREZSHASDEFAULTSHELL:-"false"}"
INSTALL_OH_MY_ZSH="${INSTALLOHMYZSH:-"true"}"
INSTALL_OH_MY_ZSH_CONFIG="${INSTALLOHMYZSHCONFIG:-"true"}"
UPGRADE_PACKAGES="${UPGRADEPACKAGES:-"true"}"
USERNAME="${USERNAME:-"automatic"}"
USER_UID="${UID:-"automatic"}"
USER_GID="${GID:-"automatic"}"
ADD_NON_FREE_PACKAGES="${NONFREEPACKAGES:-"false"}"

MARKER_FILE="/usr/local/etc/vscode-dev-containers/common"

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# If we're using Alpine, install bash before executing
. /etc/os-release
if [ "${ID}" = "alpine" ]; then
    apk add --no-cache bash
fi
if [ "${ID}" = "azurelinux" ]; then
    tdnf install -y curl git 
fi
exec /bin/bash "$(dirname $0)/main.sh" "$@"
exit $?



================================================
FILE: src/common-utils/main.sh
================================================
#!/bin/bash
#-------------------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://github.com/devcontainers/features/blob/main/LICENSE for license information.
#-------------------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/devcontainers/features/tree/main/src/common-utils
# Maintainer: The Dev Container spec maintainers

set -e

INSTALL_ZSH="${INSTALLZSH:-"true"}"
CONFIGURE_ZSH_AS_DEFAULT_SHELL="${CONFIGUREZSHASDEFAULTSHELL:-"false"}"
INSTALL_OH_MY_ZSH="${INSTALLOHMYZSH:-"true"}"
INSTALL_OH_MY_ZSH_CONFIG="${INSTALLOHMYZSHCONFIG:-"true"}"
UPGRADE_PACKAGES="${UPGRADEPACKAGES:-"true"}"
USERNAME="${USERNAME:-"automatic"}"
USER_UID="${USERUID:-"automatic"}"
USER_GID="${USERGID:-"automatic"}"
ADD_NON_FREE_PACKAGES="${NONFREEPACKAGES:-"false"}"

MARKER_FILE="/usr/local/etc/vscode-dev-containers/common"

FEATURE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Debian / Ubuntu packages
install_debian_packages() {
    # Ensure apt is in non-interactive to avoid prompts
    export DEBIAN_FRONTEND=noninteractive

    local package_list=""
    if [ "${PACKAGES_ALREADY_INSTALLED}" != "true" ]; then
        package_list="${package_list} \
        apt-utils \
        bash-completion \
        openssh-client \
        gnupg2 \
        dirmngr \
        iproute2 \
        procps \
        lsof \
        htop \
        net-tools \
        psmisc \
        curl \
        tree \
        wget \
        rsync \
        ca-certificates \
        unzip \
        bzip2 \
        xz-utils \
        zip \
        nano \
        vim-tiny \
        less \
        jq \
        lsb-release \
        apt-transport-https \
        dialog \
        libc6 \
        libgcc1 \
        libkrb5-3 \
        libgssapi-krb5-2 \
        libicu[0-9][0-9] \
        liblttng-ust[0-9] \
        libstdc++6 \
        zlib1g \
        locales \
        sudo \
        ncdu \
        man-db \
        strace \
        manpages \
        manpages-dev \
        init-system-helpers"

        # Include libssl1.1 if available
        if [[ ! -z $(apt-cache --names-only search ^libssl1.1$) ]]; then
            package_list="${package_list} libssl1.1"
        fi

        # Include libssl3 if available
        if [[ ! -z $(apt-cache --names-only search ^libssl3$) ]]; then
            package_list="${package_list} libssl3"
        fi

        # Include appropriate version of libssl1.0.x if available
        local libssl_package=$(dpkg-query -f '${db:Status-Abbrev}\t${binary:Package}\n' -W 'libssl1\.0\.?' 2>&1 || echo '')
        if [ "$(echo "$libssl_package" | grep -o 'libssl1\.0\.[0-9]:' | uniq | sort | wc -l)" -eq 0 ]; then
            if [[ ! -z $(apt-cache --names-only search ^libssl1.0.2$) ]]; then
                # Debian 9
                package_list="${package_list} libssl1.0.2"
            elif [[ ! -z $(apt-cache --names-only search ^libssl1.0.0$) ]]; then
                # Ubuntu 18.04
                package_list="${package_list} libssl1.0.0"
            fi
        fi

        # Include git if not already installed (may be more recent than distro version)
        if ! type git > /dev/null 2>&1; then
            package_list="${package_list} git"
        fi
    fi

    # Needed for adding manpages-posix and manpages-posix-dev which are non-free packages in Debian
    if [ "${ADD_NON_FREE_PACKAGES}" = "true" ]; then
        if [[ ! -e "/etc/apt/sources.list" ]] && [[ -e "/etc/apt/sources.list.d/debian.sources" ]]; then 
            sed -i '/^URIs: http:\/\/deb.debian.org\/debian$/ { N; N; s/Components: main/Components: main non-free non-free-firmware/ }' /etc/apt/sources.list.d/debian.sources
        else
            # Bring in variables from /etc/os-release like VERSION_CODENAME
            sed -i -E "s/deb http:\/\/(deb|httpredir)\.debian\.org\/debian ${VERSION_CODENAME} main/deb http:\/\/\1\.debian\.org\/debian ${VERSION_CODENAME} main contrib non-free/" /etc/apt/sources.list
            sed -i -E "s/deb-src http:\/\/(deb|httredir)\.debian\.org\/debian ${VERSION_CODENAME} main/deb http:\/\/\1\.debian\.org\/debian ${VERSION_CODENAME} main contrib non-free/" /etc/apt/sources.list
            sed -i -E "s/deb http:\/\/(deb|httpredir)\.debian\.org\/debian ${VERSION_CODENAME}-updates main/deb http:\/\/\1\.debian\.org\/debian ${VERSION_CODENAME}-updates main contrib non-free/" /etc/apt/sources.list
            sed -i -E "s/deb-src http:\/\/(deb|httpredir)\.debian\.org\/debian ${VERSION_CODENAME}-updates main/deb http:\/\/\1\.debian\.org\/debian ${VERSION_CODENAME}-updates main contrib non-free/" /etc/apt/sources.list
            sed -i "s/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}\/updates main/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}\/updates main contrib non-free/" /etc/apt/sources.list
            sed -i "s/deb-src http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}\/updates main/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}\/updates main contrib non-free/" /etc/apt/sources.list
            sed -i "s/deb http:\/\/deb\.debian\.org\/debian ${VERSION_CODENAME}-backports main/deb http:\/\/deb\.debian\.org\/debian ${VERSION_CODENAME}-backports main contrib non-free/" /etc/apt/sources.list
            sed -i "s/deb-src http:\/\/deb\.debian\.org\/debian ${VERSION_CODENAME}-backports main/deb http:\/\/deb\.debian\.org\/debian ${VERSION_CODENAME}-backports main contrib non-free/" /etc/apt/sources.list
            # Handle bullseye location for security https://www.debian.org/releases/bullseye/amd64/release-notes/ch-information.en.html
            sed -i "s/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}-security main/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}-security main contrib non-free/" /etc/apt/sources.list
            sed -i "s/deb-src http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}-security main/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}-security main contrib non-free/" /etc/apt/sources.list
        fi;
        echo "Running apt-get update..."
        package_list="${package_list} manpages-posix manpages-posix-dev"
    fi

    # Install the list of packages
    echo "Packages to verify are installed: ${package_list}"
    rm -rf /var/lib/apt/lists/*
    apt-get update -y
    apt-get -y install --no-install-recommends ${package_list} 2> >( grep -v 'debconf: delaying package configuration, since apt-utils is not installed' >&2 )

    # Install zsh (and recommended packages) if needed
    if [ "${INSTALL_ZSH}" = "true" ] && ! type zsh > /dev/null 2>&1; then
        apt-get install -y zsh
    fi

    # Get to latest versions of all packages
    if [ "${UPGRADE_PACKAGES}" = "true" ]; then
        apt-get -y upgrade --no-install-recommends
        apt-get autoremove -y
    fi

    # Ensure at least the en_US.UTF-8 UTF-8 locale is available = common need for both applications and things like the agnoster ZSH theme.
    if [ "${LOCALE_ALREADY_SET}" != "true" ] && ! grep -o -E '^\s*en_US.UTF-8\s+UTF-8' /etc/locale.gen > /dev/null; then
        echo "en_US.UTF-8 UTF-8" >> /etc/locale.gen
        locale-gen
        LOCALE_ALREADY_SET="true"
    fi

    PACKAGES_ALREADY_INSTALLED="true"

    # Clean up
    apt-get -y clean
    rm -rf /var/lib/apt/lists/*
}

# RedHat / RockyLinux / CentOS / Fedora packages
install_redhat_packages() {
    local package_list=""
    local remove_epel="false"
    local install_cmd=microdnf
    if type microdnf > /dev/null 2>&1; then
       install_cmd=microdnf
    elif type tdnf > /dev/null 2>&1; then
       install_cmd=tdnf
    elif type dnf > /dev/null 2>&1; then
       install_cmd=dnf
    elif type yum > /dev/null 2>&1; then
       install_cmd=yum
    else
       echo "Unable to find 'tdnf', 'dnf', or 'yum' package manager. Exiting."
       exit 1
fi

    if [ "${PACKAGES_ALREADY_INSTALLED}" != "true" ]; then
        package_list="${package_list} \
            gawk \
            bash-completion \
            openssh-clients \
            gnupg2 \
            iproute \
            procps \
            lsof \
            net-tools \
            psmisc \
            wget \
            ca-certificates \
            rsync \
            unzip \
            xz \
            zip \
            nano \
            vim-minimal \
            less \
            jq \
            openssl-libs \
            krb5-libs \
            libicu \
            zlib \
            sudo \
            sed \
            grep \
            which \
            man-db \
            strace"

        # rockylinux:9 installs 'curl-minimal' which clashes with 'curl'
        # Install 'curl' for every OS except this rockylinux:9
        if [[ "${ID}" = "rocky" ]] && [[ "${VERSION}" != *"9."* ]]; then
            package_list="${package_list} curl"
        fi

        # Install OpenSSL 1.0 compat if needed
        if ${install_cmd} -q list compat-openssl10 >/dev/null 2>&1; then
            package_list="${package_list} compat-openssl10"
        fi

        # Install lsb_release if available
        if ${install_cmd} -q list redhat-lsb-core >/dev/null 2>&1; then
            package_list="${package_list} redhat-lsb-core"
        fi

        # Install git if not already installed (may be more recent than distro version)
        if ! type git > /dev/null 2>&1; then
            package_list="${package_list} git"
        fi

        # Install EPEL repository if needed (required to install 'jq' for CentOS)
        if ! ${install_cmd} -q list jq >/dev/null 2>&1; then
            ${install_cmd} -y install epel-release
            remove_epel="true"
        fi
    fi

    # Install zsh if needed
    if [ "${INSTALL_ZSH}" = "true" ] && ! type zsh > /dev/null 2>&1; then
        package_list="${package_list} zsh"
    fi

    if [ -n "${package_list}" ]; then
        ${install_cmd} -y install ${package_list}
    fi

    # Get to latest versions of all packages
    if [ "${UPGRADE_PACKAGES}" = "true" ]; then
        ${install_cmd} upgrade -y
    fi

    if [[ "${remove_epel}" = "true" ]]; then
        ${install_cmd} -y remove epel-release
    fi

    PACKAGES_ALREADY_INSTALLED="true"
}

# Alpine Linux packages
install_alpine_packages() {
    apk update

    if [ "${PACKAGES_ALREADY_INSTALLED}" != "true" ]; then
        apk add --no-cache \
            openssh-client \
            bash-completion \
            gnupg \
            procps \
            lsof \
            htop \
            net-tools \
            psmisc \
            curl \
            wget \
            rsync \
            ca-certificates \
            unzip \
            xz \
            zip \
            nano \
            vim \
            less \
            jq \
            libgcc \
            libstdc++ \
            krb5-libs \
            libintl \
            lttng-ust \
            tzdata \
            userspace-rcu \
            zlib \
            sudo \
            coreutils \
            sed \
            grep \
            which \
            ncdu \
            shadow \
            strace

        # # Include libssl1.1 if available (not available for 3.19 and newer)
        LIBSSL1_PKG=libssl1.1
        if [[ $(apk search --no-cache -a $LIBSSL1_PKG | grep $LIBSSL1_PKG) ]]; then
            apk add --no-cache $LIBSSL1_PKG
        fi

        # Install man pages - package name varies between 3.12 and earlier versions
        if apk info man > /dev/null 2>&1; then
            apk add --no-cache man man-pages
        else
            apk add --no-cache mandoc man-pages
        fi

        # Install git if not already installed (may be more recent than distro version)
        if ! type git > /dev/null 2>&1; then
            apk add --no-cache git
        fi
    fi

    # Install zsh if needed
    if [ "${INSTALL_ZSH}" = "true" ] && ! type zsh > /dev/null 2>&1; then
        apk add --no-cache zsh
    fi

    PACKAGES_ALREADY_INSTALLED="true"
}

# ******************
# ** Main section **
# ******************

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Load markers to see which steps have already run
if [ -f "${MARKER_FILE}" ]; then
    echo "Marker file found:"
    cat "${MARKER_FILE}"
    source "${MARKER_FILE}"
fi

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# Bring in ID, ID_LIKE, VERSION_ID, VERSION_CODENAME
. /etc/os-release
# Get an adjusted ID independent of distro variants
if [ "${ID}" = "debian" ] || [ "${ID_LIKE}" = "debian" ]; then
    ADJUSTED_ID="debian"
elif [[ "${ID}" = "rhel" || "${ID}" = "fedora" || "${ID}" = "azurelinux" || "${ID}" = "mariner" || "${ID_LIKE}" = *"rhel"* || "${ID_LIKE}" = *"fedora"* || "${ID_LIKE}" = *"mariner"* ]]; then
    ADJUSTED_ID="rhel"
    VERSION_CODENAME="${ID}${VERSION_ID}"
elif [ "${ID}" = "alpine" ]; then
    ADJUSTED_ID="alpine"
else
    echo "Linux distro ${ID} not supported."
    exit 1
fi

if [ "${ADJUSTED_ID}" = "rhel" ] && [ "${VERSION_CODENAME-}" = "centos7" ]; then
    # As of 1 July 2024, mirrorlist.centos.org no longer exists.
    # Update the repo files to reference vault.centos.org.
    sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.repo
    sed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.repo
    sed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo
fi

if [ "${ADJUSTED_ID}" = "rhel" ] && [ "${VERSION_CODENAME-}" = "centos7" ]; then
    # As of 1 July 2024, mirrorlist.centos.org no longer exists.
    # Update the repo files to reference vault.centos.org.
    sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.repo
    sed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.repo
    sed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo
fi

# Install packages for appropriate OS
case "${ADJUSTED_ID}" in
    "debian")
        install_debian_packages
        ;;
    "rhel")
        install_redhat_packages
        ;;
    "alpine")
        install_alpine_packages
        ;;
esac

# If in automatic mode, determine if a user already exists, if not use vscode
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    if [ "${_REMOTE_USER}" != "root" ]; then
        USERNAME="${_REMOTE_USER}"
    else
        USERNAME=""
        POSSIBLE_USERS=("devcontainer" "vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
        for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
            if id -u ${CURRENT_USER} > /dev/null 2>&1; then
                USERNAME=${CURRENT_USER}
                break
            fi
        done
        if [ "${USERNAME}" = "" ]; then
            USERNAME=vscode
        fi
    fi
elif [ "${USERNAME}" = "none" ]; then
    USERNAME=root
    USER_UID=0
    USER_GID=0
fi
# Create or update a non-root user to match UID/GID.
group_name="${USERNAME}"
if id -u ${USERNAME} > /dev/null 2>&1; then
    # User exists, update if needed
    if [ "${USER_GID}" != "automatic" ] && [ "$USER_GID" != "$(id -g $USERNAME)" ]; then
        group_name="$(id -gn $USERNAME)"
        groupmod --gid $USER_GID ${group_name}
        usermod --gid $USER_GID $USERNAME
    fi
    if [ "${USER_UID}" != "automatic" ] && [ "$USER_UID" != "$(id -u $USERNAME)" ]; then
        usermod --uid $USER_UID $USERNAME
    fi
else
    # Create user
    if [ "${USER_GID}" = "automatic" ]; then
        groupadd $USERNAME
    else
        groupadd --gid $USER_GID $USERNAME
    fi
    if [ "${USER_UID}" = "automatic" ]; then
        useradd -s /bin/bash --gid $USERNAME -m $USERNAME
    else
        useradd -s /bin/bash --uid $USER_UID --gid $USERNAME -m $USERNAME
    fi
fi

# Add add sudo support for non-root user
if [ "${USERNAME}" != "root" ] && [ "${EXISTING_NON_ROOT_USER}" != "${USERNAME}" ]; then
    echo $USERNAME ALL=\(root\) NOPASSWD:ALL > /etc/sudoers.d/$USERNAME
    chmod 0440 /etc/sudoers.d/$USERNAME
    EXISTING_NON_ROOT_USER="${USERNAME}"
fi

# *********************************
# ** Shell customization section **
# *********************************

if [ "${USERNAME}" = "root" ]; then
    user_home="/root"
# Check if user already has a home directory other than /home/${USERNAME}
elif [ "/home/${USERNAME}" != $( getent passwd $USERNAME | cut -d: -f6 ) ]; then
    user_home=$( getent passwd $USERNAME | cut -d: -f6 )
else
    user_home="/home/${USERNAME}"
    if [ ! -d "${user_home}" ]; then
        mkdir -p "${user_home}"
        chown ${USERNAME}:${group_name} "${user_home}"
    fi
fi

# Restore user .bashrc / .profile / .zshrc defaults from skeleton file if it doesn't exist or is empty
possible_rc_files=( ".bashrc" ".profile" )
[ "$INSTALL_OH_MY_ZSH_CONFIG" == "true" ] && possible_rc_files+=('.zshrc')
[ "$INSTALL_ZSH" == "true" ] && possible_rc_files+=('.zprofile')
for rc_file in "${possible_rc_files[@]}"; do
    if [ -f "/etc/skel/${rc_file}" ]; then
        if [ ! -e "${user_home}/${rc_file}" ] || [ ! -s "${user_home}/${rc_file}" ]; then
            cp "/etc/skel/${rc_file}" "${user_home}/${rc_file}"
            chown ${USERNAME}:${group_name} "${user_home}/${rc_file}"
        fi
    fi
done

# Add RC snippet and custom bash prompt
if [ "${RC_SNIPPET_ALREADY_ADDED}" != "true" ]; then
    case "${ADJUSTED_ID}" in
        "debian")
            global_rc_path="/etc/bash.bashrc"
            ;;
        "rhel")
            global_rc_path="/etc/bashrc"
            ;;
        "alpine")
            global_rc_path="/etc/bash/bashrc"
            # /etc/bash/bashrc does not exist in alpine 3.14 & 3.15
            mkdir -p /etc/bash
            ;;
    esac
    cat "${FEATURE_DIR}/scripts/rc_snippet.sh" >> ${global_rc_path}
    cat "${FEATURE_DIR}/scripts/bash_theme_snippet.sh" >> "${user_home}/.bashrc"
    if [ "${USERNAME}" != "root" ]; then
        cat "${FEATURE_DIR}/scripts/bash_theme_snippet.sh" >> "/root/.bashrc"
        chown ${USERNAME}:${group_name} "${user_home}/.bashrc"
    fi
    RC_SNIPPET_ALREADY_ADDED="true"
fi

# Optionally configure zsh and Oh My Zsh!
if [ "${INSTALL_ZSH}" = "true" ]; then
   if [ ! -f "${user_home}/.zprofile" ]; then
        touch "${user_home}/.zprofile"
        echo 'source $HOME/.profile' >> "${user_home}/.zprofile" # TODO: Reconsider adding '.profile' to '.zprofile'
        chown ${USERNAME}:${group_name} "${user_home}/.zprofile"
    fi

    if [ "${ZSH_ALREADY_INSTALLED}" != "true" ]; then
        if [ "${ADJUSTED_ID}" = "rhel" ]; then
             global_rc_path="/etc/zshrc"
        else
            global_rc_path="/etc/zsh/zshrc"
        fi
        cat "${FEATURE_DIR}/scripts/rc_snippet.sh" >> ${global_rc_path}
        ZSH_ALREADY_INSTALLED="true"
    fi

    if [ "${CONFIGURE_ZSH_AS_DEFAULT_SHELL}" == "true" ]; then
        # Fixing chsh always asking for a password on alpine linux
        # ref: https://askubuntu.com/questions/812420/chsh-always-asking-a-password-and-get-pam-authentication-failure.
        if [ ! -f "/etc/pam.d/chsh" ] || ! grep -Eq '^auth(.*)pam_rootok\.so$' /etc/pam.d/chsh; then
            echo "auth sufficient pam_rootok.so" >> /etc/pam.d/chsh
        elif [[ -n "$(awk '/^auth(.*)pam_rootok\.so$/ && !/^auth[[:blank:]]+sufficient[[:blank:]]+pam_rootok\.so$/' /etc/pam.d/chsh)" ]]; then
            awk '/^auth(.*)pam_rootok\.so$/ { $2 = "sufficient" } { print }' /etc/pam.d/chsh > /tmp/chsh.tmp && mv /tmp/chsh.tmp /etc/pam.d/chsh
        fi

        chsh --shell /bin/zsh ${USERNAME}
    fi

    # Adapted, simplified inline Oh My Zsh! install steps that adds, defaults to a codespaces theme.
    # See https://github.com/ohmyzsh/ohmyzsh/blob/master/tools/install.sh for official script.
    if [ "${INSTALL_OH_MY_ZSH}" = "true" ]; then
        user_rc_file="${user_home}/.zshrc"
        oh_my_install_dir="${user_home}/.oh-my-zsh"
        template_path="${oh_my_install_dir}/templates/zshrc.zsh-template"
        if [ ! -d "${oh_my_install_dir}" ]; then
            umask g-w,o-w
            mkdir -p ${oh_my_install_dir}
            git clone --depth=1 \
                -c core.eol=lf \
                -c core.autocrlf=false \
                -c fsck.zeroPaddedFilemode=ignore \
                -c fetch.fsck.zeroPaddedFilemode=ignore \
                -c receive.fsck.zeroPaddedFilemode=ignore \
                "https://github.com/ohmyzsh/ohmyzsh" "${oh_my_install_dir}" 2>&1

            # Shrink git while still enabling updates
            cd "${oh_my_install_dir}"
            git repack -a -d -f --depth=1 --window=1
        fi

        # Add Dev Containers theme
        mkdir -p ${oh_my_install_dir}/custom/themes
        cp -f "${FEATURE_DIR}/scripts/devcontainers.zsh-theme" "${oh_my_install_dir}/custom/themes/devcontainers.zsh-theme"
        ln -sf "${oh_my_install_dir}/custom/themes/devcontainers.zsh-theme" "${oh_my_install_dir}/custom/themes/codespaces.zsh-theme"

        # Add devcontainer .zshrc template
        if [ "$INSTALL_OH_MY_ZSH_CONFIG" = "true" ]; then
            if ! [ -f "${template_path}" ] || ! grep -qF "$(head -n 1 "${template_path}")" "${user_rc_file}"; then
                echo -e "$(cat "${template_path}")\nzstyle ':omz:update' mode disabled" > ${user_rc_file}
            fi
            sed -i -e 's/ZSH_THEME=.*/ZSH_THEME="devcontainers"/g' ${user_rc_file}
        fi

        # Copy to non-root user if one is specified
        if [ "${USERNAME}" != "root" ]; then
            copy_to_user_files=("${oh_my_install_dir}")
            [ -f "$user_rc_file" ] && copy_to_user_files+=("$user_rc_file")
            cp -rf "${copy_to_user_files[@]}" /root
            chown -R ${USERNAME}:${group_name} "${copy_to_user_files[@]}"
        fi
    fi
fi

# *********************************
# ** Ensure config directory **
# *********************************
user_config_dir="${user_home}/.config"
if [ ! -d "${user_config_dir}" ]; then
    mkdir -p "${user_config_dir}"
    chown ${USERNAME}:${group_name} "${user_config_dir}"
fi

# ****************************
# ** Utilities and commands **
# ****************************

# code shim, it fallbacks to code-insiders if code is not available
cp -f "${FEATURE_DIR}/bin/code" /usr/local/bin/
chmod +rx /usr/local/bin/code

# systemctl shim for Debian/Ubuntu - tells people to use 'service' if systemd is not running
if [ "${ADJUSTED_ID}" = "debian" ]; then
    cp -fL "${FEATURE_DIR}/bin/systemctl" /usr/local/bin/systemctl
    chmod +rx /usr/local/bin/systemctl
fi

# Persist image metadata info, script if meta.env found in same directory
if [ -f "/usr/local/etc/vscode-dev-containers/meta.env" ] || [ -f "/usr/local/etc/dev-containers/meta.env" ]; then
    cp -f "${FEATURE_DIR}/bin/devcontainer-info" /usr/local/bin/devcontainer-info
    chmod +rx /usr/local/bin/devcontainer-info
fi

# Write marker file
if [ ! -d "/usr/local/etc/vscode-dev-containers" ]; then
    mkdir -p "$(dirname "${MARKER_FILE}")"
fi
echo -e "\
    PACKAGES_ALREADY_INSTALLED=${PACKAGES_ALREADY_INSTALLED}\n\
    LOCALE_ALREADY_SET=${LOCALE_ALREADY_SET}\n\
    EXISTING_NON_ROOT_USER=${EXISTING_NON_ROOT_USER}\n\
    RC_SNIPPET_ALREADY_ADDED=${RC_SNIPPET_ALREADY_ADDED}\n\
    ZSH_ALREADY_INSTALLED=${ZSH_ALREADY_INSTALLED}" > "${MARKER_FILE}"

echo "Done!"



================================================
FILE: src/common-utils/NOTES.md
================================================
## OS Support

This Feature should work on recent versions of Debian/Ubuntu, RedHat Enterprise Linux, Fedora, RockyLinux, and Alpine Linux.

## Using with dev container images

This Feature is used in many of the [dev container images](https://github.com/search?q=repo%3Adevcontainers%2Fimages+%22ghcr.io%2Fdevcontainers%2Ffeatures%2Fcommon-utils%22&type=code), as a result
these images have already allocated UID & GID 1000. Attempting to add this Feature with  UID 1000 and/or GID 1000 on top of such a dev container image will result in an error when building the dev container.

## Customizing the command prompt

By default, this script provides a custom command prompt that includes information about the git repository for the current folder. However, with certain large repositories, this can result in a slow command prompt due to the performance of needed git operations.

For performance reasons, a "dirty" indicator that tells you whether or not there are uncommitted changes is disabled by default. You can opt to turn this on for smaller repositories by entering the following in a terminal or adding it to your `postCreateCommand`:

```bash
git config devcontainers-theme.show-dirty 1
```

To completely disable the git portion of the prompt for the current folder's repository, you can use this configuration setting instead:

```bash
git config devcontainers-theme.hide-status 1
```

For `zsh`, the default theme is a [standard Oh My Zsh! theme](https://ohmyz.sh/). You may pick a different one by modifying the `ZSH_THEME` variable in `~/.zshrc`.



================================================
FILE: src/common-utils/scripts/bash_theme_snippet.sh
================================================
# bash theme - partly inspired by https://github.com/ohmyzsh/ohmyzsh/blob/master/themes/robbyrussell.zsh-theme
__bash_prompt() {
    local userpart='`export XIT=$? \
        && [ ! -z "${GITHUB_USER:-}" ] && echo -n "\[\033[0;32m\]@${GITHUB_USER:-} " || echo -n "\[\033[0;32m\]\u " \
        && [ "$XIT" -ne "0" ] && echo -n "\[\033[1;31m\]âœ" || echo -n "\[\033[0m\]âœ"`'
    local gitbranch='`\
        if [ "$(git config --get devcontainers-theme.hide-status 2>/dev/null)" != 1 ] && [ "$(git config --get codespaces-theme.hide-status 2>/dev/null)" != 1 ]; then \
            export BRANCH="$(git --no-optional-locks symbolic-ref --short HEAD 2>/dev/null || git --no-optional-locks rev-parse --short HEAD 2>/dev/null)"; \
            if [ "${BRANCH:-}" != "" ]; then \
                echo -n "\[\033[0;36m\](\[\033[1;31m\]${BRANCH:-}" \
                && if [ "$(git config --get devcontainers-theme.show-dirty 2>/dev/null)" = 1 ] && \
                    git --no-optional-locks ls-files --error-unmatch -m --directory --no-empty-directory -o --exclude-standard ":/*" > /dev/null 2>&1; then \
                        echo -n " \[\033[1;33m\]âœ—"; \
                fi \
                && echo -n "\[\033[0;36m\]) "; \
            fi; \
        fi`'
    local lightblue='\[\033[1;34m\]'
    local removecolor='\[\033[0m\]'
    PS1="${userpart} ${lightblue}\w ${gitbranch}${removecolor}\$ "
    unset -f __bash_prompt
}
__bash_prompt
export PROMPT_DIRTRIM=4

# Check if the terminal is xterm
if [[ "$TERM" == "xterm" ]]; then
    # Function to set the terminal title to the current command
    preexec() {
        local cmd="${BASH_COMMAND}"
        echo -ne "\033]0;${USER}@${HOSTNAME}: ${cmd}\007"
    }

    # Function to reset the terminal title to the shell type after the command is executed
    precmd() {
        echo -ne "\033]0;${USER}@${HOSTNAME}: ${SHELL}\007"
    }

    # Trap DEBUG signal to call preexec before each command
    trap 'preexec' DEBUG

    # Append to PROMPT_COMMAND to call precmd before displaying the prompt
    PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND; }precmd"
fi



================================================
FILE: src/common-utils/scripts/devcontainers.zsh-theme
================================================
# Oh My Zsh! theme - partly inspired by https://github.com/ohmyzsh/ohmyzsh/blob/master/themes/robbyrussell.zsh-theme
__zsh_prompt() {
    local prompt_username
    if [ ! -z "${GITHUB_USER}" ]; then
        prompt_username="@${GITHUB_USER}"
    else
        prompt_username="%n"
    fi
    PROMPT="%{$fg[green]%}${prompt_username} %(?:%{$reset_color%}âœ :%{$fg_bold[red]%}âœ )" # User/exit code arrow
    PROMPT+='%{$fg_bold[blue]%}%(5~|%-1~/â€¦/%3~|%4~)%{$reset_color%} ' # cwd
    PROMPT+='`\
        if [ "$(git config --get devcontainers-theme.hide-status 2>/dev/null)" != 1 ] && [ "$(git config --get codespaces-theme.hide-status 2>/dev/null)" != 1 ]; then \
            export BRANCH=$(git --no-optional-locks symbolic-ref --short HEAD 2>/dev/null || git --no-optional-locks rev-parse --short HEAD 2>/dev/null); \
            if [ "${BRANCH}" != "" ]; then \
                echo -n "%{$fg_bold[cyan]%}(%{$fg_bold[red]%}${BRANCH}" \
                && if [ "$(git config --get devcontainers-theme.show-dirty 2>/dev/null)" = 1 ] && \
                    git --no-optional-locks ls-files --error-unmatch -m --directory --no-empty-directory -o --exclude-standard ":/*" > /dev/null 2>&1; then \
                        echo -n " %{$fg_bold[yellow]%}âœ—"; \
                fi \
                && echo -n "%{$fg_bold[cyan]%})%{$reset_color%} "; \
            fi; \
        fi`'
    PROMPT+='%{$fg[white]%}$ %{$reset_color%}'
    unset -f __zsh_prompt
}
__zsh_prompt

# Check if the terminal is xterm
if [[ "$TERM" == "xterm" ]]; then
    # Function to set the terminal title to the current command
    preexec() {
        local cmd=${1}
        echo -ne "\033]0;${USER}@${HOSTNAME}: ${cmd}\007"
    }

    # Function to reset the terminal title to the shell type after the command is executed
    precmd() {
        echo -ne "\033]0;${USER}@${HOSTNAME}: ${SHELL}\007"
    }

    # Add the preexec and precmd functions to the corresponding hooks
    autoload -Uz add-zsh-hook
    add-zsh-hook preexec preexec
    add-zsh-hook precmd precmd
fi



================================================
FILE: src/common-utils/scripts/rc_snippet.sh
================================================
if [ -z "${USER}" ]; then export USER=$(whoami); fi
if [[ "${PATH}" != *"$HOME/.local/bin"* ]]; then export PATH="${PATH}:$HOME/.local/bin"; fi

# Display optional first run image specific notice if configured and terminal is interactive
if [ -t 1 ] && [[ "${TERM_PROGRAM}" = "vscode" || "${TERM_PROGRAM}" = "codespaces" ]] && [ ! -f "$HOME/.config/vscode-dev-containers/first-run-notice-already-displayed" ]; then
    if [ -f "/usr/local/etc/vscode-dev-containers/first-run-notice.txt" ]; then
        cat "/usr/local/etc/vscode-dev-containers/first-run-notice.txt"
    elif [ -f "/workspaces/.codespaces/shared/first-run-notice.txt" ]; then
        cat "/workspaces/.codespaces/shared/first-run-notice.txt"
    fi
    mkdir -p "$HOME/.config/vscode-dev-containers"
    # Mark first run notice as displayed after 10s to avoid problems with fast terminal refreshes hiding it
    ((sleep 10s; touch "$HOME/.config/vscode-dev-containers/first-run-notice-already-displayed") &)
fi

# Set the default git editor if not already set
if [ -z "$(git config --get core.editor)" ] && [ -z "${GIT_EDITOR}" ]; then
    if  [ "${TERM_PROGRAM}" = "vscode" ]; then
        if [[ -n $(command -v code-insiders) &&  -z $(command -v code) ]]; then
            export GIT_EDITOR="code-insiders --wait"
        else
            export GIT_EDITOR="code --wait"
        fi
    fi
fi



================================================
FILE: src/conda/README.md
================================================

# Conda (conda)

A cross-platform, language-agnostic binary package manager

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/conda:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a conda version. | string | latest |
| addCondaForge | Add conda-forge channel to the config? | boolean | false |

## Using Conda

This Feature includes [the `conda` package manager](https://docs.conda.io/projects/conda/en/latest/index.html) which is a part of the [Anaconda Distribution](https://repo.anaconda.com). Additional packages installed using Conda will be downloaded from Anaconda or another repository if you configure one. To reconfigure Conda in this container to access an alternative repository, please see information on [configuring Conda channels here](https://docs.conda.io/projects/conda/en/latest/user-guide/concepts/channels.html ).

Access to the Anaconda repository is covered by the [Anaconda Terms of Service](https://legal.anaconda.com/policies/en/?name=terms-of-service), which may require some organizations to obtain a commercial license from Anaconda. **However**, when used with GitHub Codespaces or GitHub Actions, **all users are permitted** to use the Anaconda Repository through the service, including organizations normally required by Anaconda to obtain a paid license for commercial activities. Note that third-party packages may be licensed by their publishers in ways that impact your intellectual property, and are used at your own risk.

## Installing a different version of Python

As covered in the [user FAQ](https://docs.anaconda.com/anaconda/user-guide/faq) for Anaconda, you can install different versions of Python than the one in this image by running the following from a terminal:

```bash
conda install python=3.7
```


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/conda/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/conda/devcontainer-feature.json
================================================
{
    "id": "conda",
    "version": "1.0.10",
    "name": "Conda",
    "description": "A cross-platform, language-agnostic binary package manager",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/conda",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "4.11.0",
                "4.12.0"
            ],
            "default": "latest",
            "description": "Select or enter a conda version."
        },
        "addCondaForge": {
            "type": "boolean",
            "default": false,
            "description": "Add conda-forge channel to the config?"
        }
    },
    "containerEnv": {
        "CONDA_DIR": "/opt/conda",
        "CONDA_SCRIPT":"/opt/conda/etc/profile.d/conda.sh",
        "PATH": "/opt/conda/bin:${PATH}"
    },
    "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes the conda package manager pre-installed and available on the `PATH` for data science and Python development. Additional packages installed using Conda will be downloaded from Anaconda or another repository configured by the user. A user can install different versions of Python than the one in this dev container by running a command like: conda install python=3.7"
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/conda/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------

VERSION=${VERSION:-"latest"}
ADD_CONDA_FORGE=$ADDCONDAFORGE

USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="true"
CONDA_DIR="/opt/conda"

set -eux
export DEBIAN_FRONTEND=noninteractive

# Clean up
rm -rf /var/lib/apt/lists/*

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u "${CURRENT_USER}" > /dev/null 2>&1; then
            USERNAME="${CURRENT_USER}"
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

architecture="$(uname -m)"
if [ "${architecture}" != "x86_64" ]; then
    echo "(!) Architecture $architecture unsupported"
    exit 1
fi

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
            echo "Running apt-get update..."
            apt-get update -y
        fi
        apt-get -y install --no-install-recommends "$@"
    fi
}

sudo_if() {
    COMMAND="$*"
    if [ "$(id -u)" -eq 0 ] && [ "$USERNAME" != "root" ]; then
        su - "$USERNAME" -c "$COMMAND"
    else
        $COMMAND
    fi
}

install_user_package() {
    PACKAGE="$1"
    sudo_if "${CONDA_DIR}/bin/python3" -m pip install --user --upgrade "$PACKAGE"
}

# Install Conda if it's missing
if ! conda --version &> /dev/null ; then
    if ! cat /etc/group | grep -e "^conda:" > /dev/null 2>&1; then
        groupadd -r conda
    fi
    usermod -a -G conda "${USERNAME}"

    # Install dependencies
    check_packages curl ca-certificates gnupg2

    echo "Installing Conda..."

    curl -sS https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc | gpg --dearmor > /usr/share/keyrings/conda-archive-keyring.gpg
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/conda-archive-keyring.gpg] https://repo.anaconda.com/pkgs/misc/debrepo/conda stable main" > /etc/apt/sources.list.d/conda.list
    apt-get update -y

    CONDA_PKG="conda=${VERSION}-0"
    if [ "${VERSION}" = "latest" ]; then
        CONDA_PKG="conda"
    fi

    check_packages $CONDA_PKG

    CONDA_SCRIPT="/opt/conda/etc/profile.d/conda.sh"
    . $CONDA_SCRIPT

    if [ "${ADD_CONDA_FORGE}" = "true" ]; then
        conda config --add channels conda-forge
    fi

    conda config --set channel_priority strict
    conda config --set env_prompt '({name})'
    echo "source ${CONDA_SCRIPT}" >> ~/.bashrc

    chown -R "${USERNAME}:conda" "${CONDA_DIR}"
    chmod -R g+r+w "${CONDA_DIR}"
    
    find "${CONDA_DIR}" -type d -print0 | xargs -n 1 -0 chmod g+s

    # Temporary fixes
    # Due to https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-23491
    install_user_package certifi
    # Due to https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-0286 and https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23931
    install_user_package cryptography
    # Due to https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-40897
    install_user_package setuptools
fi

# Display a notice on conda when not running in GitHub Codespaces
mkdir -p /usr/local/etc/vscode-dev-containers
cat << 'EOF' > /usr/local/etc/vscode-dev-containers/conda-notice.txt
When using "conda" from outside of GitHub Codespaces, note the Anaconda repository contains
restrictions on commercial use that may impact certain organizations. See https://aka.ms/ghcs-conda

EOF

notice_script="$(cat << 'EOF'
if [ -t 1 ] && [ "${IGNORE_NOTICE}" != "true" ] && [ "${TERM_PROGRAM}" = "vscode" ] && [ "${CODESPACES}" != "true" ] && [ ! -f "$HOME/.config/vscode-dev-containers/conda-notice-already-displayed" ]; then
    cat "/usr/local/etc/vscode-dev-containers/conda-notice.txt"
    mkdir -p "$HOME/.config/vscode-dev-containers"
    ((sleep 10s; touch "$HOME/.config/vscode-dev-containers/conda-notice-already-displayed") &)
fi
EOF
)"

if [ -f "/etc/zsh/zshrc" ]; then
    echo "${notice_script}" | tee -a /etc/zsh/zshrc
fi

if [ -f "/etc/bash.bashrc" ]; then
    echo "${notice_script}" | tee -a /etc/bash.bashrc
fi

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"



================================================
FILE: src/conda/NOTES.md
================================================
## Using Conda

This Feature includes [the `conda` package manager](https://docs.conda.io/projects/conda/en/latest/index.html) which is a part of the [Anaconda Distribution](https://repo.anaconda.com). Additional packages installed using Conda will be downloaded from Anaconda or another repository if you configure one. To reconfigure Conda in this container to access an alternative repository, please see information on [configuring Conda channels here](https://docs.conda.io/projects/conda/en/latest/user-guide/concepts/channels.html ).

Access to the Anaconda repository is covered by the [Anaconda Terms of Service](https://legal.anaconda.com/policies/en/?name=terms-of-service), which may require some organizations to obtain a commercial license from Anaconda. **However**, when used with GitHub Codespaces or GitHub Actions, **all users are permitted** to use the Anaconda Repository through the service, including organizations normally required by Anaconda to obtain a paid license for commercial activities. Note that third-party packages may be licensed by their publishers in ways that impact your intellectual property, and are used at your own risk.

## Installing a different version of Python

As covered in the [user FAQ](https://docs.anaconda.com/anaconda/user-guide/faq) for Anaconda, you can install different versions of Python than the one in this image by running the following from a terminal:

```bash
conda install python=3.7
```


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/desktop-lite/README.md
================================================

# Light-weight Desktop (desktop-lite)

Adds a lightweight Fluxbox based desktop to the container that can be accessed using a VNC viewer or the web. GUI-based commands executed from the built-in VS code terminal will open on the desktop automatically.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/desktop-lite:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Currently Unused! | string | latest |
| noVncVersion | The noVNC version to use | string | 1.2.0 |
| password | Enter a password for desktop connections. If "noPassword", connections from the local host can be established without entering a password | string | vscode |
| webPort | Enter a port for the VNC web client (noVNC) | string | 6080 |
| vncPort | Enter a port for the desktop VNC server (TigerVNC) | string | 5901 |

## Connecting to the desktop

This feature provides two ways of connecting to the desktop environment it adds. The first is to connect using a web browser. To do so:

1. Forward the noVNC port (`6080` by default) to your local machine using either the `forwardPorts` property in `devcontainer.json` or the user interface in your tool (e.g., you can press <kbd>F1</kbd> or <kbd>Ctrl/Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> and select **Ports: Focus on Ports View** in VS Code to bring it into focus).
1. Open the ports view in your tool, select the noVNC port, and click the Globe icon.
1. In the browser that appears, click the **Connect** button and enter the desktop password (`vscode` by default).

To set up the `6080` port from your `devcontainer.json` file, include the following:
```json
  "forwardPorts": [6080],
  "portsAttributes": {
    "6080": {
      "label": "desktop"
    }
  }
```

You can also connect to the desktop using a [VNC viewer](https://www.realvnc.com/en/connect/download/viewer/). To do so:

1. Connect to the environment from a desktop tool that supports the dev container spec (e.g., VS Code client).
1. Forward the VNC server port (`5901` by default) to your local machine using either the `forwardPorts` property in `devcontainer.json` or the user interface in your tool (e.g., you can press <kbd>F1</kbd> or <kbd>Ctrl/Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> and select **Ports: Focus on Ports View** in VS Code to bring it into focus). If you are using the [Dev Container CLI](https://github.com/devcontainers/cli), you should instead use the `appPort` property in `devcontainer.json`.
1. Start your VNC Viewer and connect to localhost:5901. Note that you may need to bump up the color depth to 24 bits to see full color.
1. Enter the desktop password (`vscode` by default).

## Customizing Fluxbox

The window manager installed is [Fluxbox](http://fluxbox.org/). **Right-click** to see the application menu. In addition, any UI-based commands you execute inside the dev container will automatically appear on the desktop.

You can customize the desktop using Fluxbox configuration files. The configuration files are located in the `.fluxbox` folder of the home directory of the user you using to connect to the dev container (`$HOME/.fluxbox`).

If you add custom content to your base image or a Dockerfile in this location, the Feature will automatically use it rather than its default configuration.

See the [Fluxbox menu documentation](http://www.fluxbox.org/help/man-fluxbox-menu.php) for format details. More information on additional customization can be found in Fluxbox's [help](http://www.fluxbox.org/help/) and [general](http://fluxbox.sourceforge.net/docbook/en/html/book1.html) documentation.

## Resolving crashes

If you run into applications crashing, you may need to increase the size of the shared memory space allocated to your container. For example, this will bump it up to 1 GB in `devcontainer.json`:

```json
"runArgs": ["--shm-size=1g"]
```

Or using Docker Compose:

```yaml
services:
  your-service-here:
    # ...
    shm_size: '1gb'
    # ...
```

## Installing a browser

If you need a browser, you can install **Firefox ESR** by adding the following to `.devcontainer/Dockerfile`:

```Dockerfile
RUN apt-get update && export DEBIAN_FRONTEND=noninteractive && apt-get install -y firefox-esr
```

If you want the full version of **Google Chrome** in the desktop:

1. Add the following to `.devcontainer/Dockerfile`

    ```Dockerfile
    RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \
        && curl -sSL https://dl.google.com/linux/direct/google-chrome-stable_current_$(dpkg --print-architecture).deb -o /tmp/chrome.deb \
        && apt-get -y install /tmp/chrome.deb
    ```

2. Chrome sandbox support requires you set up and run as a non-root user. The [`common-utils`](https://github.com/devcontainers/features/tree/main/src/common-utils) script can do this for you, or you [set one up yourself](https://aka.ms/vscode-remote/containers/non-root). Alternatively, you can start Chrome using `google-chrome --no-sandbox`

That's it!


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/desktop-lite/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/desktop-lite/devcontainer-feature.json
================================================
{
    "id": "desktop-lite",
    "version": "1.2.8",
    "name": "Light-weight Desktop",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/desktop-lite",
    "description": "Adds a lightweight Fluxbox based desktop to the container that can be accessed using a VNC viewer or the web. GUI-based commands executed from the built-in VS code terminal will open on the desktop automatically.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest"
            ],
            "default": "latest",
            "description": "Currently Unused!"
        },
        "noVncVersion": {
            "type": "string",
            "proposals": [
                "1.6.0"
            ],
            "default": "1.6.0",
            "description": "The noVNC version to use"
        },
        "password": {
            "type": "string",
            "proposals": [
                "vscode",
                "codespaces",
                "password",
                "noPassword"
            ],
            "default": "vscode",
            "description": "Enter a password for desktop connections. If \"noPassword\", connections from the local host can be established without entering a password"
        },
        "webPort": {
            "type": "string",
            "proposals": [
                "6080"
            ],
            "default": "6080",
            "description": "Enter a port for the VNC web client (noVNC)"
        },
        "vncPort": {
            "type": "string",
            "proposals": [
                "5901"
            ],
            "default": "5901",
            "description": "Enter a port for the desktop VNC server (TigerVNC)"
        }
    },
    "init": true,
    "entrypoint": "/usr/local/share/desktop-init.sh",
    "containerEnv": {
        "DISPLAY": ":1"
    },
    "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes a lightweight Fluxbox based desktop that can be accessed using a VNC viewer or the web. GUI-based commands executed from the built-in VS Code terminal will open on the desktop automatically."
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/desktop-lite/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/desktop-lite.md
# Maintainer: The VS Code and Codespaces Teams

NOVNC_VERSION="${NOVNCVERSION:-"1.6.0"}" # TODO: Add in a 'latest' auto-detect and swap name to 'version'
VNC_PASSWORD=${PASSWORD:-"vscode"}
if [ "$VNC_PASSWORD" = "noPassword" ]; then
    unset VNC_PASSWORD
fi
NOVNC_PORT="${WEBPORT:-6080}"
VNC_PORT="${VNCPORT:-5901}"

INSTALL_NOVNC="${INSTALL_NOVNC:-"true"}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"

WEBSOCKETIFY_VERSION=0.10.0

package_list="
    tigervnc-standalone-server \
    tigervnc-common \
    fluxbox \
    dbus-x11 \
    x11-utils \
    x11-xserver-utils \
    xdg-utils \
    fbautostart \
    at-spi2-core \
    xterm \
    nautilus\
    mousepad \
    seahorse \
    gnome-icon-theme \
    gnome-keyring \
    libx11-dev \
    libxkbfile-dev \
    libsecret-1-dev \
    libgbm-dev \
    libnotify4 \
    libnss3 \
    libxss1 \
    xfonts-base \
    xfonts-terminus \
    fonts-noto \
    fonts-wqy-microhei \
    fonts-droid-fallback \
    htop \
    ncdu \
    curl \
    ca-certificates\
    unzip \
    nano \
    locales"

# Packages to attempt to install if essential tools are missing (ie: vncpasswd).
# This is useful, at least, for Ubuntu 22.04 (jammy)
package_list_additional="
    tigervnc-tools"

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi
# Add default Fluxbox config files if none are already present
fluxbox_apps="$(cat \
<< 'EOF'
[transient] (role=GtkFileChooserDialog)
  [Dimensions]	{70% 70%}
  [Position]	(CENTER)	{0 0}
[end]
EOF
)"

fluxbox_init="$(cat \
<< 'EOF'
session.configVersion:	13
session.menuFile:	~/.fluxbox/menu
session.keyFile: ~/.fluxbox/keys
session.styleFile: /usr/share/fluxbox/styles/qnx-photon
session.screen0.workspaces: 1
session.screen0.workspacewarping: false
session.screen0.toolbar.widthPercent: 100
session.screen0.strftimeFormat: %a %l:%M %p
session.screen0.toolbar.tools: RootMenu, clock, iconbar, systemtray
session.screen0.workspaceNames: One,
EOF
)"

fluxbox_menu="$(cat \
<< 'EOF'
[begin] (  Application Menu  )
    [exec] (File Manager) { nautilus ~ } <>
    [exec] (Text Editor) { mousepad } <>
    [exec] (Terminal) { tilix -w ~ -e $(readlink -f /proc/$$/exe) -il } <>
    [exec] (Web Browser) { x-www-browser --disable-dev-shm-usage } <>
    [submenu] (System) {}
        [exec] (Set Resolution) { tilix -t "Set Resolution" -e bash /usr/local/bin/set-resolution } <>
        [exec] (Edit Application Menu) { mousepad ~/.fluxbox/menu } <>
        [exec] (Passwords and Keys) { seahorse } <>
        [exec] (Top Processes) { tilix -t "Top" -e htop } <>
        [exec] (Disk Utilization) { tilix -t "Disk Utilization" -e ncdu / } <>
        [exec] (Editres) {editres} <>
        [exec] (Xfontsel) {xfontsel} <>
        [exec] (Xkill) {xkill} <>
        [exec] (Xrefresh) {xrefresh} <>
    [end]
    [config] (Configuration)
    [workspaces] (Workspaces)
[end]
EOF
)"

# Copy config files if the don't already exist
copy_fluxbox_config() {
    local target_dir="$1"
    mkdir -p "${target_dir}/.fluxbox"
    touch "${target_dir}/.Xmodmap"
    if [ ! -e "${target_dir}/.fluxbox/apps" ]; then
        echo "${fluxbox_apps}" > "${target_dir}/.fluxbox/apps"
    fi
    if [ ! -e "${target_dir}/.fluxbox/init" ]; then
        echo "${fluxbox_init}" > "${target_dir}/.fluxbox/init"
    fi
    if [ ! -e "${target_dir}/.fluxbox/menu" ]; then
        echo "${fluxbox_menu}" > "${target_dir}/.fluxbox/menu"
    fi
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

##########################
#  Install starts here   #
##########################

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive

apt_get_update

# On older Ubuntu, Tilix is in a PPA. on Debian stretch its in backports.
if [[ -z $(apt-cache --names-only search ^tilix$) ]]; then
    . /etc/os-release
    if [ "${ID}" = "ubuntu" ]; then
        check_packages apt-transport-https software-properties-common
        add-apt-repository -y ppa:webupd8team/terminix
    elif [ "${VERSION_CODENAME}" = "stretch" ]; then
        echo "deb http://deb.debian.org/debian stretch-backports main" > /etc/apt/sources.list.d/stretch-backports.list
    fi
    apt-get update
    if [[ -z $(apt-cache --names-only search ^tilix$) ]]; then
        echo "(!) WARNING: Tilix not available on ${ID} ${VERSION_CODENAME} architecture $(uname -m). Skipping."
    else
        package_list="${package_list} tilix"
    fi
else
    package_list="${package_list} tilix"
fi

# Install X11, fluxbox and VS Code dependencies
check_packages ${package_list}

# if Ubuntu-24.04, noble(numbat) / Debian-13, trixie found, then will install libasound2-dev instead of libasound2.
# this change is temporary, https://packages.ubuntu.com/noble/libasound2 will switch to libasound2 once it is available for Ubuntu-24.04, noble(numbat)
. /etc/os-release
if { [ "${ID}" = "ubuntu" ] && [ "${VERSION_CODENAME}" = "noble" ]; } || { [ "${ID}" = "debian" ] && [ "${VERSION_CODENAME}" = "trixie" ]; }; then
    echo "Detected Noble (Ubuntu 24.04) or Trixie (Debian). Installing libasound2-dev package..."
    check_packages "libasound2-dev"
else
    check_packages "libasound2"
fi

# On newer versions of Ubuntu (22.04), 
# we need an additional package that isn't provided in earlier versions
if ! type vncpasswd > /dev/null 2>&1; then
    check_packages ${package_list_additional}
fi

# Install Emoji font if available in distro - Available in Debian 10+, Ubuntu 18.04+
if dpkg-query -W fonts-noto-color-emoji > /dev/null 2>&1 && ! dpkg -s fonts-noto-color-emoji > /dev/null 2>&1; then
    apt-get -y install --no-install-recommends fonts-noto-color-emoji
fi

# Check at least one locale exists
if ! grep -o -E '^\s*en_US.UTF-8\s+UTF-8' /etc/locale.gen > /dev/null; then
    echo "en_US.UTF-8 UTF-8" >> /etc/locale.gen
    locale-gen
fi

# Install the Cascadia Code fonts - https://github.com/microsoft/cascadia-code
if [ ! -d "/usr/share/fonts/truetype/cascadia" ]; then
    curl -sSL https://github.com/microsoft/cascadia-code/releases/download/v2008.25/CascadiaCode-2008.25.zip -o /tmp/cascadia-fonts.zip
    unzip /tmp/cascadia-fonts.zip -d /tmp/cascadia-fonts
    mkdir -p /usr/share/fonts/truetype/cascadia
    mv /tmp/cascadia-fonts/ttf/* /usr/share/fonts/truetype/cascadia/
    rm -rf /tmp/cascadia-fonts.zip /tmp/cascadia-fonts
fi

# Install noVNC
if [ "${INSTALL_NOVNC}" = "true" ] && [ ! -d "/usr/local/novnc" ]; then
    mkdir -p /usr/local/novnc
    curl -sSL https://github.com/novnc/noVNC/archive/v${NOVNC_VERSION}.zip -o /tmp/novnc-install.zip
    unzip /tmp/novnc-install.zip -d /usr/local/novnc
    cp /usr/local/novnc/noVNC-${NOVNC_VERSION}/vnc.html /usr/local/novnc/noVNC-${NOVNC_VERSION}/index.html
    curl -sSL https://github.com/novnc/websockify/archive/v${WEBSOCKETIFY_VERSION}.zip -o /tmp/websockify-install.zip
    unzip /tmp/websockify-install.zip -d /usr/local/novnc
    ln -s /usr/local/novnc/websockify-${WEBSOCKETIFY_VERSION} /usr/local/novnc/noVNC-${NOVNC_VERSION}/utils/websockify
    rm -f /tmp/websockify-install.zip /tmp/novnc-install.zip

    # Install noVNC dependencies and use them.
    check_packages python3-minimal python3-numpy
    sed -i -E 's/^python /python3 /' /usr/local/novnc/websockify-${WEBSOCKETIFY_VERSION}/run
fi

# Set up folders for scripts and init files
mkdir -p /var/run/dbus /usr/local/etc/vscode-dev-containers/

# Script to change resolution of desktop
cat << EOF > /usr/local/bin/set-resolution
#!/bin/bash
RESOLUTION=\${1:-\${VNC_RESOLUTION:-1920x1080}}
DPI=\${2:-\${VNC_DPI:-96}}
IGNORE_ERROR=\${3:-"false"}
if [ -z "\$1" ]; then
    echo -e "**Current Settings **\n"
    xrandr
    echo -n -e "\nEnter new resolution (WIDTHxHEIGHT, blank for \${RESOLUTION}, Ctrl+C to abort).\n> "
    read NEW_RES
    if [ "\${NEW_RES}" != "" ]; then
        RESOLUTION=\${NEW_RES}
    fi
    if ! echo "\${RESOLUTION}" | grep -E '[0-9]+x[0-9]+' > /dev/null; then
        echo -e "\nInvalid resolution format!\n"
        exit 1
    fi
    if [ -z "\$2" ]; then
        echo -n -e "\nEnter new DPI (blank for \${DPI}, Ctrl+C to abort).\n> "
        read NEW_DPI
        if [ "\${NEW_DPI}" != "" ]; then
            DPI=\${NEW_DPI}
        fi
    fi
fi

xrandr --fb \${RESOLUTION} --dpi \${DPI} > /dev/null 2>&1

if [ \$? -ne 0 ] && [ "\${IGNORE_ERROR}" != "true" ]; then
    echo -e "\nFAILED TO SET RESOLUTION!\n"
    exit 1
fi

echo -e "\nSuccess!\n"
EOF

# Container ENTRYPOINT script
cat << EOF > /usr/local/share/desktop-init.sh
#!/bin/bash

user_name="${USERNAME}"
group_name="$(id -gn ${USERNAME})"
LOG=/tmp/container-init.log

export DBUS_SESSION_BUS_ADDRESS="\${DBUS_SESSION_BUS_ADDRESS:-"autolaunch:"}"
export DISPLAY="\${DISPLAY:-:1}"
export VNC_RESOLUTION="\${VNC_RESOLUTION:-1440x768x16}" 
export LANG="\${LANG:-"en_US.UTF-8"}"
export LANGUAGE="\${LANGUAGE:-"en_US.UTF-8"}"

# Execute the command it not already running
startInBackgroundIfNotRunning()
{
    log "Starting \$1."
    echo -e "\n** \$(date) **" | sudoIf tee -a /tmp/\$1.log > /dev/null
    if ! pgrep -x \$1 > /dev/null; then
        keepRunningInBackground "\$@"
        while ! pgrep -x \$1 > /dev/null; do
            sleep 1
        done
        log "\$1 started."
    else
        echo "\$1 is already running." | sudoIf tee -a /tmp/\$1.log > /dev/null
        log "\$1 is already running."
    fi
}

# Keep command running in background
keepRunningInBackground()
{
    (\$2 bash -c "while :; do echo [\\\$(date)] Process started.; \$3; echo [\\\$(date)] Process exited!; sleep 5; done 2>&1" | sudoIf tee -a /tmp/\$1.log > /dev/null & echo "\$!" | sudoIf tee /tmp/\$1.pid > /dev/null)
}

# Use sudo to run as root when required
sudoIf()
{
    if [ "\$(id -u)" -ne 0 ]; then
        sudo "\$@"
    else
        "\$@"
    fi
}

# Use sudo to run as non-root user if not already running
sudoUserIf()
{
    if [ "\$(id -u)" -eq 0 ] && [ "\${user_name}" != "root" ]; then
        sudo -u \${user_name} "\$@"
    else
        "\$@"
    fi
}

# Log messages
log()
{
    echo -e "[\$(date)] \$@" | sudoIf tee -a \$LOG > /dev/null
}

# Function to compare versions
version_gt() {
    # returns 0 if \$1 > \$2
    [ "\$(printf '%s\n' "\$2" "\$1" | sort -V | head -n1)" != "\$1" ]
}


log "** SCRIPT START **"

# Start dbus.
log 'Running "/etc/init.d/dbus start".'
if [ -f "/var/run/dbus/pid" ] && ! pgrep -x dbus-daemon  > /dev/null; then
    sudoIf rm -f /var/run/dbus/pid
fi
sudoIf /etc/init.d/dbus start 2>&1 | sudoIf tee -a /tmp/dbus-daemon-system.log > /dev/null
while ! pgrep -x dbus-daemon > /dev/null; do
    sleep 1
done

# Startup tigervnc server and fluxbox
sudoIf rm -rf /tmp/.X11-unix /tmp/.X*-lock
mkdir -p /tmp/.X11-unix
sudoIf chmod 1777 /tmp/.X11-unix
sudoIf chown root:\${group_name} /tmp/.X11-unix
if [ "\$(echo "\${VNC_RESOLUTION}" | tr -cd 'x' | wc -c)" = "1" ]; then VNC_RESOLUTION=\${VNC_RESOLUTION}x16; fi
screen_geometry="\${VNC_RESOLUTION%*x*}"
screen_depth="\${VNC_RESOLUTION##*x}"

# Check if VNC_PASSWORD is set and use the appropriate command
common_options="tigervncserver \${DISPLAY} -geometry \${screen_geometry} -depth \${screen_depth} -rfbport ${VNC_PORT} -dpi \${VNC_DPI:-96} -localhost -desktop fluxbox -fg"

if [ -n "\${VNC_PASSWORD+x}" ]; then
    startInBackgroundIfNotRunning "Xtigervnc" sudoUserIf "\${common_options} -passwd /usr/local/etc/vscode-dev-containers/vnc-passwd"
else
    startInBackgroundIfNotRunning "Xtigervnc" sudoUserIf "\${common_options} -SecurityTypes None"
fi

# Spin up noVNC if installed and not running.
if [ -d "/usr/local/novnc" ]; then
    if [ "\$(ps -ef | grep /usr/local/novnc/noVNC*/utils/launch.sh | grep -v grep)" = "" ] && [ "\$(ps -ef | grep /usr/local/novnc/noVNC*/utils/novnc_proxy | grep -v grep)" = "" ]; then
        if version_gt "${NOVNC_VERSION}" "1.2.0"; then
            keepRunningInBackground "noVNC" sudoIf "/usr/local/novnc/noVNC*/utils/novnc_proxy --listen ${NOVNC_PORT} --vnc localhost:${VNC_PORT}"
            log "noVNC started with novnc_proxy."
        else
            keepRunningInBackground "noVNC" sudoIf "/usr/local/novnc/noVNC*/utils/launch.sh --listen ${NOVNC_PORT} --vnc localhost:${VNC_PORT}"
            log "noVNC started with launch.sh."
        fi
    else
        log "noVNC is already running."
    fi
else
    log "noVNC is not installed."
fi

# Run whatever was passed in
if [ -n "$1" ]; then
    log "Executing \"\$@\"."
    exec "$@"
else
    log "No command provided to execute."
fi
log "** SCRIPT EXIT **"
EOF

if [ -n "${VNC_PASSWORD+x}" ]; then
    echo "${VNC_PASSWORD}" | vncpasswd -f > /usr/local/etc/vscode-dev-containers/vnc-passwd
fi
chmod +x /usr/local/share/desktop-init.sh /usr/local/bin/set-resolution

# Set up fluxbox config
copy_fluxbox_config "/root"
if [ "${USERNAME}" != "root" ]; then
    copy_fluxbox_config "/home/${USERNAME}"
    chown -R ${USERNAME} /home/${USERNAME}/.Xmodmap /home/${USERNAME}/.fluxbox
fi

# Clean up
rm -rf /var/lib/apt/lists/*

# Determine the message based on whether VNC_PASSWORD is set
if [ -n "${VNC_PASSWORD+x}" ]; then
    PASSWORD_MESSAGE="In both cases, use the password \"${VNC_PASSWORD}\" when connecting"
else
    PASSWORD_MESSAGE="In both cases, no password is required."
fi

# Display the message
cat << EOF


You now have a working desktop! Connect to in one of the following ways:

- Forward port ${NOVNC_PORT} and use a web browser to start the noVNC client (recommended)
- Forward port ${VNC_PORT} using VS Code client and connect using a VNC Viewer

${PASSWORD_MESSAGE}

(*) Done!

EOF



================================================
FILE: src/desktop-lite/NOTES.md
================================================
## Connecting to the desktop

This feature provides two ways of connecting to the desktop environment it adds. The first is to connect using a web browser. To do so:

1. Forward the noVNC port (`6080` by default) to your local machine using either the `forwardPorts` property in `devcontainer.json` or the user interface in your tool (e.g., you can press <kbd>F1</kbd> or <kbd>Ctrl/Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> and select **Ports: Focus on Ports View** in VS Code to bring it into focus).
1. Open the ports view in your tool, select the noVNC port, and click the Globe icon.
1. In the browser that appears, click the **Connect** button and enter the desktop password (`vscode` by default).

To set up the `6080` port from your `devcontainer.json` file, include the following:
```json
  "forwardPorts": [6080],
  "portsAttributes": {
    "6080": {
      "label": "desktop"
    }
  }
```

You can also connect to the desktop using a [VNC viewer](https://www.realvnc.com/en/connect/download/viewer/). To do so:

1. Connect to the environment from a desktop tool that supports the dev container spec (e.g., VS Code client).
1. Forward the VNC server port (`5901` by default) to your local machine using either the `forwardPorts` property in `devcontainer.json` or the user interface in your tool (e.g., you can press <kbd>F1</kbd> or <kbd>Ctrl/Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> and select **Ports: Focus on Ports View** in VS Code to bring it into focus). If you are using the [Dev Container CLI](https://github.com/devcontainers/cli), you should instead use the `appPort` property in `devcontainer.json`.
1. Start your VNC Viewer and connect to localhost:5901. Note that you may need to bump up the color depth to 24 bits to see full color.
1. Enter the desktop password (`vscode` by default).

## Customizing Fluxbox

The window manager installed is [Fluxbox](http://fluxbox.org/). **Right-click** to see the application menu. In addition, any UI-based commands you execute inside the dev container will automatically appear on the desktop.

You can customize the desktop using Fluxbox configuration files. The configuration files are located in the `.fluxbox` folder of the home directory of the user you using to connect to the dev container (`$HOME/.fluxbox`).

If you add custom content to your base image or a Dockerfile in this location, the Feature will automatically use it rather than its default configuration.

See the [Fluxbox menu documentation](http://www.fluxbox.org/help/man-fluxbox-menu.php) for format details. More information on additional customization can be found in Fluxbox's [help](http://www.fluxbox.org/help/) and [general](http://fluxbox.sourceforge.net/docbook/en/html/book1.html) documentation.

## Resolving crashes

If you run into applications crashing, you may need to increase the size of the shared memory space allocated to your container. For example, this will bump it up to 1 GB in `devcontainer.json`:

```json
"runArgs": ["--shm-size=1g"]
```

Or using Docker Compose:

```yaml
services:
  your-service-here:
    # ...
    shm_size: '1gb'
    # ...
```

## Installing a browser

If you need a browser, you can install **Firefox ESR** by adding the following to `.devcontainer/Dockerfile`:

```Dockerfile
RUN apt-get update && export DEBIAN_FRONTEND=noninteractive && apt-get install -y firefox-esr
```

If you want the full version of **Google Chrome** in the desktop:

1. Add the following to `.devcontainer/Dockerfile`

    ```Dockerfile
    RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \
        && curl -sSL https://dl.google.com/linux/direct/google-chrome-stable_current_$(dpkg --print-architecture).deb -o /tmp/chrome.deb \
        && apt-get -y install /tmp/chrome.deb
    ```

2. Chrome sandbox support requires you set up and run as a non-root user. The [`common-utils`](https://github.com/devcontainers/features/tree/main/src/common-utils) script can do this for you, or you [set one up yourself](https://aka.ms/vscode-remote/containers/non-root). Alternatively, you can start Chrome using `google-chrome --no-sandbox`

That's it!


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/docker-in-docker/README.md
================================================

# Docker (Docker-in-Docker) (docker-in-docker)

Create child containers *inside* a container, independent from the host's docker instance. Installs Docker extension in the container along with needed CLIs.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a Docker/Moby Engine version. (Availability can vary by OS version.) | string | latest |
| moby | Install OSS Moby build instead of Docker CE | boolean | true |
| mobyBuildxVersion | Install a specific version of moby-buildx when using Moby | string | latest |
| dockerDashComposeVersion | Default version of Docker Compose (v1, v2 or none) | string | v2 |
| azureDnsAutoDetection | Allow automatically setting the dockerd DNS server when the installation script detects it is running in Azure | boolean | true |
| dockerDefaultAddressPool | Define default address pools for Docker networks. e.g. base=192.168.0.0/16,size=24 | string | - |
| installDockerBuildx | Install Docker Buildx | boolean | true |
| installDockerComposeSwitch | Install Compose Switch (provided docker compose is available) which is a replacement to the Compose V1 docker-compose (python) executable. It translates the command line into Compose V2 docker compose then runs the latter. | boolean | true |
| disableIp6tables | Disable ip6tables (this option is only applicable for Docker versions 27 and greater) | boolean | false |

## Customizations

### VS Code Extensions

- `ms-azuretools.vscode-containers`

## Limitations

This docker-in-docker Dev Container Feature is roughly based on the [official docker-in-docker wrapper script](https://github.com/moby/moby/blob/master/hack/dind) that is part of the [Moby project](https://mobyproject.org/). With this in mind:
* As the name implies, the Feature is expected to work when the host is running Docker (or the OSS Moby container engine it is built on). It may be possible to get running in other container engines, but it has not been tested with them.
* The host and the container must be running on the same chip architecture. You will not be able to use it with an emulated x86 image with Docker Desktop on an Apple Silicon Mac, like in this example:
  ```
  FROM --platform=linux/amd64 mcr.microsoft.com/devcontainers/typescript-node:16
  ```
  See [Issue #219](https://github.com/devcontainers/features/issues/219) for more details.


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/docker-in-docker/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/docker-in-docker/devcontainer-feature.json
================================================
{
    "id": "docker-in-docker",
    "version": "2.12.4",
    "name": "Docker (Docker-in-Docker)",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/docker-in-docker",
    "description": "Create child containers *inside* a container, independent from the host's docker instance. Installs Docker extension in the container along with needed CLIs.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "none",
                "20.10"
            ],
            "default": "latest",
            "description": "Select or enter a Docker/Moby Engine version. (Availability can vary by OS version.)"
        },
        "moby": {
            "type": "boolean",
            "default": true,
            "description": "Install OSS Moby build instead of Docker CE"
        },
        "mobyBuildxVersion": {
            "type": "string",
            "default": "latest",
            "description": "Install a specific version of moby-buildx when using Moby"
        },
        "dockerDashComposeVersion": {
            "type": "string",
            "enum": [
                "none",
                "v1",
                "v2"
            ],
            "default": "v2",
            "description": "Default version of Docker Compose (v1, v2 or none)"
        },
        "azureDnsAutoDetection": {
            "type": "boolean",
            "default": true,
            "description": "Allow automatically setting the dockerd DNS server when the installation script detects it is running in Azure"
        },
        "dockerDefaultAddressPool": {
            "type": "string",
            "default": "",
            "proposals": [],
            "description": "Define default address pools for Docker networks. e.g. base=192.168.0.0/16,size=24"
        },
        "installDockerBuildx": {
            "type": "boolean",
            "default": true,
            "description": "Install Docker Buildx"
        },
        "installDockerComposeSwitch": {
            "type": "boolean",
            "default": true,
            "description": "Install Compose Switch (provided docker compose is available) which is a replacement to the Compose V1 docker-compose (python) executable. It translates the command line into Compose V2 docker compose then runs the latter."
        },
        "disableIp6tables": {
            "type": "boolean",
            "default": false,
            "description": "Disable ip6tables (this option is only applicable for Docker versions 27 and greater)"
        }
    },
    "entrypoint": "/usr/local/share/docker-init.sh",
    "privileged": true,
    "containerEnv": {
        "DOCKER_BUILDKIT": "1"
    },
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-azuretools.vscode-containers"
            ],
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes the Docker CLI (`docker`) pre-installed and available on the `PATH` for running and managing containers using a dedicated Docker daemon running inside the dev container."
                    }
                ]
            }
        }
    },
    "mounts": [
        {
            "source": "dind-var-lib-docker-${devcontainerId}",
            "target": "/var/lib/docker",
            "type": "volume"
        }
    ],
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/docker-in-docker/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/docker-in-docker.md
# Maintainer: The Dev Container spec maintainers


DOCKER_VERSION="${VERSION:-"latest"}" # The Docker/Moby Engine + CLI should match in version
USE_MOBY="${MOBY:-"true"}"
MOBY_BUILDX_VERSION="${MOBYBUILDXVERSION:-"latest"}"
DOCKER_DASH_COMPOSE_VERSION="${DOCKERDASHCOMPOSEVERSION:-"v2"}" #v1, v2 or none
AZURE_DNS_AUTO_DETECTION="${AZUREDNSAUTODETECTION:-"true"}"
DOCKER_DEFAULT_ADDRESS_POOL="${DOCKERDEFAULTADDRESSPOOL:-""}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
INSTALL_DOCKER_BUILDX="${INSTALLDOCKERBUILDX:-"true"}"
INSTALL_DOCKER_COMPOSE_SWITCH="${INSTALLDOCKERCOMPOSESWITCH:-"true"}"
MICROSOFT_GPG_KEYS_URI="https://packages.microsoft.com/keys/microsoft.asc"
MICROSOFT_GPG_KEYS_ROLLING_URI="https://packages.microsoft.com/keys/microsoft-rolling.asc"
DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES="trixie bookworm buster bullseye bionic focal jammy noble"
DOCKER_LICENSED_ARCHIVE_VERSION_CODENAMES="trixie bookworm buster bullseye bionic focal hirsute impish jammy noble"
DISABLE_IP6_TABLES="${DISABLEIP6TABLES:-false}"

# Default: Exit on any failure.
set -e

# Clean up
rm -rf /var/lib/apt/lists/*

# Setup STDERR.
err() {
    echo "(!) $*" >&2
}

if [ "$(id -u)" -ne 0 ]; then
    err 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

###################
# Helper Functions
# See: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/shared/utils.sh
###################

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
                declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        err "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    prev_version=${!variable_name}

    output=$(curl -s "$repo_url");
    if echo "$output" | jq -e 'type == "object"' > /dev/null; then
      message=$(echo "$output" | jq -r '.message')
      
      if [[ $message == "API rate limit exceeded"* ]]; then
            echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
            echo -e "\nAttempting to find latest version using GitHub tags."
            find_prev_version_from_git_tags prev_version "$url" "tags/v"
            declare -g ${variable_name}="${prev_version}"
       fi
    elif echo "$output" | jq -e 'type == "array"' > /dev/null; then 
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.[1].tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases"
}

###########################################
# Start docker-in-docker installation
###########################################

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive


# Source /etc/os-release to get OS info
. /etc/os-release
# Fetch host/container arch.
architecture="$(dpkg --print-architecture)"

# Prevent attempting to install Moby on Debian trixie (packages removed)
if [ "${USE_MOBY}" = "true" ] && [ "${ID}" = "debian" ] && [ "${VERSION_CODENAME}" = "trixie" ]; then
    err "The 'moby' option is not supported on Debian 'trixie' because 'moby-cli' and related system packages have been removed from that distribution."
    err "To continue, either set the feature option '\"moby\": false' or use a different base image (for example: 'debian:bookworm' or 'ubuntu-24.04')."
    exit 1
fi

# Check if distro is supported
if [ "${USE_MOBY}" = "true" ]; then
    if [[ "${DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES}" != *"${VERSION_CODENAME}"* ]]; then
        err "Unsupported  distribution version '${VERSION_CODENAME}'. To resolve, either: (1) set feature option '\"moby\": false' , or (2) choose a compatible OS distribution"
        err "Supported distributions include:  ${DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES}"
        exit 1
    fi
    echo "Distro codename  '${VERSION_CODENAME}'  matched filter  '${DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES}'"
else
    if [[ "${DOCKER_LICENSED_ARCHIVE_VERSION_CODENAMES}" != *"${VERSION_CODENAME}"* ]]; then
        err "Unsupported distribution version '${VERSION_CODENAME}'. To resolve, please choose a compatible OS distribution"
        err "Supported distributions include:  ${DOCKER_LICENSED_ARCHIVE_VERSION_CODENAMES}"
        exit 1
    fi
    echo "Distro codename  '${VERSION_CODENAME}'  matched filter  '${DOCKER_LICENSED_ARCHIVE_VERSION_CODENAMES}'"
fi

# Install dependencies
check_packages apt-transport-https curl ca-certificates pigz iptables gnupg2 dirmngr wget jq
if ! type git > /dev/null 2>&1; then
    check_packages git
fi

# Swap to legacy iptables for compatibility
if type iptables-legacy > /dev/null 2>&1; then
    update-alternatives --set iptables /usr/sbin/iptables-legacy
    update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy
fi



# Set up the necessary apt repos (either Microsoft's or Docker's)
if [ "${USE_MOBY}" = "true" ]; then

    # Name of open source engine/cli
    engine_package_name="moby-engine"
    cli_package_name="moby-cli"

    # Import key safely and import Microsoft apt repo
    {
        curl -sSL ${MICROSOFT_GPG_KEYS_URI}
        curl -sSL ${MICROSOFT_GPG_KEYS_ROLLING_URI}
    } | gpg --dearmor > /usr/share/keyrings/microsoft-archive-keyring.gpg
    echo "deb [arch=${architecture} signed-by=/usr/share/keyrings/microsoft-archive-keyring.gpg] https://packages.microsoft.com/repos/microsoft-${ID}-${VERSION_CODENAME}-prod ${VERSION_CODENAME} main" > /etc/apt/sources.list.d/microsoft.list
else
    # Name of licensed engine/cli
    engine_package_name="docker-ce"
    cli_package_name="docker-ce-cli"

    # Import key safely and import Docker apt repo
    curl -fsSL https://download.docker.com/linux/${ID}/gpg | gpg --dearmor > /usr/share/keyrings/docker-archive-keyring.gpg
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/${ID} ${VERSION_CODENAME} stable" > /etc/apt/sources.list.d/docker.list
fi

# Refresh apt lists
apt-get update

# Soft version matching
if [ "${DOCKER_VERSION}" = "latest" ] || [ "${DOCKER_VERSION}" = "lts" ] || [ "${DOCKER_VERSION}" = "stable" ]; then
    # Empty, meaning grab whatever "latest" is in apt repo
    engine_version_suffix=""
    cli_version_suffix=""
else
    # Fetch a valid version from the apt-cache (eg: the Microsoft repo appends +azure, breakfix, etc...)
    docker_version_dot_escaped="${DOCKER_VERSION//./\\.}"
    docker_version_dot_plus_escaped="${docker_version_dot_escaped//+/\\+}"
    # Regex needs to handle debian package version number format: https://www.systutorials.com/docs/linux/man/5-deb-version/
    docker_version_regex="^(.+:)?${docker_version_dot_plus_escaped}([\\.\\+ ~:-]|$)"
    set +e # Don't exit if finding version fails - will handle gracefully
        cli_version_suffix="=$(apt-cache madison ${cli_package_name} | awk -F"|" '{print $2}' | sed -e 's/^[ \t]*//' | grep -E -m 1 "${docker_version_regex}")"
        engine_version_suffix="=$(apt-cache madison ${engine_package_name} | awk -F"|" '{print $2}' | sed -e 's/^[ \t]*//' | grep -E -m 1 "${docker_version_regex}")"
    set -e
    if [ -z "${engine_version_suffix}" ] || [ "${engine_version_suffix}" = "=" ] || [ -z "${cli_version_suffix}" ] || [ "${cli_version_suffix}" = "=" ] ; then
        err "No full or partial Docker / Moby version match found for \"${DOCKER_VERSION}\" on OS ${ID} ${VERSION_CODENAME} (${architecture}). Available versions:"
        apt-cache madison ${cli_package_name} | awk -F"|" '{print $2}' | grep -oP '^(.+:)?\K.+'
        exit 1
    fi
    echo "engine_version_suffix ${engine_version_suffix}"
    echo "cli_version_suffix ${cli_version_suffix}"
fi

# Version matching for moby-buildx
if [ "${USE_MOBY}" = "true" ]; then
    if [ "${MOBY_BUILDX_VERSION}" = "latest" ]; then
        # Empty, meaning grab whatever "latest" is in apt repo
        buildx_version_suffix=""
    else
        buildx_version_dot_escaped="${MOBY_BUILDX_VERSION//./\\.}"
        buildx_version_dot_plus_escaped="${buildx_version_dot_escaped//+/\\+}"
        buildx_version_regex="^(.+:)?${buildx_version_dot_plus_escaped}([\\.\\+ ~:-]|$)"
        set +e
            buildx_version_suffix="=$(apt-cache madison moby-buildx | awk -F"|" '{print $2}' | sed -e 's/^[ \t]*//' | grep -E -m 1 "${buildx_version_regex}")"
        set -e
        if [ -z "${buildx_version_suffix}" ] || [ "${buildx_version_suffix}" = "=" ]; then
            err "No full or partial moby-buildx version match found for \"${MOBY_BUILDX_VERSION}\" on OS ${ID} ${VERSION_CODENAME} (${architecture}). Available versions:"
            apt-cache madison moby-buildx | awk -F"|" '{print $2}' | grep -oP '^(.+:)?\K.+'
            exit 1
        fi
        echo "buildx_version_suffix ${buildx_version_suffix}"
    fi
fi

# Install Docker / Moby CLI if not already installed
if type docker > /dev/null 2>&1 && type dockerd > /dev/null 2>&1; then
    echo "Docker / Moby CLI and Engine already installed."
else
    if [ "${USE_MOBY}" = "true" ]; then
        # Install engine
        set +e # Handle error gracefully
            apt-get -y install --no-install-recommends moby-cli${cli_version_suffix} moby-buildx${buildx_version_suffix} moby-engine${engine_version_suffix}
            exit_code=$?
        set -e    
        
        if [ ${exit_code} -ne 0 ]; then
            err "Packages for moby not available in OS ${ID} ${VERSION_CODENAME} (${architecture}). To resolve, either: (1) set feature option '\"moby\": false' , or (2) choose a compatible OS version (eg: 'ubuntu-24.04')."
            exit 1
        fi

        # Install compose
        apt-get -y install --no-install-recommends moby-compose || err "Package moby-compose (Docker Compose v2) not available for OS ${ID} ${VERSION_CODENAME} (${architecture}). Skipping."
    else
        apt-get -y install --no-install-recommends docker-ce-cli${cli_version_suffix} docker-ce${engine_version_suffix}
        # Install compose
        apt-mark hold docker-ce docker-ce-cli
        apt-get -y install --no-install-recommends docker-compose-plugin || echo "(*) Package docker-compose-plugin (Docker Compose v2) not available for OS ${ID} ${VERSION_CODENAME} (${architecture}). Skipping."
    fi
fi

echo "Finished installing docker / moby!"

docker_home="/usr/libexec/docker"
cli_plugins_dir="${docker_home}/cli-plugins"

# fallback for docker-compose
fallback_compose(){
    local url=$1
    local repo_url=$(get_github_api_repo_url "$url")
    echo -e "\n(!) Failed to fetch the latest artifacts for docker-compose v${compose_version}..."
    get_previous_version "${url}" "${repo_url}" compose_version
    echo -e "\nAttempting to install v${compose_version}"
    curl -fsSL "https://github.com/docker/compose/releases/download/v${compose_version}/docker-compose-linux-${target_compose_arch}" -o ${docker_compose_path}
}

# If 'docker-compose' command is to be included
if [ "${DOCKER_DASH_COMPOSE_VERSION}" != "none" ]; then
    case "${architecture}" in
        amd64) target_compose_arch=x86_64 ;;
        arm64) target_compose_arch=aarch64 ;;
        *)
            echo "(!) Docker in docker does not support machine architecture '$architecture'. Please use an x86-64 or ARM64 machine."
            exit 1
    esac

    docker_compose_path="/usr/local/bin/docker-compose"
    if [ "${DOCKER_DASH_COMPOSE_VERSION}" = "v1" ]; then
        err "The final Compose V1 release, version 1.29.2, was May 10, 2021. These packages haven't received any security updates since then. Use at your own risk."
        INSTALL_DOCKER_COMPOSE_SWITCH="false"

        if [ "${target_compose_arch}" = "x86_64" ]; then
            echo "(*) Installing docker compose v1..."
            curl -fsSL "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64" -o ${docker_compose_path}
            chmod +x ${docker_compose_path}

            # Download the SHA256 checksum
            DOCKER_COMPOSE_SHA256="$(curl -sSL "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64.sha256" | awk '{print $1}')"
            echo "${DOCKER_COMPOSE_SHA256}  ${docker_compose_path}" > docker-compose.sha256sum
            sha256sum -c docker-compose.sha256sum --ignore-missing
        elif [ "${VERSION_CODENAME}" = "bookworm" ]; then
            err "Docker compose v1 is unavailable for 'bookworm' on Arm64. Kindly switch to use v2"
            exit 1
        else
            # Use pip to get a version that runs on this architecture
            check_packages python3-minimal python3-pip libffi-dev python3-venv
            echo "(*) Installing docker compose v1 via pip..."
            export PYTHONUSERBASE=/usr/local
            pip3 install --disable-pip-version-check --no-cache-dir --user "Cython<3.0" pyyaml wheel docker-compose --no-build-isolation
        fi
    else
        compose_version=${DOCKER_DASH_COMPOSE_VERSION#v}
        docker_compose_url="https://github.com/docker/compose"
        find_version_from_git_tags compose_version "$docker_compose_url" "tags/v"
        echo "(*) Installing docker-compose ${compose_version}..."
        curl -fsSL "https://github.com/docker/compose/releases/download/v${compose_version}/docker-compose-linux-${target_compose_arch}" -o ${docker_compose_path} || {
                 echo -e "\n(!) Failed to fetch the latest artifacts for docker-compose v${compose_version}..." 
                 fallback_compose "$docker_compose_url"
        }

        chmod +x ${docker_compose_path}

        # Download the SHA256 checksum
        DOCKER_COMPOSE_SHA256="$(curl -sSL "https://github.com/docker/compose/releases/download/v${compose_version}/docker-compose-linux-${target_compose_arch}.sha256" | awk '{print $1}')"
        echo "${DOCKER_COMPOSE_SHA256}  ${docker_compose_path}" > docker-compose.sha256sum
        sha256sum -c docker-compose.sha256sum --ignore-missing

        mkdir -p ${cli_plugins_dir}
        cp ${docker_compose_path} ${cli_plugins_dir}
    fi
fi

# fallback method for compose-switch
fallback_compose-switch() {
    local url=$1
    local repo_url=$(get_github_api_repo_url "$url")
    echo -e "\n(!) Failed to fetch the latest artifacts for compose-switch v${compose_switch_version}..."
    get_previous_version "$url" "$repo_url" compose_switch_version
    echo -e "\nAttempting to install v${compose_switch_version}"
    curl -fsSL "https://github.com/docker/compose-switch/releases/download/v${compose_switch_version}/docker-compose-linux-${architecture}" -o /usr/local/bin/compose-switch
}

# Install docker-compose switch if not already installed - https://github.com/docker/compose-switch#manual-installation
if [ "${INSTALL_DOCKER_COMPOSE_SWITCH}" = "true" ] && ! type compose-switch > /dev/null 2>&1; then
    if type docker-compose > /dev/null 2>&1; then
        echo "(*) Installing compose-switch..."
        current_compose_path="$(which docker-compose)"
        target_compose_path="$(dirname "${current_compose_path}")/docker-compose-v1"
        compose_switch_version="latest"
        compose_switch_url="https://github.com/docker/compose-switch"
        find_version_from_git_tags compose_switch_version "$compose_switch_url"
        curl -fsSL "https://github.com/docker/compose-switch/releases/download/v${compose_switch_version}/docker-compose-linux-${architecture}" -o /usr/local/bin/compose-switch || fallback_compose-switch "$compose_switch_url"
        chmod +x /usr/local/bin/compose-switch
        # TODO: Verify checksum once available: https://github.com/docker/compose-switch/issues/11
        # Setup v1 CLI as alternative in addition to compose-switch (which maps to v2)
        mv "${current_compose_path}" "${target_compose_path}"
        update-alternatives --install ${docker_compose_path} docker-compose /usr/local/bin/compose-switch 99
        update-alternatives --install ${docker_compose_path} docker-compose "${target_compose_path}" 1
    else
        err "Skipping installation of compose-switch as docker compose is unavailable..."
    fi
fi

# If init file already exists, exit
if [ -f "/usr/local/share/docker-init.sh" ]; then
    echo "/usr/local/share/docker-init.sh already exists, so exiting."
    # Clean up
    rm -rf /var/lib/apt/lists/*
    exit 0
fi
echo "docker-init doesn't exist, adding..."

if ! cat /etc/group | grep -e "^docker:" > /dev/null 2>&1; then
        groupadd -r docker
fi

usermod -aG docker ${USERNAME}

# fallback for docker/buildx
fallback_buildx() {
    local url=$1
    local repo_url=$(get_github_api_repo_url "$url")
    echo -e "\n(!) Failed to fetch the latest artifacts for docker buildx v${buildx_version}..."
    get_previous_version "$url" "$repo_url" buildx_version
    buildx_file_name="buildx-v${buildx_version}.linux-${architecture}"
    echo -e "\nAttempting to install v${buildx_version}"
    wget https://github.com/docker/buildx/releases/download/v${buildx_version}/${buildx_file_name}
}
 
if [ "${INSTALL_DOCKER_BUILDX}" = "true" ]; then
    buildx_version="latest"
    docker_buildx_url="https://github.com/docker/buildx"
    find_version_from_git_tags buildx_version "$docker_buildx_url" "refs/tags/v"
    echo "(*) Installing buildx ${buildx_version}..."
    buildx_file_name="buildx-v${buildx_version}.linux-${architecture}"
    
    cd /tmp
    wget https://github.com/docker/buildx/releases/download/v${buildx_version}/${buildx_file_name} || fallback_buildx "$docker_buildx_url"
    
    docker_home="/usr/libexec/docker"
    cli_plugins_dir="${docker_home}/cli-plugins"

    mkdir -p ${cli_plugins_dir}
    mv ${buildx_file_name} ${cli_plugins_dir}/docker-buildx
    chmod +x ${cli_plugins_dir}/docker-buildx

    chown -R "${USERNAME}:docker" "${docker_home}"
    chmod -R g+r+w "${docker_home}"
    find "${docker_home}" -type d -print0 | xargs -n 1 -0 chmod g+s
fi

DOCKER_DEFAULT_IP6_TABLES=""
if [ "$DISABLE_IP6_TABLES" == true ]; then
    requested_version=""
    # checking whether the version requested either is in semver format or just a number denoting the major version
    # and, extracting the major version number out of the two scenarios
    semver_regex="^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?(\+([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?$"
    if echo "$DOCKER_VERSION" | grep -Eq $semver_regex; then
        requested_version=$(echo $DOCKER_VERSION | cut -d. -f1)
    elif echo "$DOCKER_VERSION" | grep -Eq "^[1-9][0-9]*$"; then
        requested_version=$DOCKER_VERSION
    fi
    if [ "$DOCKER_VERSION" = "latest" ] || [[ -n "$requested_version" && "$requested_version" -ge 27 ]] ; then
        DOCKER_DEFAULT_IP6_TABLES="--ip6tables=false"
        echo "(!) As requested, passing '${DOCKER_DEFAULT_IP6_TABLES}'"
    fi
fi

tee /usr/local/share/docker-init.sh > /dev/null \
<< EOF
#!/bin/sh
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------

set -e

AZURE_DNS_AUTO_DETECTION=${AZURE_DNS_AUTO_DETECTION}
DOCKER_DEFAULT_ADDRESS_POOL=${DOCKER_DEFAULT_ADDRESS_POOL}
DOCKER_DEFAULT_IP6_TABLES=${DOCKER_DEFAULT_IP6_TABLES}
EOF

tee -a /usr/local/share/docker-init.sh > /dev/null \
<< 'EOF'
dockerd_start="AZURE_DNS_AUTO_DETECTION=${AZURE_DNS_AUTO_DETECTION} DOCKER_DEFAULT_ADDRESS_POOL=${DOCKER_DEFAULT_ADDRESS_POOL} DOCKER_DEFAULT_IP6_TABLES=${DOCKER_DEFAULT_IP6_TABLES} $(cat << 'INNEREOF'
    # explicitly remove dockerd and containerd PID file to ensure that it can start properly if it was stopped uncleanly
    find /run /var/run -iname 'docker*.pid' -delete || :
    find /run /var/run -iname 'container*.pid' -delete || :

    # -- Start: dind wrapper script --
    # Maintained: https://github.com/moby/moby/blob/master/hack/dind

    export container=docker

    if [ -d /sys/kernel/security ] && ! mountpoint -q /sys/kernel/security; then
        mount -t securityfs none /sys/kernel/security || {
            echo >&2 'Could not mount /sys/kernel/security.'
            echo >&2 'AppArmor detection and --privileged mode might break.'
        }
    fi

    # Mount /tmp (conditionally)
    if ! mountpoint -q /tmp; then
        mount -t tmpfs none /tmp
    fi

    set_cgroup_nesting()
    {
        # cgroup v2: enable nesting
        if [ -f /sys/fs/cgroup/cgroup.controllers ]; then
            # move the processes from the root group to the /init group,
            # otherwise writing subtree_control fails with EBUSY.
            # An error during moving non-existent process (i.e., "cat") is ignored.
            mkdir -p /sys/fs/cgroup/init
            xargs -rn1 < /sys/fs/cgroup/cgroup.procs > /sys/fs/cgroup/init/cgroup.procs || :
            # enable controllers
            sed -e 's/ / +/g' -e 's/^/+/' < /sys/fs/cgroup/cgroup.controllers \
                > /sys/fs/cgroup/cgroup.subtree_control
        fi
    }

    # Set cgroup nesting, retrying if necessary
    retry_cgroup_nesting=0

    until [ "${retry_cgroup_nesting}" -eq "5" ];
    do
        set +e
            set_cgroup_nesting

            if [ $? -ne 0 ]; then
                echo "(*) cgroup v2: Failed to enable nesting, retrying..."
            else
                break
            fi

            retry_cgroup_nesting=`expr $retry_cgroup_nesting + 1`
        set -e
    done

    # -- End: dind wrapper script --

    # Handle DNS
    set +e
        cat /etc/resolv.conf | grep -i 'internal.cloudapp.net' > /dev/null 2>&1
        if [ $? -eq 0 ] && [ "${AZURE_DNS_AUTO_DETECTION}" = "true" ]
        then
            echo "Setting dockerd Azure DNS."
            CUSTOMDNS="--dns 168.63.129.16"
        else
            echo "Not setting dockerd DNS manually."
            CUSTOMDNS=""
        fi
    set -e

    if [ -z "$DOCKER_DEFAULT_ADDRESS_POOL" ]
    then
        DEFAULT_ADDRESS_POOL=""
    else
        DEFAULT_ADDRESS_POOL="--default-address-pool $DOCKER_DEFAULT_ADDRESS_POOL"
    fi

    # Start docker/moby engine
    ( dockerd $CUSTOMDNS $DEFAULT_ADDRESS_POOL $DOCKER_DEFAULT_IP6_TABLES > /tmp/dockerd.log 2>&1 ) &
INNEREOF
)"

sudo_if() {
    COMMAND="$*"

    if [ "$(id -u)" -ne 0 ]; then
        sudo $COMMAND
    else
        $COMMAND
    fi
}

retry_docker_start_count=0
docker_ok="false"

until [ "${docker_ok}" = "true"  ] || [ "${retry_docker_start_count}" -eq "5" ];
do
    # Start using sudo if not invoked as root
    if [ "$(id -u)" -ne 0 ]; then
        sudo /bin/sh -c "${dockerd_start}"
    else
        eval "${dockerd_start}"
    fi

    retry_count=0
    until [ "${docker_ok}" = "true"  ] || [ "${retry_count}" -eq "5" ];
    do
        sleep 1s
        set +e
            docker info > /dev/null 2>&1 && docker_ok="true"
        set -e

        retry_count=`expr $retry_count + 1`
    done

    if [ "${docker_ok}" != "true" ] && [ "${retry_docker_start_count}" != "4" ]; then
        echo "(*) Failed to start docker, retrying..."
        set +e
            sudo_if pkill dockerd
            sudo_if pkill containerd
        set -e
    fi

    retry_docker_start_count=`expr $retry_docker_start_count + 1`
done

# Execute whatever commands were passed in (if any). This allows us
# to set this script to ENTRYPOINT while still executing the default CMD.
exec "$@"
EOF

chmod +x /usr/local/share/docker-init.sh
chown ${USERNAME}:root /usr/local/share/docker-init.sh

# Clean up
rm -rf /var/lib/apt/lists/*

echo 'docker-in-docker-debian script has completed!'



================================================
FILE: src/docker-in-docker/NOTES.md
================================================
## Limitations

This docker-in-docker Dev Container Feature is roughly based on the [official docker-in-docker wrapper script](https://github.com/moby/moby/blob/master/hack/dind) that is part of the [Moby project](https://mobyproject.org/). With this in mind:
* As the name implies, the Feature is expected to work when the host is running Docker (or the OSS Moby container engine it is built on). It may be possible to get running in other container engines, but it has not been tested with them.
* The host and the container must be running on the same chip architecture. You will not be able to use it with an emulated x86 image with Docker Desktop on an Apple Silicon Mac, like in this example:
  ```
  FROM --platform=linux/amd64 mcr.microsoft.com/devcontainers/typescript-node:16
  ```
  See [Issue #219](https://github.com/devcontainers/features/issues/219) for more details.


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

Debian Trixie (13) does not include moby-cli and related system packages, so the feature cannot install with "moby": "true". To use this feature on Trixie, please set "moby": "false" or choose a different base image (for example, Ubuntu 24.04).

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/docker-outside-of-docker/README.md
================================================
### **IMPORTANT NOTE**
- **Ids used to publish this Feature in the past - 'docker-from-docker'**

# Docker (docker-outside-of-docker) (docker-outside-of-docker)

Re-use the host docker socket, adding the Docker CLI to a container. Feature invokes a script to enable using a forwarded Docker socket within a container to run Docker commands.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/docker-outside-of-docker:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a Docker/Moby CLI version. (Availability can vary by OS version.) | string | latest |
| moby | Install OSS Moby build instead of Docker CE | boolean | true |
| mobyBuildxVersion | Install a specific version of moby-buildx when using Moby | string | latest |
| dockerDashComposeVersion | Compose version to use for docker-compose (v1 or v2 or none) | string | v2 |
| installDockerBuildx | Install Docker Buildx | boolean | true |
| installDockerComposeSwitch | Install Compose Switch (provided docker compose is available) which is a replacement to the Compose V1 docker-compose (python) executable. It translates the command line into Compose V2 docker compose then runs the latter. | boolean | true |

## Customizations

### VS Code Extensions

- `ms-azuretools.vscode-containers`

## Limitations

- As the name implies, the Feature is expected to work when the host is running Docker (or the OSS Moby container engine it is built on). It may be possible to get running in other container engines, but it has not been tested with them.
- The host and the container must be running on the same chip architecture. You will not be able to use it with an emulated x86 image with Docker Desktop on an Apple Silicon Mac, for example.
- This approach does not currently enable bind mounting the workspace folder by default, and cannot support folders outside of the workspace folder. Consider whether the [Docker-in-Docker Feature](../docker-in-docker) would better meet your needs given it does not have this limitation.

## Supporting bind mounts from the workspace folder

A common question that comes up is how you can use `bind` mounts from the Docker CLI from within the a dev container using this Feature (e.g. via `-v`). If you cannot use the [Docker-in-Docker Feature](../docker-in-docker), the only way to work around this is to use the **host**'s folder paths instead of the container's paths. There are 2 ways to do this

### 1. Use the `${localWorkspaceFolder}` as environment variable in your code

1. Add the following to `devcontainer.json`:

```json
"remoteEnv": { "LOCAL_WORKSPACE_FOLDER": "${localWorkspaceFolder}" }
```

2. Usage with Docker commands

```bash
docker run -it --rm -v ${LOCAL_WORKSPACE_FOLDER}:/workspace debian bash
```

3. Usage with Docker-compose

```yaml
version: "3.9"

services:
  debian:
    image: debian
    volumes:
      - ${LOCAL_WORKSPACE_FOLDER:-./}:/workspace
```

- The defaults value `./` is added so that the `docker-compose.yaml` file can work when it is run outside of the container

### 2. Change the workspace to `${localWorkspaceFolder}`

- This is useful if we don't want to edit the `docker-compose.yaml` file

1. Add the following to `devcontainer.json`

```json
"workspaceFolder": "${localWorkspaceFolder}",
"workspaceMount": "source=${localWorkspaceFolder},target=${localWorkspaceFolder},type=bind"
```

2. Rebuild the container.
3. When the container first started with this settings, select the Workspace with the absolute path to the working directory inside the container
4. Docker commands with bind mount should work as they did outside of the devcontainer

> **Note:** There is no `${localWorkspaceFolder}` when using the **Clone Repository in Container Volume** command in the VS Code Dev Containers extension ([info](https://github.com/microsoft/vscode-remote-release/issues/6160#issuecomment-1014701007)).


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/docker-outside-of-docker/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/docker-outside-of-docker/devcontainer-feature.json
================================================
{
    "id": "docker-outside-of-docker",
    "version": "1.6.5",
    "name": "Docker (docker-outside-of-docker)",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/docker-outside-of-docker",
    "description": "Re-use the host docker socket, adding the Docker CLI to a container. Feature invokes a script to enable using a forwarded Docker socket within a container to run Docker commands.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "none",
                "20.10"
            ],
            "default": "latest",
            "description": "Select or enter a Docker/Moby CLI version. (Availability can vary by OS version.)"
        },
        "moby": {
            "type": "boolean",
            "default": true,
            "description": "Install OSS Moby build instead of Docker CE"
        },
        "mobyBuildxVersion": {
            "type": "string",
            "default": "latest",
            "description": "Install a specific version of moby-buildx when using Moby"
        },
        "dockerDashComposeVersion": {
            "type": "string",
            "enum": [
                "none",
                "v1",
                "v2"
            ],
            "default": "v2",
            "description": "Compose version to use for docker-compose (v1 or v2 or none)"
        },
        "installDockerBuildx": {
            "type": "boolean",
            "default": true,
            "description": "Install Docker Buildx"
        },
        "installDockerComposeSwitch": {
            "type": "boolean",
            "default": true,
            "description": "Install Compose Switch (provided docker compose is available) which is a replacement to the Compose V1 docker-compose (python) executable. It translates the command line into Compose V2 docker compose then runs the latter."
        }
    },
    "entrypoint": "/usr/local/share/docker-init.sh",
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-azuretools.vscode-containers"
            ],
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes the Docker CLI (`docker`) pre-installed and available on the `PATH` for running and managing containers using the Docker daemon on the host machine."
                    }
                ]
            }
        }
    },
    "mounts": [
        {
            "source": "/var/run/docker.sock",
            "target": "/var/run/docker-host.sock",
            "type": "bind"
        }
    ],
    "securityOpt": [
        "label=disable"
    ],
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ],
    "legacyIds": [
        "docker-from-docker"
    ]
}



================================================
FILE: src/docker-outside-of-docker/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/docker.md
# Maintainer: The VS Code and Codespaces Teams

DOCKER_VERSION="${VERSION:-"latest"}"
USE_MOBY="${MOBY:-"true"}"
MOBY_BUILDX_VERSION="${MOBYBUILDXVERSION:-"latest"}"
DOCKER_DASH_COMPOSE_VERSION="${DOCKERDASHCOMPOSEVERSION:-"v2"}" # v1 or v2 or none

ENABLE_NONROOT_DOCKER="${ENABLE_NONROOT_DOCKER:-"true"}"
SOURCE_SOCKET="${SOURCE_SOCKET:-"/var/run/docker-host.sock"}"
TARGET_SOCKET="${TARGET_SOCKET:-"/var/run/docker.sock"}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
INSTALL_DOCKER_BUILDX="${INSTALLDOCKERBUILDX:-"true"}"
INSTALL_DOCKER_COMPOSE_SWITCH="${INSTALLDOCKERCOMPOSESWITCH:-"true"}"
MICROSOFT_GPG_KEYS_URI="https://packages.microsoft.com/keys/microsoft.asc"
MICROSOFT_GPG_KEYS_ROLLING_URI="https://packages.microsoft.com/keys/microsoft-rolling.asc"
DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES="trixie bookworm buster bullseye bionic focal jammy noble plucky"
DOCKER_LICENSED_ARCHIVE_VERSION_CODENAMES="trixie bookworm buster bullseye bionic focal hirsute impish jammy noble plucky"

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

# Setup STDERR.
err() {
    echo "(!) $*" >&2
}

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");

    check_packages jq
    
    if echo "$output" | jq -e 'type == "object"' > /dev/null; then
        message=$(echo "$output" | jq -r '.message')
        if [[ $message == "API rate limit exceeded"* ]]; then
            echo -e "\nAn attempt to find previous to latest version using GitHub Api Failed... \nReason: ${message}"
            echo -e "\nAttempting to find previous to latest version using GitHub tags."
            find_prev_version_from_git_tags prev_version "$url" "tags/v"
            declare -g ${variable_name}="${prev_version}"
        fi
    elif echo "$output" | jq -e 'type == "array"' > /dev/null; then
        echo -e "\nAttempting to find previous version using GitHub Api."
        version=$(echo "$output" | jq -r '.[1].tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}" 
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases"
}

install_compose_switch_fallback() {
    compose_switch_url=$1
    repo_url=$(get_github_api_repo_url "${compose_switch_url}")
    echo -e "\n(!) Failed to fetch the latest artifacts for compose-switch v${compose_switch_version}..."
    get_previous_version "${compose_switch_url}" "${repo_url}" compose_switch_version
    echo -e "\nAttempting to install v${compose_switch_version}"
    curl -fsSL "https://github.com/docker/compose-switch/releases/download/v${compose_switch_version}/docker-compose-linux-${architecture}" -o /usr/local/bin/compose-switch
}

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive

# Install dependencies
check_packages apt-transport-https curl ca-certificates gnupg2 dirmngr wget
if ! type git > /dev/null 2>&1; then
    check_packages git
fi

# Source /etc/os-release to get OS info
. /etc/os-release
# Fetch host/container arch.
architecture="$(dpkg --print-architecture)"

# Prevent attempting to install Moby on Debian trixie (packages removed)
if [ "${USE_MOBY}" = "true" ] && [ "${ID}" = "debian" ] && [ "${VERSION_CODENAME}" = "trixie" ]; then
    err "The 'moby' option is not supported on Debian 'trixie' because 'moby-cli' and related system packages have been removed from that distribution."
    err "To continue, either set the feature option '\"moby\": false' or use a different base image (for example: 'debian:bookworm' or 'ubuntu-24.04')."
    exit 1
fi

# Check if distro is supported
if [ "${USE_MOBY}" = "true" ]; then
    if [[ "${DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES}" != *"${VERSION_CODENAME}"* ]]; then
        err "Unsupported  distribution version '${VERSION_CODENAME}'. To resolve, either: (1) set feature option '\"moby\": false' , or (2) choose a compatible OS distribution"
        err "Supported distributions include:  ${DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES}"
        exit 1
    fi
    echo "Distro codename  '${VERSION_CODENAME}'  matched filter  '${DOCKER_MOBY_ARCHIVE_VERSION_CODENAMES}'"
else
    if [[ "${DOCKER_LICENSED_ARCHIVE_VERSION_CODENAMES}" != *"${VERSION_CODENAME}"* ]]; then
        err "Unsupported distribution version '${VERSION_CODENAME}'. To resolve, please choose a compatible OS distribution"
        err "Supported distributions include:  ${DOCKER_LICENSED_ARCHIVE_VERSION_CODENAMES}"
        exit 1
    fi
    echo "Distro codename  '${VERSION_CODENAME}'  matched filter  '${DOCKER_LICENSED_ARCHIVE_VERSION_CODENAMES}'"
fi

# Set up the necessary apt repos (either Microsoft's or Docker's)
if [ "${USE_MOBY}" = "true" ]; then

    cli_package_name="moby-cli"

    # Import key safely and import Microsoft apt repo
    {
        curl -sSL ${MICROSOFT_GPG_KEYS_URI}
        curl -sSL ${MICROSOFT_GPG_KEYS_ROLLING_URI}
    } | gpg --dearmor > /usr/share/keyrings/microsoft-archive-keyring.gpg
    echo "deb [arch=${architecture} signed-by=/usr/share/keyrings/microsoft-archive-keyring.gpg] https://packages.microsoft.com/repos/microsoft-${ID}-${VERSION_CODENAME}-prod ${VERSION_CODENAME} main" > /etc/apt/sources.list.d/microsoft.list
else
    # Name of proprietary engine package
    cli_package_name="docker-ce-cli"

    # Import key safely and import Docker apt repo
    curl -fsSL https://download.docker.com/linux/${ID}/gpg | gpg --dearmor > /usr/share/keyrings/docker-archive-keyring.gpg
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/${ID} ${VERSION_CODENAME} stable" > /etc/apt/sources.list.d/docker.list
fi

# Refresh apt lists
apt-get update

# Soft version matching for CLI
if [ "${DOCKER_VERSION}" = "latest" ] || [ "${DOCKER_VERSION}" = "lts" ] || [ "${DOCKER_VERSION}" = "stable" ]; then
    # Empty, meaning grab whatever "latest" is in apt repo
    cli_version_suffix=""
else
    # Fetch a valid version from the apt-cache (eg: the Microsoft repo appends +azure, breakfix, etc...)
    docker_version_dot_escaped="${DOCKER_VERSION//./\\.}"
    docker_version_dot_plus_escaped="${docker_version_dot_escaped//+/\\+}"
    # Regex needs to handle debian package version number format: https://www.systutorials.com/docs/linux/man/5-deb-version/
    docker_version_regex="^(.+:)?${docker_version_dot_plus_escaped}([\\.\\+ ~:-]|$)"
    set +e # Don't exit if finding version fails - will handle gracefully
    cli_version_suffix="=$(apt-cache madison ${cli_package_name} | awk -F"|" '{print $2}' | sed -e 's/^[ \t]*//' | grep -E -m 1 "${docker_version_regex}")"
    set -e
    if [ -z "${cli_version_suffix}" ] || [ "${cli_version_suffix}" = "=" ]; then
        echo "(!) No full or partial Docker / Moby version match found for \"${DOCKER_VERSION}\" on OS ${ID} ${VERSION_CODENAME} (${architecture}). Available versions:"
        apt-cache madison ${cli_package_name} | awk -F"|" '{print $2}' | grep -oP '^(.+:)?\K.+'
        exit 1
    fi
    echo "cli_version_suffix ${cli_version_suffix}"
fi

# Version matching for moby-buildx
if [ "${USE_MOBY}" = "true" ]; then
    if [ "${MOBY_BUILDX_VERSION}" = "latest" ]; then
        # Empty, meaning grab whatever "latest" is in apt repo
        buildx_version_suffix=""
    else
        buildx_version_dot_escaped="${MOBY_BUILDX_VERSION//./\\.}"
        buildx_version_dot_plus_escaped="${buildx_version_dot_escaped//+/\\+}"
        buildx_version_regex="^(.+:)?${buildx_version_dot_plus_escaped}([\\.\\+ ~:-]|$)"
        set +e
            buildx_version_suffix="=$(apt-cache madison moby-buildx | awk -F"|" '{print $2}' | sed -e 's/^[ \t]*//' | grep -E -m 1 "${buildx_version_regex}")"
        set -e
        if [ -z "${buildx_version_suffix}" ] || [ "${buildx_version_suffix}" = "=" ]; then
            err "No full or partial moby-buildx version match found for \"${MOBY_BUILDX_VERSION}\" on OS ${ID} ${VERSION_CODENAME} (${architecture}). Available versions:"
            apt-cache madison moby-buildx | awk -F"|" '{print $2}' | grep -oP '^(.+:)?\K.+'
            exit 1
        fi
        echo "buildx_version_suffix ${buildx_version_suffix}"
    fi
fi


docker_home="/usr/libexec/docker"
cli_plugins_dir="${docker_home}/cli-plugins"

install_compose_fallback(){
    local url=$1
    local repo_url=$(get_github_api_repo_url "$url")
    echo -e "\n(!) Failed to fetch the latest artifacts for docker-compose v${compose_version}..."
    get_previous_version "${url}" "${repo_url}" compose_version
    echo -e "\nAttempting to install v${compose_version}"
    curl -fsSL "https://github.com/docker/compose/releases/download/v${compose_version}/docker-compose-linux-${target_compose_arch}" -o ${docker_compose_path}
}

# Install Docker / Moby CLI if not already installed
if type docker > /dev/null 2>&1; then
    echo "Docker / Moby CLI already installed."
else
    if [ "${USE_MOBY}" = "true" ]; then
        buildx=()
        if [ "${INSTALL_DOCKER_BUILDX}" = "true" ]; then
            buildx=(moby-buildx${buildx_version_suffix})
        fi
        apt-get -y install --no-install-recommends ${cli_package_name}${cli_version_suffix} "${buildx[@]}" || { err "It seems packages for moby not available in OS ${ID} ${VERSION_CODENAME} (${architecture}). To resolve, either: (1) set feature option '\"moby\": false' , or (2) choose a compatible OS version (eg: 'ubuntu-24.04')." ; exit 1 ; }
        apt-get -y install --no-install-recommends moby-compose || echo "(*) Package moby-compose (Docker Compose v2) not available for OS ${ID} ${VERSION_CODENAME} (${architecture}). Skipping."
    else
        buildx=()
        if [ "${INSTALL_DOCKER_BUILDX}" = "true" ]; then
            buildx=(docker-buildx-plugin)
        fi
        apt-get -y install --no-install-recommends ${cli_package_name}${cli_version_suffix} "${buildx[@]}" docker-compose-plugin
        buildx_path="/usr/libexec/docker/cli-plugins/docker-buildx"
        # Older versions of Docker CE installs buildx as part of the CLI package
        if [ "${INSTALL_DOCKER_BUILDX}" = "false" ] && [ -f "${buildx_path}" ]; then
            echo "(*) Removing docker-buildx installed from docker-ce-cli since installDockerBuildx is disabled..."
            rm -f "${buildx_path}"
        fi
    fi
    unset buildx buildx_path
fi

# If 'docker-compose' command is to be included
if [ "${DOCKER_DASH_COMPOSE_VERSION}" != "none" ]; then
    case "${architecture}" in
        amd64) target_compose_arch=x86_64 ;;
        arm64) target_compose_arch=aarch64 ;;
        *)
            echo "(!) Docker outside of docker does not support machine architecture '$architecture'. Please use an x86-64 or ARM64 machine."
            exit 1
    esac
    docker_compose_path="/usr/local/bin/docker-compose" 
    # Install Docker Compose if not already installed  and is on a supported architecture
    if type docker-compose > /dev/null 2>&1; then
        echo "Docker Compose already installed."
    elif [ "${DOCKER_DASH_COMPOSE_VERSION}" = "v1" ]; then
        err "The final Compose V1 release, version 1.29.2, was May 10, 2021. These packages haven't received any security updates since then. Use at your own risk."
        INSTALL_DOCKER_COMPOSE_SWITCH="false"
        
        if [ "${target_compose_arch}" = "x86_64" ]; then
            echo "(*) Installing docker compose v1..."
            curl -fsSL "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64" -o ${docker_compose_path}
            chmod +x ${docker_compose_path}

            # Download the SHA256 checksum
            DOCKER_COMPOSE_SHA256="$(curl -sSL "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64.sha256" | awk '{print $1}')"
            echo "${DOCKER_COMPOSE_SHA256}  ${docker_compose_path}" > docker-compose.sha256sum
            sha256sum -c docker-compose.sha256sum --ignore-missing
        elif [ "${VERSION_CODENAME}" = "bookworm" ]; then
            err "Docker compose v1 is unavailable for 'bookworm' on Arm64. Kindly switch to use v2"
            exit 1
        else
            # Use pip to get a version that runs on this architecture
            check_packages python3-minimal python3-pip libffi-dev python3-venv
            echo "(*) Installing docker compose v1 via pip..."
            export PYTHONUSERBASE=/usr/local
            pip3 install --disable-pip-version-check --no-cache-dir --user "Cython<3.0" pyyaml wheel docker-compose --no-build-isolation
        fi
    else
        compose_version=${DOCKER_DASH_COMPOSE_VERSION#v}
        docker_compose_url="https://github.com/docker/compose"
        find_version_from_git_tags compose_version "$docker_compose_url" "tags/v"
        echo "(*) Installing docker-compose ${compose_version}..."
        curl -fsSL "https://github.com/docker/compose/releases/download/v${compose_version}/docker-compose-linux-${target_compose_arch}" -o ${docker_compose_path} || {
            install_compose_fallback "$docker_compose_url" "$compose_version" "$target_compose_arch" "$docker_compose_path"
        }
        chmod +x ${docker_compose_path}

        # Download the SHA256 checksum
        DOCKER_COMPOSE_SHA256="$(curl -sSL "https://github.com/docker/compose/releases/download/v${compose_version}/docker-compose-linux-${target_compose_arch}.sha256" | awk '{print $1}')"
        echo "${DOCKER_COMPOSE_SHA256}  ${docker_compose_path}" > docker-compose.sha256sum
        sha256sum -c docker-compose.sha256sum --ignore-missing

        mkdir -p ${cli_plugins_dir}
        cp ${docker_compose_path} ${cli_plugins_dir}
    fi
fi

# Install docker-compose switch if not already installed - https://github.com/docker/compose-switch#manual-installation
if [ "${INSTALL_DOCKER_COMPOSE_SWITCH}" = "true" ] && ! type compose-switch > /dev/null 2>&1; then
    if type docker-compose > /dev/null 2>&1; then
        echo "(*) Installing compose-switch..."
        current_compose_path="$(which docker-compose)"
        target_compose_path="$(dirname "${current_compose_path}")/docker-compose-v1"
        compose_switch_version="latest"
        compose_switch_url="https://github.com/docker/compose-switch"
        find_version_from_git_tags compose_switch_version "${compose_switch_url}"
        curl -fsSL "https://github.com/docker/compose-switch/releases/download/v${compose_switch_version}/docker-compose-linux-${architecture}" -o /usr/local/bin/compose-switch || install_compose_switch_fallback "${compose_switch_url}"
        chmod +x /usr/local/bin/compose-switch
        # TODO: Verify checksum once available: https://github.com/docker/compose-switch/issues/11
        # Setup v1 CLI as alternative in addition to compose-switch (which maps to v2)
        mv "${current_compose_path}" "${target_compose_path}"
        update-alternatives --install ${docker_compose_path} docker-compose /usr/local/bin/compose-switch 99
        update-alternatives --install ${docker_compose_path} docker-compose "${target_compose_path}" 1
    else
        err "Skipping installation of compose-switch as docker compose is unavailable..."
    fi
fi

# Setup a docker group in the event the docker socket's group is not root
if ! grep -qE '^docker:' /etc/group; then
    echo "(*) Creating missing docker group..."
    groupadd --system docker
fi

# Remarking this out to restore functionality in Azure VMs.  ID 999 is a reserved group ID
# Ensure docker group gid is 999
# if [ "$(getent group docker | cut -d: -f3)" != "999" ]; then
#     echo "(*) Updating docker group gid to 999..."
#     groupmod -g 999 docker
# fi


usermod -aG docker "${USERNAME}"

# If init file already exists, exit
if [ -f "/usr/local/share/docker-init.sh" ]; then
    # Clean up
    rm -rf /var/lib/apt/lists/*
    exit 0
fi
echo "docker-init doesn't exist, adding..."

# By default, make the source and target sockets the same
if [ "${SOURCE_SOCKET}" != "${TARGET_SOCKET}" ]; then
    touch "${SOURCE_SOCKET}"
    ln -s "${SOURCE_SOCKET}" "${TARGET_SOCKET}"
fi

# Add a stub if not adding non-root user access, user is root
if [ "${ENABLE_NONROOT_DOCKER}" = "false" ] || [ "${USERNAME}" = "root" ]; then
    echo -e '#!/usr/bin/env bash\nexec "$@"' > /usr/local/share/docker-init.sh
    chmod +x /usr/local/share/docker-init.sh
    # Clean up
    rm -rf /var/lib/apt/lists/*
    exit 0
fi

DOCKER_GID="$(grep -oP '^docker:x:\K[^:]+' /etc/group)"

# If enabling non-root access and specified user is found, setup socat and add script
chown -h "${USERNAME}":root "${TARGET_SOCKET}"
check_packages socat
tee /usr/local/share/docker-init.sh > /dev/null \
<< EOF
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------

set -e

SOCAT_PATH_BASE=/tmp/vscr-docker-from-docker
SOCAT_LOG=\${SOCAT_PATH_BASE}.log
SOCAT_PID=\${SOCAT_PATH_BASE}.pid

# Wrapper function to only use sudo if not already root
sudoIf()
{
    if [ "\$(id -u)" -ne 0 ]; then
        sudo "\$@"
    else
        "\$@"
    fi
}

# Log messages
log()
{
    echo -e "[\$(date)] \$@" | sudoIf tee -a \${SOCAT_LOG} > /dev/null
}

echo -e "\n** \$(date) **" | sudoIf tee -a \${SOCAT_LOG} > /dev/null
log "Ensuring ${USERNAME} has access to ${SOURCE_SOCKET} via ${TARGET_SOCKET}"

# If enabled, try to update the docker group with the right GID. If the group is root,
# fall back on using socat to forward the docker socket to another unix socket so
# that we can set permissions on it without affecting the host.
if [ "${ENABLE_NONROOT_DOCKER}" = "true" ] && [ "${SOURCE_SOCKET}" != "${TARGET_SOCKET}" ] && [ "${USERNAME}" != "root" ] && [ "${USERNAME}" != "0" ]; then
    SOCKET_GID=\$(stat -c '%g' ${SOURCE_SOCKET})
    if [ "\${SOCKET_GID}" != "0" ] && [ "\${SOCKET_GID}" != "${DOCKER_GID}" ] && ! grep -E ".+:x:\${SOCKET_GID}" /etc/group; then
        sudoIf groupmod --gid "\${SOCKET_GID}" docker
    else
        # Enable proxy if not already running
        if [ ! -f "\${SOCAT_PID}" ] || ! ps -p \$(cat \${SOCAT_PID}) > /dev/null; then
            log "Enabling socket proxy."
            log "Proxying ${SOURCE_SOCKET} to ${TARGET_SOCKET} for vscode"
            sudoIf rm -rf ${TARGET_SOCKET}
            (sudoIf socat UNIX-LISTEN:${TARGET_SOCKET},fork,mode=660,user=${USERNAME},backlog=128 UNIX-CONNECT:${SOURCE_SOCKET} 2>&1 | sudoIf tee -a \${SOCAT_LOG} > /dev/null & echo "\$!" | sudoIf tee \${SOCAT_PID} > /dev/null)
        else
            log "Socket proxy already running."
        fi
    fi
    log "Success"
fi

# Execute whatever commands were passed in (if any). This allows us
# to set this script to ENTRYPOINT while still executing the default CMD.
set +e
exec "\$@"
EOF
chmod +x /usr/local/share/docker-init.sh
chown ${USERNAME}:root /usr/local/share/docker-init.sh

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"



================================================
FILE: src/docker-outside-of-docker/NOTES.md
================================================
## Limitations

- As the name implies, the Feature is expected to work when the host is running Docker (or the OSS Moby container engine it is built on). It may be possible to get running in other container engines, but it has not been tested with them.
- The host and the container must be running on the same chip architecture. You will not be able to use it with an emulated x86 image with Docker Desktop on an Apple Silicon Mac, for example.
- This approach does not currently enable bind mounting the workspace folder by default, and cannot support folders outside of the workspace folder. Consider whether the [Docker-in-Docker Feature](../docker-in-docker) would better meet your needs given it does not have this limitation.

## Supporting bind mounts from the workspace folder

A common question that comes up is how you can use `bind` mounts from the Docker CLI from within the a dev container using this Feature (e.g. via `-v`). If you cannot use the [Docker-in-Docker Feature](../docker-in-docker), the only way to work around this is to use the **host**'s folder paths instead of the container's paths. There are 2 ways to do this

### 1. Use the `${localWorkspaceFolder}` as environment variable in your code

1. Add the following to `devcontainer.json`:

```json
"remoteEnv": { "LOCAL_WORKSPACE_FOLDER": "${localWorkspaceFolder}" }
```

2. Usage with Docker commands

```bash
docker run -it --rm -v ${LOCAL_WORKSPACE_FOLDER}:/workspace debian bash
```

3. Usage with Docker-compose

```yaml
version: "3.9"

services:
  debian:
    image: debian
    volumes:
      - ${LOCAL_WORKSPACE_FOLDER:-./}:/workspace
```

- The defaults value `./` is added so that the `docker-compose.yaml` file can work when it is run outside of the container

### 2. Change the workspace to `${localWorkspaceFolder}`

- This is useful if we don't want to edit the `docker-compose.yaml` file

1. Add the following to `devcontainer.json`

```json
"workspaceFolder": "${localWorkspaceFolder}",
"workspaceMount": "source=${localWorkspaceFolder},target=${localWorkspaceFolder},type=bind"
```

2. Rebuild the container.
3. When the container first started with this settings, select the Workspace with the absolute path to the working directory inside the container
4. Docker commands with bind mount should work as they did outside of the devcontainer

> **Note:** There is no `${localWorkspaceFolder}` when using the **Clone Repository in Container Volume** command in the VS Code Dev Containers extension ([info](https://github.com/microsoft/vscode-remote-release/issues/6160#issuecomment-1014701007)).


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

Debian Trixie (13) does not include moby-cli and related system packages, so the feature cannot install with "moby": "true". To use this feature on Trixie, please set "moby": "false" or choose a different base image (for example, Ubuntu 24.04).

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/dotnet/README.md
================================================

# Dotnet CLI (dotnet)

This Feature installs the latest .NET SDK, which includes the .NET CLI and the shared runtime. Options are provided to choose a different version or additional versions.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a .NET SDK version. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version. | string | latest |
| additionalVersions | Enter additional .NET SDK versions, separated by commas. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version. | string | - |
| dotnetRuntimeVersions | Enter additional .NET runtime versions, separated by commas. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version. | string | - |
| aspNetCoreRuntimeVersions | Enter additional ASP.NET Core runtime versions, separated by commas. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version. | string | - |
| workloads | Enter additional .NET SDK workloads, separated by commas. Use 'dotnet workload search' to learn what workloads are available to install. | string | - |

## Customizations

### VS Code Extensions

- `ms-dotnettools.csharp`

## Configuration examples

Installing only the latest .NET SDK version (the default).

``` jsonc
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": "latest" // or "" or {}
}
```

Installing an additional SDK version. Multiple versions can be specified as comma-separated values.

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "additionalVersions": "lts"
    }
}
```

Installing specific SDK versions.

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "version": "6.0",
        "additionalVersions": "7.0, 8.0"
    }
}
```

Installing a specific SDK feature band.

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "version": "6.0.4xx",
    }
}
```

Installing a specific SDK patch version.

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "version": "6.0.412",
    }
}
```

Installing only the .NET Runtime or the ASP.NET Core Runtime. (The SDK includes all runtimes so this configuration is only useful if you need to run .NET apps without building them from source.)

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "version": "none",
        "dotnetRuntimeVersions": "latest, lts",
        "aspnetCoreRuntimeVersions": "latest, lts",
    }
}
```

Installing .NET workloads. Multiple workloads can be specified as comma-separated values.

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
      "workloads": "aspire, wasm-tools"
    }
}
```

## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/dotnet/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/dotnet/devcontainer-feature.json
================================================
{
    "id": "dotnet",
    "version": "2.4.0",
    "name": "Dotnet CLI",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/dotnet",
    "description": "This Feature installs the latest .NET SDK, which includes the .NET CLI and the shared runtime. Options are provided to choose a different version or additional versions.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "lts",
                "none",
                "10.0",
                "10.0-preview",
                "10.0-daily",
                "9.0",
                "8.0",
                "7.0",
                "6.0"
            ],
            "default": "latest",
            "description": "Select or enter a .NET SDK version. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version, 'X.Y-preview' or 'X.Y-daily' for prereleases."
        },
        "additionalVersions": {
            "type": "string",
            "default": "",
            "description": "Enter additional .NET SDK versions, separated by commas. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version, 'X.Y-preview' or 'X.Y-daily' for prereleases."
        },
        "dotnetRuntimeVersions": {
            "type": "string",
            "default": "",
            "description": "Enter additional .NET runtime versions, separated by commas. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version, 'X.Y-preview' or 'X.Y-daily' for prereleases."
        },
        "aspNetCoreRuntimeVersions": {
            "type": "string",
            "default": "",
            "description": "Enter additional ASP.NET Core runtime versions, separated by commas. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version, 'X.Y-preview' or 'X.Y-daily' for prereleases."
        },
        "workloads": {
            "type": "string",
            "default": "",
            "description": "Enter additional .NET SDK workloads, separated by commas. Use 'dotnet workload search' to learn what workloads are available to install."
        }
    },
    "containerEnv": {
        "DOTNET_ROOT": "/usr/share/dotnet",
        "PATH": "$PATH:$DOTNET_ROOT:~/.dotnet/tools",
        "DOTNET_RUNNING_IN_CONTAINER": "true",
        "DOTNET_USE_POLLING_FILE_WATCHER": "true"
    },
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-dotnettools.csharp"
            ],
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes the .NET SDK, which includes the .NET CLI and the shared runtime, pre-installed and available on the `PATH`, along with the C# language extension for .NET development."
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/dotnet/install.sh
================================================
#!/bin/bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/devcontainers/features/tree/main/src/dotnet
# Maintainer: The Dev Container spec maintainers
DOTNET_VERSION="${VERSION:-"latest"}"
ADDITIONAL_VERSIONS="${ADDITIONALVERSIONS:-""}"
DOTNET_RUNTIME_VERSIONS="${DOTNETRUNTIMEVERSIONS:-""}"
ASPNETCORE_RUNTIME_VERSIONS="${ASPNETCORERUNTIMEVERSIONS:-""}"
WORKLOADS="${WORKLOADS:-""}"

# Prevent "Welcome to .NET" message from dotnet
export DOTNET_NOLOGO=true

# Prevent generating a development certificate while running this script
# Otherwise it would be stored in the image, which is undesirable
export DOTNET_GENERATE_ASPNET_CERTIFICATE=false

set -e

# Import trim_whitespace and split_csv
source "scripts/string-helpers.sh"

# Import install_sdk and install_runtime
source "scripts/dotnet-helpers.sh"

# Clean up
rm -rf /var/lib/apt/lists/*

# Setup STDERR.
err() {
    echo "(!) $*" >&2
}

apt_get_update() {
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

if [ "$(id -u)" -ne 0 ]; then
    err 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# For our own convenience, combine DOTNET_VERSION and ADDITIONAL_VERSIONS into a single 'versions' array
versions=()

# The version can be set to 'none' for runtime-only installations, then the array will just remain empty
# Ensure there are no leading or trailing spaces that can break regex pattern matching
if [ "$DOTNET_VERSION" != "none" ]; then
    versions+=("$(trim_whitespace "$DOTNET_VERSION")")
    for additional_version in $(split_csv "$ADDITIONAL_VERSIONS"); do
        versions+=("$additional_version")
    done
fi

dotnetRuntimeVersions=()
for dotnetRuntimeVersion in $(split_csv "$DOTNET_RUNTIME_VERSIONS"); do
    dotnetRuntimeVersions+=("$dotnetRuntimeVersion")
done

aspNetCoreRuntimeVersions=()
for aspNetCoreRuntimeVersion in $(split_csv "$ASPNETCORE_RUNTIME_VERSIONS"); do
    aspNetCoreRuntimeVersions+=("$aspNetCoreRuntimeVersion")
done

# Fail fast in case of bad input to avoid unneccesary work
# v1 of the .NET feature allowed specifying only a major version 'X' like '3'
# v2 removed this ability
# - because install-dotnet.sh does not support it directly
# - because the previous behavior installed an old version like '3.0.103', not the newest version '3.1.426', which was counterintuitive
for version in "${versions[@]}"; do
    if [[ "$version" =~ ^[0-9]+$ ]]; then
        err "Unsupported .NET SDK version '${version}'. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version."
        exit 1
    fi
done

for version in "${dotnetRuntimeVersions[@]}"; do
    if [[ "$version" =~ ^[0-9]+$ ]]; then
        err "Unsupported .NET Runtime version '${version}'. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version."
        exit 1
    fi
done

for version in "${aspNetCoreRuntimeVersions[@]}"; do
    if [[ "$version" =~ ^[0-9]+$ ]]; then
        err "Unsupported ASP.NET Core Runtime version '${version}'. Use 'latest' for the latest version, 'lts' for the latest LTS version, 'X.Y' or 'X.Y.Z' for a specific version."
        exit 1
    fi
done

# Install .NET versions and dependencies
# icu-devtools includes dependencies for .NET
check_packages wget ca-certificates icu-devtools

for version in "${versions[@]}"; do
    read -r clean_version quality < <(parse_version_and_quality "$version")
    if [ -n "$quality" ]; then
        echo "Interpreting requested version '$version' as version '$clean_version' with quality '$quality'"
    fi
    install_sdk "$clean_version" "$quality"
done

for version in "${dotnetRuntimeVersions[@]}"; do
    read -r clean_version quality < <(parse_version_and_quality "$version")
    if [ -n "$quality" ]; then
        echo "Interpreting requested runtime version '$version' as version '$clean_version' with quality '$quality'"
    fi
    install_runtime "dotnet" "$clean_version" "$quality"
done

for version in "${aspNetCoreRuntimeVersions[@]}"; do
    read -r clean_version quality < <(parse_version_and_quality "$version")
    if [ -n "$quality" ]; then
        echo "Interpreting requested ASP.NET Core runtime version '$version' as version '$clean_version' with quality '$quality'"
    fi
    install_runtime "aspnetcore" "$clean_version" "$quality"
done

workloads=()
for workload in $(split_csv "$WORKLOADS"); do
    workloads+=("$workload")
done

if [ ${#workloads[@]} -ne 0 ]; then
    install_workloads "${workloads[@]}"
fi

# Create a symbolic link '/usr/bin/dotnet', to make dotnet available to 'sudo'
# This is necessary because 'sudo' resets the PATH variable, so it won't search the DOTNET_ROOT directory
if [ ! -e /usr/bin/dotnet ]; then
    ln --symbolic "$DOTNET_ROOT/dotnet" /usr/bin/dotnet
fi

# Clean up
rm -rf /var/lib/apt/lists/*
rm -rf scripts

echo "Done!"



================================================
FILE: src/dotnet/NOTES.md
================================================
## Configuration examples

Installing only the latest .NET SDK version (the default).

``` jsonc
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": "latest" // or "" or {}
}
```

Installing an additional SDK version. Multiple versions can be specified as comma-separated values.

``` jsonc
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "version": "latest", // (this can be omitted)
        "additionalVersions": "lts"
    }
}
```

Installing specific SDK versions.

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "version": "6.0",
        "additionalVersions": "7.0, 8.0"
    }
}
```

Installing a specific SDK feature band.

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "version": "6.0.4xx",
    }
}
```

Installing a specific SDK patch version.

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "version": "6.0.412",
    }
}
```

Installing only the .NET Runtime or the ASP.NET Core Runtime. (The SDK includes all runtimes so this configuration is only useful if you need to run .NET apps without building them from source.)

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "version": "none",
        "dotnetRuntimeVersions": "latest, lts",
        "aspnetCoreRuntimeVersions": "latest, lts",
    }
}
```

Installing .NET workloads. Multiple workloads can be specified as comma-separated values.

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
      "workloads": "aspire, wasm-tools"
    }
}
```

Installing prerelease builds. Supports `preview` and `daily` suffixes.

``` json
"features": {
    "ghcr.io/devcontainers/features/dotnet:2": {
        "version": "10.0-preview",
        "additionalVersions": "10.0.1xx-daily",
        "dotnetRuntimeVersions": "10.0-daily",
        "aspnetCoreRuntimeVersions": "10.0-daily"
    }
}
```

## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/dotnet/scripts/dotnet-helpers.sh
================================================
#!/bin/bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/devcontainers/features/tree/main/src/dotnet
# Maintainer: The Dev Container spec maintainers
DOTNET_SCRIPTS=$(dirname "${BASH_SOURCE[0]}")
DOTNET_INSTALL_SCRIPT="$DOTNET_SCRIPTS/vendor/dotnet-install.sh"

# Prints the latest dotnet version in the specified channel
# Usage: fetch_latest_version_in_channel <channel> [<runtime>]
# Example: fetch_latest_version_in_channel "LTS"
# Example: fetch_latest_version_in_channel "6.0" "dotnet"
# Example: fetch_latest_version_in_channel "6.0" "aspnetcore"
fetch_latest_version_in_channel() {
    local channel="$1"
    local runtime="$2"
    if [ "$runtime" = "dotnet" ]; then
        wget -qO- "https://builds.dotnet.microsoft.com/dotnet/Runtime/$channel/latest.version"
    elif [ "$runtime" = "aspnetcore" ]; then
        wget -qO- "https://builds.dotnet.microsoft.com/dotnet/aspnetcore/Runtime/$channel/latest.version"
    else
        wget -qO- "https://builds.dotnet.microsoft.com/dotnet/Sdk/$channel/latest.version"
    fi
}

# Prints the latest dotnet version
# Usage: fetch_latest_version [<runtime>]
# Example: fetch_latest_version
# Example: fetch_latest_version "dotnet"
# Example: fetch_latest_version "aspnetcore"
fetch_latest_version() {
    local runtime="$1"
    local sts_version
    local lts_version
    sts_version=$(fetch_latest_version_in_channel "STS" "$runtime")
    lts_version=$(fetch_latest_version_in_channel "LTS" "$runtime")
    if [[ "$sts_version" > "$lts_version" ]]; then
        echo "$sts_version"
    else
        echo "$lts_version"
    fi
}

# Installs a version of the .NET SDK
# Usage: install_sdk <version> [<quality>]
# Example: install_sdk "9.0"
# Example: install_sdk "10.0" "preview"
install_sdk() {
    local inputVersion="$1" # Could be 'latest', 'lts', 'X.Y', 'X.Y.Z', 'X.Y.4xx', or base channel when paired with quality
    local quality="$2"      # Optional quality: GA, preview, daily (empty implies GA)
    local version=""
    local channel=""
    if [[ "$inputVersion" == "latest" ]]; then
        # Fetch the latest version manually, because dotnet-install.sh does not support it directly
        version=$(fetch_latest_version)
    elif [[ "$inputVersion" == "lts" ]]; then
        # When user input is 'lts'
        # Then version=latest, channel=LTS
        version="latest"
        channel="LTS"
    elif [[ "$inputVersion" =~ ^[0-9]+\.[0-9]+$ ]]; then
        # When user input is form 'A.B' like '3.1'
        # Then version=latest, channel=3.1
        version="latest"
        channel="$inputVersion"
    elif [[ "$inputVersion" =~ ^[0-9]+\.[0-9]+\.[0-9]xx$ ]]; then
        # When user input is form 'A.B.Cxx' like '6.0.4xx'
        # Then version=latest, channel=6.0.4xx
        version="latest"
        channel="$inputVersion"
    else
        # Assume version is an exact version string like '6.0.413' or '8.0.100-rc.2.23425.18'
        version="$inputVersion"
    fi
    
    local cmd=("$DOTNET_INSTALL_SCRIPT" "--version" "$version" "--install-dir" "$DOTNET_ROOT")
    if [ -n "$channel" ]; then
        cmd+=("--channel" "$channel")
    fi
    if [ -n "$quality" ]; then
        cmd+=("--quality" "$quality")
    fi
    echo "Executing ${cmd[*]}"
    "${cmd[@]}"
}

# Installs a version of the .NET Runtime
# Usage: install_runtime <runtime> <version> [<quality>]
# Example: install_runtime "dotnet" "9.0"
# Example: install_runtime "aspnetcore" "10.0" "preview"
install_runtime() {
    local runtime="$1"
    local inputVersion="$2" # Could be 'latest', 'lts', 'X.Y', 'X.Y.Z'
    local quality="$3"      # Optional quality: GA, preview, daily (empty implies GA)
    local version=""
    local channel=""
    if [[ "$inputVersion" == "latest" ]]; then
        # Fetch the latest version manually, because dotnet-install.sh does not support it directly
        version=$(fetch_latest_version "$runtime")
    elif [[ "$inputVersion" == "lts" ]]; then
        # When user input is 'lts'
        # Then version=latest, channel=LTS
        version="latest"
        channel="LTS"
    elif [[ "$inputVersion" =~ ^[0-9]+\.[0-9]+$ ]]; then
        # When user input is form 'A.B' like '3.1'
        # Then version=latest, channel=3.1
        version="latest"
        channel="$inputVersion"
    else
        # Assume version is an exact version string like '6.0.21' or '8.0.0-preview.7.23375.6'
        version="$inputVersion"
    fi

    local cmd=("$DOTNET_INSTALL_SCRIPT" "--runtime" "$runtime" "--version" "$version" "--install-dir" "$DOTNET_ROOT" "--no-path")
    if [ -n "$channel" ]; then
        cmd+=("--channel" "$channel")
    fi
    if [ -n "$quality" ]; then
        cmd+=("--quality" "$quality")
    fi
    echo "Executing ${cmd[*]}"
    "${cmd[@]}"
}

# Installs one or more .NET workloads
# Usage: install_workload <workload_id> [<workload_id> ...]
# Reference: https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-workload-install
install_workloads() {
    local workloads="$@"

    echo "Installing .NET workload(s) $workloads"
    dotnet workload install $workloads --temp-dir /tmp/dotnet-workload-temp-dir

    # Clean up
    rm -r /tmp/dotnet-workload-temp-dir
}

# Input: version spec possibly containing -preview or -daily
# Supports channels in the forms:
#   A.B            (e.g. 10.0)
#   A.B.Cxx        (feature band e.g. 6.0.4xx)
#   A.B-preview    (adds quality)
#   A.B-daily
#   A.B.Cxx-preview
#   A.B.Cxx-daily
# Output (stdout): "<clean_version> <quality>"
#   - For channel specs (A.B or A.B.Cxx) without suffix -> quality is GA
#   - For channel specs with -preview/-daily suffix -> quality is preview/daily
#   - For exact version specs (contain a third numeric segment or prerelease labels beyond channel patterns, e.g. 8.0.100-rc.2.23502.2) -> quality is empty
# Examples:
#   parse_version_and_quality "10.0-preview"    => "10.0 preview"
#   parse_version_and_quality "10.0-daily"      => "10.0 daily"
#   parse_version_and_quality "10.0"            => "10.0 GA"
#   parse_version_and_quality "6.0.4xx"         => "6.0.4xx GA"
#   parse_version_and_quality "6.0.4xx-preview" => "6.0.4xx preview"
#   parse_version_and_quality "6.0.4xx-daily"   => "6.0.4xx daily"
parse_version_and_quality() {
    local input="$1"
    local quality=""
    local clean_version="$input"
    # Match feature band with quality
    if [[ "$input" =~ ^([0-9]+\.[0-9]+\.[0-9]xx)-(preview|daily)$ ]]; then
        clean_version="${BASH_REMATCH[1]}"
        quality="${BASH_REMATCH[2]}"
    # Match simple channel with quality
    elif [[ "$input" =~ ^([0-9]+\.[0-9]+)-(preview|daily)$ ]]; then
        clean_version="${BASH_REMATCH[1]}"
        quality="${BASH_REMATCH[2]}"
    # Match plain feature band channel (defaults to GA)
    elif [[ "$input" =~ ^[0-9]+\.[0-9]+\.[0-9]xx$ ]]; then
        clean_version="$input"
        quality="GA"
    # Match simple channel (defaults to GA)
    elif [[ "$input" =~ ^[0-9]+\.[0-9]+$ ]]; then
        clean_version="$input"
        quality="GA"
    else
        # Exact version (leave quality empty)
        clean_version="$input"
        quality=""
    fi
    echo "$clean_version" "$quality"
}


================================================
FILE: src/dotnet/scripts/fetch-latest-dotnet-install.sh
================================================
#!/bin/bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/devcontainers/features/tree/main/src/dotnet
# Maintainer: The Dev Container spec maintainers
#
# Run this script to replace dotnet-install.sh with the latest and greatest available version
# 
DOTNET_SCRIPTS=$(dirname "${BASH_SOURCE[0]}")
DOTNET_INSTALL_SCRIPT="$DOTNET_SCRIPTS/vendor/dotnet-install.sh"

wget https://dot.net/v1/dotnet-install.sh -O "$DOTNET_INSTALL_SCRIPT"
chmod +x "$DOTNET_INSTALL_SCRIPT"



================================================
FILE: src/dotnet/scripts/string-helpers.sh
================================================
#!/bin/bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/devcontainers/features/tree/main/src/dotnet
# Maintainer: The Dev Container spec maintainers

# Removes leading and trailing whitespace from an input string
# Usage: trim_whitespace <text>
trim_whitespace() {
    text="$1"

    # Remove leading spaces
    while [ "${text:0:1}" == " " ]; do
        text="${text:1}"
    done

    # Remove trailing spaces
    while [ "${text: -1}" == " " ]; do
        text="${text:0:-1}"
    done

    echo "$text"
}

# Splits comma-separated values into an array while ignoring empty entries
# Usage: split_csv <comma-separated-values>
split_csv() {
    local -a values=()
    while IFS="," read -ra entries; do
        for entry in "${entries[@]}"; do
            entry="$(trim_whitespace "$entry")"
            if [ -n "$entry" ]; then
                values+=("$entry")
            fi
        done
    done <<< "$1"

    echo "${values[@]}"
}


================================================
FILE: src/git/README.md
================================================

# Git (from source) (git)

Install an up-to-date version of Git, built from source as needed. Useful for when you want the latest and greatest features. Auto-detects latest stable version and installs needed dependencies.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/git:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a Git version. | string | os-provided |
| ppa | Install from PPA if available (only supported for Ubuntu distributions) | boolean | true |



## OS Support

This Feature should work on recent versions of Alpine, Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, and RockyLinux distributions with the `apk`, `apt`, `yum`, `dnf`, or `microdnf` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/git/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/git/devcontainer-feature.json
================================================
{
    "id": "git",
    "version": "1.3.4",
    "name": "Git (from source)",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/git",
    "description": "Install an up-to-date version of Git, built from source as needed. Useful for when you want the latest and greatest features. Auto-detects latest stable version and installs needed dependencies.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "system",
                "os-provided"
            ],
            "default": "os-provided",
            "description": "Select or enter a Git version."
        },
        "ppa": {
            "type": "boolean",
            "default": true,
            "description": "Install from PPA if available (only supported for Ubuntu distributions)"
        }
    },
    "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes an up-to-date version of Git, built from source as needed, pre-installed and available on the `PATH`."
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/git/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/git-from-src.md
# Maintainer: The VS Code and Codespaces Teams

GIT_VERSION=${VERSION} # 'system' checks the base image first, else installs 'latest'
USE_PPA_IF_AVAILABLE=${PPA}

GIT_CORE_PPA_ARCHIVE_GPG_KEY=F911AB184317630C59970973E363C90F8F1B6217

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Bring in ID, ID_LIKE, VERSION_ID, VERSION_CODENAME
. /etc/os-release
# Get an adjusted ID independent of distro variants
if [ "${ID}" = "debian" ] || [ "${ID_LIKE}" = "debian" ]; then
    ADJUSTED_ID="debian"
elif [ "${ID}" = "alpine" ]; then
    ADJUSTED_ID="alpine"
elif [[ "${ID}" = "rhel" || "${ID}" = "fedora" || "${ID}" = "mariner" || "${ID_LIKE}" = *"rhel"* || "${ID_LIKE}" = *"fedora"* || "${ID_LIKE}" = *"mariner"* ]]; then
    ADJUSTED_ID="rhel"
    VERSION_CODENAME="${ID}${VERSION_ID}"
else
    echo "Linux distro ${ID} not supported."
    exit 1
fi

if [ "${ADJUSTED_ID}" = "rhel" ] && [ "${VERSION_CODENAME-}" = "centos7" ]; then
    # As of 1 July 2024, mirrorlist.centos.org no longer exists.
    # Update the repo files to reference vault.centos.org.
    sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.repo
    sed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.repo
    sed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo
fi

if type apt-get > /dev/null 2>&1; then
    INSTALL_CMD=apt-get
elif type apk > /dev/null 2>&1; then
    INSTALL_CMD=apk
elif type microdnf > /dev/null 2>&1; then
    INSTALL_CMD=microdnf
elif type dnf > /dev/null 2>&1; then
    INSTALL_CMD=dnf
elif type yum > /dev/null 2>&1; then
    INSTALL_CMD=yum
else
    echo "(Error) Unable to find a supported package manager."
    exit 1
fi

# Clean up
clean_up() {
    case $ADJUSTED_ID in
        debian)
            rm -rf /var/lib/apt/lists/*
            ;;
        alpine)
            rm -rf /var/cache/apk/*
            ;;
        rhel)
            rm -rf /var/cache/dnf/*
            rm -rf /var/cache/yum/*
            ;;
    esac
}
clean_up

# Get the list of GPG key servers that are reachable
get_gpg_key_servers() {
    local curl_args=""
    local keyserver_reachable=false  # Flag to indicate if any keyserver is reachable

    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        curl_args="--proxy ${KEYSERVER_PROXY}"
    fi

    test_keyserver() {
        local keyserver="$1"
        local keyserver_curl_url="$2"
        if curl -s ${curl_args} --max-time 5 "${keyserver_curl_url}" > /dev/null; then
            echo "keyserver ${keyserver}"
            keyserver_reachable=true
        else
            echo "(*) Keyserver ${keyserver} is not reachable." >&2
        fi
    }

    # Explicitly test these in order because Bash v4.4.20 (Ubuntu Bionic)
    # enumerates associative array keys in a different order than Bash v5
    test_keyserver "hkp://keyserver.ubuntu.com"    "http://keyserver.ubuntu.com:11371"
    test_keyserver "hkp://keyserver.ubuntu.com:80" "http://keyserver.ubuntu.com"
    test_keyserver "hkp://keyserver.pgp.com"       "http://keyserver.pgp.com:11371"
    # Test this server last because keys.openpgp.org strips user IDs from keys unless
    # the owner gives permission, which causes gpg in Ubuntu Bionic to reject the key
    # (https://github.com/devcontainers/features/issues/1055)
    test_keyserver "hkps://keys.openpgp.org"       "https://keys.openpgp.org"

    if ! $keyserver_reachable; then
        echo "(!) No keyserver is reachable." >&2
        exit 1
    fi
}

# Import the specified key in a variable name passed in as
receive_gpg_keys() {
    local keys=${!1}
    local keyring_args=""
    if [ ! -z "$2" ]; then
        mkdir -p "$(dirname \"$2\")"
        keyring_args="--no-default-keyring --keyring $2"
    fi

    # Install curl
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi

    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    echo -e "disable-ipv6\n$(get_gpg_key_servers)" > ${GNUPGHOME}/dirmngr.conf
    # GPG key download sometimes fails for some reason and retrying fixes it.
    local retry_count=0
    local gpg_ok="false"
    set +e
    until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "5" ];
    do
        echo "(*) Downloading GPG key..."
        ( echo "${keys}" | xargs -n 1 gpg -q ${keyring_args} --recv-keys) 2>&1 && gpg_ok="true"
        if [ "${gpg_ok}" != "true" ]; then
            echo "(*) Failed getting key, retrying in 10s..."
            (( retry_count++ ))
            sleep 10s
        fi
    done
    set -e
    if [ "${gpg_ok}" = "false" ]; then
        echo "(!) Failed to get gpg key."
        exit 1
    fi
}

pkg_mgr_update() {
    if [ ${INSTALL_CMD} = "apt-get" ]; then
        if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
            echo "Running apt-get update..."
            ${INSTALL_CMD} update -y
        fi
    elif [ ${INSTALL_CMD} = "apk" ]; then
        if [ "$(find /var/cache/apk/* | wc -l)" = "0" ]; then
            echo "Running apk update..."
            ${INSTALL_CMD} update
        fi
    elif [ ${INSTALL_CMD} = "dnf" ] || [ ${INSTALL_CMD} = "yum" ]; then
        if [ "$(find /var/cache/${INSTALL_CMD}/* | wc -l)" = "0" ]; then
            echo "Running ${INSTALL_CMD} check-update ..."
            ${INSTALL_CMD} check-update
        fi
    fi
}


# Checks if packages are installed and installs them if not
check_packages() {
    if [ ${INSTALL_CMD} = "apt-get" ]; then
        if ! dpkg -s "$@" > /dev/null 2>&1; then
            pkg_mgr_update
            ${INSTALL_CMD} -y install --no-install-recommends "$@"
        fi
    elif [ ${INSTALL_CMD} = "apk" ]; then
        ${INSTALL_CMD} add \
            --no-cache \
            "$@"
    elif [ ${INSTALL_CMD} = "dnf" ] || [ ${INSTALL_CMD} = "yum" ]; then
        _num_pkgs=$(echo "$@" | tr ' ' \\012 | wc -l)
        _num_installed=$(${INSTALL_CMD} -C list installed "$@" | sed '1,/^Installed/d' | wc -l)
        if [ ${_num_pkgs} != ${_num_installed} ]; then
            pkg_mgr_update
            ${INSTALL_CMD} -y install "$@"
        fi
    elif [ ${INSTALL_CMD} = "microdnf" ]; then
        ${INSTALL_CMD} -y install \
            --refresh \
            --best \
            --nodocs \
            --noplugins \
            --setopt=install_weak_deps=0 \
            "$@"
    else
        echo "Linux distro ${ID} not supported."
        exit 1
    fi
}

export DEBIAN_FRONTEND=noninteractive

# Debian / Ubuntu packages

# If the os provided version is "good enough", just install that.
if [ ${GIT_VERSION} = "os-provided" ] || [ ${GIT_VERSION} = "system" ]; then
    if type git > /dev/null 2>&1; then
        echo "Detected existing system install: $(git version)"
        # Clean up
        clean_up
        exit 0
    fi

    if [ "$INSTALL_CMD" = "apt-get" ]; then
        echo "Installing git from OS apt repository"
    elif [ "$INSTALL_CMD" = "apk" ]; then
        echo "Installing git from OS apk repository"
    else
        echo "Installing git from OS yum/dnf repository"
    fi
    if [ $ID = "mariner" ]; then
        check_packages ca-certificates
    fi
    check_packages git
    # Clean up
    clean_up
    exit 0
fi

# If ubuntu, PPAs allowed, and latest - install from there
if ([ "${GIT_VERSION}" = "latest" ] || [ "${GIT_VERSION}" = "lts" ] || [ "${GIT_VERSION}" = "current" ]) && [ "${ID}" = "ubuntu" ] && [ "${USE_PPA_IF_AVAILABLE}" = "true" ]; then
    echo "Using PPA to install latest git..."
    check_packages apt-transport-https curl ca-certificates gnupg2 dirmngr
    receive_gpg_keys GIT_CORE_PPA_ARCHIVE_GPG_KEY /usr/share/keyrings/gitcoreppa-archive-keyring.gpg
    echo -e "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/gitcoreppa-archive-keyring.gpg] http://ppa.launchpad.net/git-core/ppa/ubuntu ${VERSION_CODENAME} main\ndeb-src [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/gitcoreppa-archive-keyring.gpg] http://ppa.launchpad.net/git-core/ppa/ubuntu ${VERSION_CODENAME} main" > /etc/apt/sources.list.d/git-core-ppa.list
    ${INSTALL_CMD} update
    ${INSTALL_CMD} -y install --no-install-recommends git
    rm -rf "/tmp/tmp-gnupg"
    rm -rf /var/lib/apt/lists/*
    exit 0
fi

# Install required packages to build if missing
if [ "${ADJUSTED_ID}" = "debian" ]; then

    check_packages build-essential curl ca-certificates tar gettext libssl-dev zlib1g-dev libcurl?-openssl-dev libexpat1-dev

    check_packages libpcre2-dev

    if [ "${VERSION_CODENAME}" = "focal" ] || [ "${VERSION_CODENAME}" = "bullseye" ]; then
        check_packages libpcre2-posix2
    elif [ "${VERSION_CODENAME}" = "bionic" ] || [ "${VERSION_CODENAME}" = "buster" ]; then
        check_packages libpcre2-posix0
    else
        check_packages libpcre2-posix3
    fi

elif [ "${ADJUSTED_ID}" = "alpine" ]; then

    # update build dependencies
    ${INSTALL_CMD} add --no-cache --update curl grep make zlib-dev

    # ref. <https://github.com/alpinelinux/aports/blob/32ac93ffb642031b88ba8639fbb3abb324169dea/main/git/APKBUILD#L62>
    check_packages asciidoc curl-dev expat-dev g++ gcc openssl-dev pcre2-dev perl-dev perl-error python3-dev tcl tk xmlto

elif [ "${ADJUSTED_ID}" = "rhel" ]; then
    check_packages gcc libcurl-devel expat-devel gettext-devel openssl-devel perl-devel zlib-devel cmake pcre2-devel tar gzip ca-certificates
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi
    if ! type cmp > /dev/null 2>&1; then
        check_packages diffutils
    fi
    if ! type awk > /dev/null 2>&1; then
        check_packages gawk
    fi        
    if [ $ID = "mariner" ]; then
        check_packages glibc-devel kernel-headers binutils
    fi

else
    echo "Linux distro ${ID} not supported."
    exit 1
fi

# Partial version matching
if [ "$(echo "${GIT_VERSION}" | grep -o '\.' | wc -l)" != "2" ]; then
    requested_version="${GIT_VERSION}"
    version_list="$(curl -sSL -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/git/git/tags" | grep -oP '"name":\s*"v\K[0-9]+\.[0-9]+\.[0-9]+"' | tr -d '"' | sort -rV )"
    if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "lts" ] || [ "${requested_version}" = "current" ]; then
        GIT_VERSION="$(echo "${version_list}" | head -n 1)"
    else
        set +e
        GIT_VERSION="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
        set -e
    fi
    if [ -z "${GIT_VERSION}" ] || ! echo "${version_list}" | grep "^${GIT_VERSION//./\\.}$" > /dev/null 2>&1; then
        echo "Invalid git version: ${requested_version}" >&2
        exit 1
    fi
fi

echo "Downloading source for ${GIT_VERSION}..."
curl -sL https://github.com/git/git/archive/v${GIT_VERSION}.tar.gz | tar -xzC /tmp 2>&1
echo "Building..."
cd /tmp/git-${GIT_VERSION}
git_options=("prefix=/usr/local")
git_options+=("sysconfdir=/etc")
git_options+=("USE_LIBPCRE=YesPlease")
if [ "${ADJUSTED_ID}" = "alpine" ]; then
    # ref. <https://github.com/alpinelinux/aports/blob/32ac93ffb642031b88ba8639fbb3abb324169dea/main/git/APKBUILD#L126>
    git_options+=("NO_REGEX=YesPlease")
    git_options+=("NO_GETTEXT=YesPlease")
fi
make -s "${git_options[@]}" all && make -s "${git_options[@]}" install 2>&1
rm -rf /tmp/git-${GIT_VERSION}
clean_up
echo "Done!"



================================================
FILE: src/git/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Alpine, Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, and RockyLinux distributions with the `apk`, `apt`, `yum`, `dnf`, or `microdnf` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/git-lfs/README.md
================================================

# Git Large File Support (LFS) (git-lfs)

Installs Git Large File Support (Git LFS) along with needed dependencies. Useful for base Dockerfiles that often are missing required install dependencies like git and curl.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/git-lfs:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select version of Git LFS to install | string | latest |
| autoPull | Automatically pull LFS files when creating the container.  When false, running 'git lfs pull' in the container will have the same effect. | boolean | true |
| installDirectlyFromGitHubRelease | Installs 'git-lfs' from GitHub releases instead of package manager feeds | boolean | false |



## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/git-lfs/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/git-lfs/devcontainer-feature.json
================================================
{
    "id": "git-lfs",
    "version": "1.2.5",
    "name": "Git Large File Support (LFS)",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/git-lfs",
    "description": "Installs Git Large File Support (Git LFS) along with needed dependencies. Useful for base Dockerfiles that often are missing required install dependencies like git and curl.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "none"
            ],
            "default": "latest",
            "description": "Select version of Git LFS to install"
        },
        "autoPull": {
            "type": "boolean",
            "default": true,
            "description": "Automatically pull LFS files when creating the container.  When false, running 'git lfs pull' in the container will have the same effect."
        },
        "installDirectlyFromGitHubRelease": {
            "type": "boolean",
            "default": false,
            "description": "Installs 'git-lfs' from GitHub releases instead of package manager feeds"
        }
    },
    "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes Git Large File Support (Git LFS) along with needed dependencies pre-installed and available on the `PATH`."
                    }
                ]
            }
        }
    },
    "postCreateCommand": "/usr/local/share/pull-git-lfs-artifacts.sh",
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}


================================================
FILE: src/git-lfs/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/git-lfs.md
# Maintainer: The VS Code and Codespaces Teams

GIT_LFS_VERSION=${VERSION:-"latest"}
AUTO_PULL=${AUTOPULL:="true"}
INSTALL_WITH_GITHUB=${INSTALLDIRECTLYFROMGITHUBRELEASE:="false"}

GIT_LFS_ARCHIVE_GPG_KEY_URI="https://packagecloud.io/github/git-lfs/gpgkey"
GIT_LFS_ARCHIVE_ARCHITECTURES="amd64 arm64"
GIT_LFS_ARCHIVE_VERSION_CODENAMES="stretch buster bullseye bionic focal jammy"
GIT_LFS_CHECKSUM_GPG_KEYS="0x88ace9b29196305ba9947552f1ba225c0223b187 0x86cd3297749375bcf8206715f54fe648088335a9 0xaa3b3450295830d2de6db90caba67be5a5795889"

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Get the list of GPG key servers that are reachable
get_gpg_key_servers() {
    local curl_args=""
    local keyserver_reachable=false  # Flag to indicate if any keyserver is reachable

    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        curl_args="--proxy ${KEYSERVER_PROXY}"
    fi

    test_keyserver() {
        local keyserver="$1"
        local keyserver_curl_url="$2"
        if curl -s ${curl_args} --max-time 5 "${keyserver_curl_url}" > /dev/null; then
            echo "keyserver ${keyserver}"
            keyserver_reachable=true
        else
            echo "(*) Keyserver ${keyserver} is not reachable." >&2
        fi
    }

    # Explicitly test these in order because Bash v4.4.20 (Ubuntu Bionic)
    # enumerates associative array keys in a different order than Bash v5
    test_keyserver "hkp://keyserver.ubuntu.com"    "http://keyserver.ubuntu.com:11371"
    test_keyserver "hkp://keyserver.ubuntu.com:80" "http://keyserver.ubuntu.com"
    test_keyserver "hkp://keyserver.pgp.com"       "http://keyserver.pgp.com:11371"
    # Test this server last because keys.openpgp.org strips user IDs from keys unless
    # the owner gives permission, which causes gpg in Ubuntu Bionic to reject the key
    # (https://github.com/devcontainers/features/issues/1055)
    test_keyserver "hkps://keys.openpgp.org"       "https://keys.openpgp.org"

    if ! $keyserver_reachable; then
        echo "(!) No keyserver is reachable." >&2
        exit 1
    fi
}

# Import the specified key in a variable name passed in as 
receive_gpg_keys() {
    local keys=${!1}

    # Install curl
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi

    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    echo -e "disable-ipv6\n$(get_gpg_key_servers)" > ${GNUPGHOME}/dirmngr.conf
    # GPG key download sometimes fails for some reason and retrying fixes it.
    local retry_count=0
    local gpg_ok="false"
    set +e
    until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "5" ]; 
    do
        echo "(*) Downloading GPG key..."
        ( echo "${keys}" | xargs -n 1 gpg --recv-keys) 2>&1 && gpg_ok="true"
        if [ "${gpg_ok}" != "true" ]; then
            echo "(*) Failed getting key, retrying in 10s..."
            (( retry_count++ ))
            sleep 10s
        fi
    done
    set -e
    if [ "${gpg_ok}" = "false" ]; then
        echo "(!) Failed to get gpg key."
        exit 1
    fi
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

install_using_apt() {
    # Soft version matching
    if [ "${GIT_LFS_VERSION}" != "latest" ] && [ "${GIT_LFS_VERSION}" != "lts" ] && [ "${GIT_LFS_VERSION}" != "stable" ]; then
        find_version_from_git_tags GIT_LFS_VERSION "https://github.com/git-lfs/git-lfs"
        version_suffix="=${GIT_LFS_VERSION}"
    else
        version_suffix=""
    fi
    # Install
    curl -sSL "${GIT_LFS_ARCHIVE_GPG_KEY_URI}" | gpg --dearmor > /usr/share/keyrings/gitlfs-archive-keyring.gpg
    echo -e "deb [arch=${architecture} signed-by=/usr/share/keyrings/gitlfs-archive-keyring.gpg] https://packagecloud.io/github/git-lfs/${ID} ${VERSION_CODENAME} main\ndeb-src [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/gitlfs-archive-keyring.gpg] https://packagecloud.io/github/git-lfs/${ID} ${VERSION_CODENAME} main" > /etc/apt/sources.list.d/git-lfs.list

    if ! (apt-get update && apt-get install -yq git-lfs${version_suffix}); then
        rm -f /etc/apt/sources.list.d/git-lfs.list
        echo "Could not fetch git-lfs from apt"
        return 1
    fi

    git-lfs install --skip-repo
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    repo_url=$1
    curl -s "$repo_url" | jq -r 'del(.[].assets) | .[0].tag_name'
}

install_from_release() {
    git_lfs_filename="git-lfs-linux-${architecture}-v${GIT_LFS_VERSION}.tar.gz"
    echo "Looking for release artfact: ${git_lfs_filename}"
    curl -sSL -o "${git_lfs_filename}" "https://github.com/git-lfs/git-lfs/releases/download/v${GIT_LFS_VERSION}/${git_lfs_filename}"
}

install_using_github() {
    echo "(*) No apt package for ${VERSION_CODENAME} ${architecture}. Installing manually."
    mkdir -p /tmp/git-lfs
    cd /tmp/git-lfs
    find_version_from_git_tags GIT_LFS_VERSION "https://github.com/git-lfs/git-lfs"
    install_from_release

    if grep -q "Not Found" "${git_lfs_filename}"; then
        echo -e "\n(!) Failed to fetch the latest artifacts for Git lfs v${GIT_LFS_VERSION}..."
        repo_url=https://api.github.com/repos/git-lfs/git-lfs/releases
        requested_version=$(get_previous_version "${repo_url}")
        echo -e "\nAttempting to install ${requested_version}"
        GIT_LFS_VERSION=${requested_version#v}
        install_from_release
    fi

    # Verify file
    curl -sSL -o "sha256sums.asc" "https://github.com/git-lfs/git-lfs/releases/download/v${GIT_LFS_VERSION}/sha256sums.asc"
    receive_gpg_keys GIT_LFS_CHECKSUM_GPG_KEYS
    gpg -q --decrypt "sha256sums.asc" > sha256sums
    sha256sum --ignore-missing -c "sha256sums"
    # Extract and install
    echo "Validated release artifact integrity."
    echo "Starting to extract..."
    tar xf "${git_lfs_filename}" -C .
    echo "Installing..."
    if [ -f "./install.sh" ]; then
        ./install.sh
    else
        # Starting around v3.2.0, the release
        # artifact file structure changed slightly
        enclosed_folder="git-lfs-${GIT_LFS_VERSION}"
        cd ${enclosed_folder}
            ./install.sh
        cd ../
    fi
    rm -rf /tmp/git-lfs /tmp/tmp-gnupg
}

export DEBIAN_FRONTEND=noninteractive

# Install git, curl, gpg, dirmngr and debian-archive-keyring if missing
. /etc/os-release
check_packages curl ca-certificates gnupg2 dirmngr apt-transport-https jq
if ! type git > /dev/null 2>&1; then
    check_packages git
fi
if [ "${ID}" = "debian" ]; then
    check_packages debian-archive-keyring
fi

# Install Git LFS
echo "Installing Git LFS..."
architecture="$(dpkg --print-architecture)"
if [[ "${GIT_LFS_ARCHIVE_ARCHITECTURES}" = *"${architecture}"* ]] && [[  "${GIT_LFS_ARCHIVE_VERSION_CODENAMES}" = *"${VERSION_CODENAME}"* ]] && [[ "${INSTALL_WITH_GITHUB}" = "false" ]]; then
    install_using_apt || INSTALL_WITH_GITHUB="true"
else
    INSTALL_WITH_GITHUB="true"
fi

# If no archive exists or apt install fails, try direct from github
if [ "${INSTALL_WITH_GITHUB}" = "true" ]; then
    install_using_github
fi

# --- Generate a 'pull-git-lfs-artifacts.sh' script to be executed by the 'postCreateCommand' lifecycle hook
PULL_GIT_LFS_SCRIPT_PATH="/usr/local/share/pull-git-lfs-artifacts.sh"

tee "$PULL_GIT_LFS_SCRIPT_PATH" > /dev/null \
<< EOF
#!/bin/sh
set -e
AUTO_PULL=${AUTO_PULL}
EOF

tee -a "$PULL_GIT_LFS_SCRIPT_PATH" > /dev/null \
<< 'EOF'

echo "Fetching git lfs artifacts..."

if [ "${AUTO_PULL}" != "true" ]; then
    echo "(!) Skipping 'git lfs pull' because 'autoPull' is not set to 'true'"
    exit 0
fi

# Check if repo is a git lfs repo.
if ! git lfs ls-files > /dev/null 2>&1; then
    echo "(!) Skipping automatic 'git lfs pull' because no git lfs files were detected"
    exit 0
fi
git lfs install
git lfs pull
EOF

chmod 755 "$PULL_GIT_LFS_SCRIPT_PATH"

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"



================================================
FILE: src/git-lfs/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/github-cli/README.md
================================================

# GitHub CLI (github-cli)

Installs the GitHub CLI. Auto-detects latest version and installs needed dependencies.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/github-cli:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select version of the GitHub CLI, if not latest. | string | latest |
| installDirectlyFromGitHubRelease | - | boolean | true |



## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/github-cli/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/github-cli/devcontainer-feature.json
================================================
{
    "id": "github-cli",
    "version": "1.0.15",
    "name": "GitHub CLI",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/github-cli",
    "description": "Installs the GitHub CLI. Auto-detects latest version and installs needed dependencies.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "none"
            ],
            "default": "latest",
            "description": "Select version of the GitHub CLI, if not latest."
        },
        "installDirectlyFromGitHubRelease": {
            "type": "boolean",
            "default": true
        }
    },
    "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes the GitHub CLI (`gh`), which is pre-installed and available on the `PATH`. IMPORTANT: `gh api -f` does not support object values, use multiple `-f` flags with hierarchical keys and string values instead. When using GitHub actions `actions/upload-artifact` or `actions/download-artifact` use v4 or later."
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils",
        "ghcr.io/devcontainers/features/git"
    ]
}




================================================
FILE: src/github-cli/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/github.md
# Maintainer: The VS Code and Codespaces Teams

CLI_VERSION=${VERSION:-"latest"}
INSTALL_DIRECTLY_FROM_GITHUB_RELEASE=${INSTALLDIRECTLYFROMGITHUBRELEASE:-"true"}

GITHUB_CLI_ARCHIVE_GPG_KEY=23F3D4EA75716059

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Get the list of GPG key servers that are reachable
get_gpg_key_servers() {
    declare -A keyservers_curl_map=(
        ["hkp://keyserver.ubuntu.com"]="http://keyserver.ubuntu.com:11371"
        ["hkp://keyserver.ubuntu.com:80"]="http://keyserver.ubuntu.com"
        ["hkps://keys.openpgp.org"]="https://keys.openpgp.org"
        ["hkp://keyserver.pgp.com"]="http://keyserver.pgp.com:11371"
    )

    local curl_args=""
    local keyserver_reachable=false  # Flag to indicate if any keyserver is reachable

    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        curl_args="--proxy ${KEYSERVER_PROXY}"
    fi

    for keyserver in "${!keyservers_curl_map[@]}"; do
        local keyserver_curl_url="${keyservers_curl_map[${keyserver}]}"
        if curl -s ${curl_args} --max-time 5 ${keyserver_curl_url} > /dev/null; then
            echo "keyserver ${keyserver}"
            keyserver_reachable=true
        else
            echo "(*) Keyserver ${keyserver} is not reachable." >&2
        fi
    done

    if ! $keyserver_reachable; then
        echo "(!) No keyserver is reachable." >&2
        exit 1
    fi
}

# Import the specified key in a variable name passed in as 
receive_gpg_keys() {
    local keys=${!1}
    local keyring_args=""
    if [ ! -z "$2" ]; then
        keyring_args="--no-default-keyring --keyring $2"
    fi

    # Install curl
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi

    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    echo -e "disable-ipv6\n$(get_gpg_key_servers)" > ${GNUPGHOME}/dirmngr.conf
    # GPG key download sometimes fails for some reason and retrying fixes it.
    local retry_count=0
    local gpg_ok="false"
    set +e
    until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "5" ]; 
    do
        echo "(*) Downloading GPG key..."
        ( echo "${keys}" | xargs -n 1 gpg -q ${keyring_args} --recv-keys) 2>&1 && gpg_ok="true"
        if [ "${gpg_ok}" != "true" ]; then
            echo "(*) Failed getting key, retrying in 10s..."
            (( retry_count++ ))
            sleep 10s
        fi
    done
    set -e
    if [ "${gpg_ok}" = "false" ]; then
        echo "(!) Failed to get gpg key."
        exit 1
    fi
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Fall back on direct download if no apt package exists
# Fetches .deb file to be installed with dpkg
install_deb_using_github() {
    check_packages wget
    arch=$(dpkg --print-architecture)

    find_version_from_git_tags CLI_VERSION https://github.com/cli/cli
    cli_filename="gh_${CLI_VERSION}_linux_${arch}.deb"

    mkdir -p /tmp/ghcli
    pushd /tmp/ghcli
    wget -q --show-progress --progress=dot:giga https://github.com/cli/cli/releases/download/v${CLI_VERSION}/${cli_filename}
    exit_code=$?
    set -e
    if [ "$exit_code" != "0" ]; then
        # Handle situation where git tags are ahead of what was is available to actually download
        echo "(!) github-cli version ${CLI_VERSION} failed to download. Attempting to fall back one version to retry..."
        find_prev_version_from_git_tags CLI_VERSION https://github.com/cli/cli
        wget -q --show-progress --progress=dot:giga https://github.com/cli/cli/releases/download/v${CLI_VERSION}/${cli_filename}
    fi

    dpkg -i /tmp/ghcli/${cli_filename}
    popd
    rm -rf /tmp/ghcli
}

export DEBIAN_FRONTEND=noninteractive

# Install curl, apt-transport-https, curl, gpg, or dirmngr, git if missing
check_packages curl ca-certificates apt-transport-https dirmngr gnupg2
if ! type git > /dev/null 2>&1; then
    check_packages git
fi

# Soft version matching
if [ "${CLI_VERSION}" != "latest" ] && [ "${CLI_VERSION}" != "lts" ] && [ "${CLI_VERSION}" != "stable" ]; then
    find_version_from_git_tags CLI_VERSION "https://github.com/cli/cli"
    version_suffix="=${CLI_VERSION}"
else
    version_suffix=""
fi

# Install the GitHub CLI
echo "Downloading github CLI..."

if [ "${INSTALL_DIRECTLY_FROM_GITHUB_RELEASE}" = "true" ]; then
    install_deb_using_github
else
   # Import key safely (new method rather than deprecated apt-key approach) and install
    . /etc/os-release
    receive_gpg_keys GITHUB_CLI_ARCHIVE_GPG_KEY /usr/share/keyrings/githubcli-archive-keyring.gpg
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" > /etc/apt/sources.list.d/github-cli.list
    apt-get update
    apt-get -y install "gh${version_suffix}"
    rm -rf "/tmp/gh/gnupg"
    echo "Done!"
fi

# Clean up
rm -rf /var/lib/apt/lists/*



================================================
FILE: src/github-cli/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/go/README.md
================================================

# Go (go)

Installs Go and common Go utilities. Auto-detects latest version and installs needed dependencies.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/go:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a Go version to install | string | latest |
| golangciLintVersion | Version of golangci-lint to install | string | latest |

## Customizations

### VS Code Extensions

- `golang.Go`



## OS Support

This Feature should work on recent versions of Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, and RockyLinux distributions with the apt, yum, dnf, or microdnf package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/go/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/go/devcontainer-feature.json
================================================
{
    "id": "go",
    "version": "1.3.2",
    "name": "Go",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/go",
    "description": "Installs Go and common Go utilities. Auto-detects latest version and installs needed dependencies.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "none",
                "1.24",
                "1.23"
            ],
            "default": "latest",
            "description": "Select or enter a Go version to install"
        },
        "golangciLintVersion": {
            "type": "string",
            "default": "latest",
            "description": "Version of golangci-lint to install"
        }
    },
    "init": true,
    "customizations": {
        "vscode": {
            "extensions": [
                "golang.Go"
            ],
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes Go and common Go utilities pre-installed and available on the `PATH`, along with the Go language extension for Go development."
                    }
                ]
            }
        }
    },
    "containerEnv": {
        "GOROOT": "/usr/local/go",
        "GOPATH": "/go",
        "PATH": "/usr/local/go/bin:/go/bin:${PATH}"
    },
    "capAdd": [
        "SYS_PTRACE"
    ],
    "securityOpt": [
        "seccomp=unconfined"
    ],
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/go/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/go.md
# Maintainer: The VS Code and Codespaces Teams

TARGET_GO_VERSION="${VERSION:-"latest"}"
GOLANGCILINT_VERSION="${GOLANGCILINTVERSION:-"latest"}"

TARGET_GOROOT="${TARGET_GOROOT:-"/usr/local/go"}"
TARGET_GOPATH="${TARGET_GOPATH:-"/go"}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
INSTALL_GO_TOOLS="${INSTALL_GO_TOOLS:-"true"}"

# https://www.google.com/linuxrepositories/
GO_GPG_KEY_URI="https://dl.google.com/linux/linux_signing_key.pub"

set -e

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Bring in ID, ID_LIKE, VERSION_ID, VERSION_CODENAME
. /etc/os-release
# Get an adjusted ID independent of distro variants
MAJOR_VERSION_ID=$(echo ${VERSION_ID} | cut -d . -f 1)
if [ "${ID}" = "debian" ] || [ "${ID_LIKE}" = "debian" ]; then
    ADJUSTED_ID="debian"
elif [[ "${ID}" = "rhel" || "${ID}" = "fedora" || "${ID}" = "mariner" || "${ID_LIKE}" = *"rhel"* || "${ID_LIKE}" = *"fedora"* || "${ID_LIKE}" = *"mariner"* ]]; then
    ADJUSTED_ID="rhel"
    if [[ "${ID}" = "rhel" ]] || [[ "${ID}" = *"alma"* ]] || [[ "${ID}" = *"rocky"* ]]; then
        VERSION_CODENAME="rhel${MAJOR_VERSION_ID}"
    else
        VERSION_CODENAME="${ID}${MAJOR_VERSION_ID}"
    fi
else
    echo "Linux distro ${ID} not supported."
    exit 1
fi

if [ "${ADJUSTED_ID}" = "rhel" ] && [ "${VERSION_CODENAME-}" = "centos7" ]; then
    # As of 1 July 2024, mirrorlist.centos.org no longer exists.
    # Update the repo files to reference vault.centos.org.
    sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.repo
    sed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.repo
    sed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo
fi

# Setup INSTALL_CMD & PKG_MGR_CMD
if type apt-get > /dev/null 2>&1; then
    PKG_MGR_CMD=apt-get
    INSTALL_CMD="${PKG_MGR_CMD} -y install --no-install-recommends"
elif type microdnf > /dev/null 2>&1; then
    PKG_MGR_CMD=microdnf
    INSTALL_CMD="${PKG_MGR_CMD} ${INSTALL_CMD_ADDL_REPOS} -y install --refresh --best --nodocs --noplugins --setopt=install_weak_deps=0"
elif type dnf > /dev/null 2>&1; then
    PKG_MGR_CMD=dnf
    INSTALL_CMD="${PKG_MGR_CMD} ${INSTALL_CMD_ADDL_REPOS} -y install --refresh --best --nodocs --noplugins --setopt=install_weak_deps=0"
else
    PKG_MGR_CMD=yum
    INSTALL_CMD="${PKG_MGR_CMD} ${INSTALL_CMD_ADDL_REPOS} -y install --noplugins --setopt=install_weak_deps=0"
fi

# Clean up
clean_up() {
    case ${ADJUSTED_ID} in
        debian)
            rm -rf /var/lib/apt/lists/*
            ;;
        rhel)
            rm -rf /var/cache/dnf/* /var/cache/yum/*
            rm -rf /tmp/yum.log
            rm -rf ${GPG_INSTALL_PATH}
            ;;
    esac
}
clean_up


# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

pkg_mgr_update() {
    case $ADJUSTED_ID in
        debian)
            if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
                echo "Running apt-get update..."
                ${PKG_MGR_CMD} update -y
            fi
            ;;
        rhel)
            if [ ${PKG_MGR_CMD} = "microdnf" ]; then
                if [ "$(ls /var/cache/yum/* 2>/dev/null | wc -l)" = 0 ]; then
                    echo "Running ${PKG_MGR_CMD} makecache ..."
                    ${PKG_MGR_CMD} makecache
                fi
            else
                if [ "$(ls /var/cache/${PKG_MGR_CMD}/* 2>/dev/null | wc -l)" = 0 ]; then
                    echo "Running ${PKG_MGR_CMD} check-update ..."
                    set +e
                    ${PKG_MGR_CMD} check-update
                    rc=$?
                    if [ $rc != 0 ] && [ $rc != 100 ]; then
                        exit 1
                    fi
                    set -e
                fi
            fi
            ;;
    esac
}

# Checks if packages are installed and installs them if not
check_packages() {
    case ${ADJUSTED_ID} in
        debian)
            if ! dpkg -s "$@" > /dev/null 2>&1; then
                pkg_mgr_update
                ${INSTALL_CMD} "$@"
            fi
            ;;
        rhel)
            if ! rpm -q "$@" > /dev/null 2>&1; then
                pkg_mgr_update
                ${INSTALL_CMD} "$@"
            fi
            ;;
    esac
}

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# Some distributions do not install awk by default (e.g. Mariner)
if ! type awk >/dev/null 2>&1; then
    check_packages awk
fi

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

export DEBIAN_FRONTEND=noninteractive

check_packages ca-certificates gnupg2 tar gcc make pkg-config

if [ $ADJUSTED_ID = "debian" ]; then
    check_packages g++ libc6-dev
else
    check_packages gcc-c++ glibc-devel
fi
# Install curl, git, other dependencies if missing
if ! type curl > /dev/null 2>&1; then
    check_packages curl
fi
if ! type git > /dev/null 2>&1; then
    check_packages git
fi
# Some systems, e.g. Mariner, still a few more packages
if ! type as > /dev/null 2>&1; then
    check_packages binutils
fi
if ! [ -f /usr/include/linux/errno.h ]; then
    check_packages kernel-headers
fi
# Minimal RHEL install may need findutils installed
if ! [ -f /usr/bin/find ]; then
    check_packages findutils
fi

# Get closest match for version number specified
find_version_from_git_tags TARGET_GO_VERSION "https://go.googlesource.com/go" "tags/go" "." "true"

architecture="$(uname -m)"
case $architecture in
    x86_64) architecture="amd64";;
    aarch64 | armv8*) architecture="arm64";;
    aarch32 | armv7* | armvhf*) architecture="armv6l";;
    i?86) architecture="386";;
    *) echo "(!) Architecture $architecture unsupported"; exit 1 ;;
esac

# Install Go
umask 0002
if ! cat /etc/group | grep -e "^golang:" > /dev/null 2>&1; then
    groupadd -r golang
fi
usermod -a -G golang "${USERNAME}"
mkdir -p "${TARGET_GOROOT}" "${TARGET_GOPATH}"

if [[ "${TARGET_GO_VERSION}" != "none" ]] && [[ "$(go version 2>/dev/null)" != *"${TARGET_GO_VERSION}"* ]]; then
    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    curl -sSL -o /tmp/tmp-gnupg/golang_key "${GO_GPG_KEY_URI}"
    gpg -q --import /tmp/tmp-gnupg/golang_key
    echo "Downloading Go ${TARGET_GO_VERSION}..."
    set +e
    curl -fsSL -o /tmp/go.tar.gz "https://golang.org/dl/go${TARGET_GO_VERSION}.linux-${architecture}.tar.gz"
    exit_code=$?
    set -e
    if [ "$exit_code" != "0" ]; then
        echo "(!) Download failed."
        # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
        set +e
        major="$(echo "${TARGET_GO_VERSION}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${TARGET_GO_VERSION}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${TARGET_GO_VERSION}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"
        # Handle Go's odd version pattern where "0" releases omit the last part
        if [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            TARGET_GO_VERSION="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags TARGET_GO_VERSION "https://go.googlesource.com/go" "tags/go" "." "true"
        else 
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ]; then
                TARGET_GO_VERSION="${major}.${minor}"
            else 
                TARGET_GO_VERSION="${major}.${minor}.${breakfix}"
            fi
        fi
        set -e
        echo "Trying ${TARGET_GO_VERSION}..."
        curl -fsSL -o /tmp/go.tar.gz "https://golang.org/dl/go${TARGET_GO_VERSION}.linux-${architecture}.tar.gz"
    fi
    curl -fsSL -o /tmp/go.tar.gz.asc "https://golang.org/dl/go${TARGET_GO_VERSION}.linux-${architecture}.tar.gz.asc"
    gpg --verify /tmp/go.tar.gz.asc /tmp/go.tar.gz
    echo "Extracting Go ${TARGET_GO_VERSION}..."
    tar -xzf /tmp/go.tar.gz -C "${TARGET_GOROOT}" --strip-components=1
    rm -rf /tmp/go.tar.gz /tmp/go.tar.gz.asc /tmp/tmp-gnupg
else
    echo "(!) Go is already installed with version ${TARGET_GO_VERSION}. Skipping."
fi

# Install Go tools that are isImportant && !replacedByGopls based on
# https://github.com/golang/vscode-go/blob/v0.38.0/src/goToolsInformation.ts
GO_TOOLS="\
    golang.org/x/tools/gopls@latest \
    honnef.co/go/tools/cmd/staticcheck@latest \
    golang.org/x/lint/golint@latest \
    github.com/mgechev/revive@latest \
    github.com/go-delve/delve/cmd/dlv@latest \
    github.com/fatih/gomodifytags@latest \
    github.com/haya14busa/goplay/cmd/goplay@latest \
    github.com/cweill/gotests/gotests@latest \ 
    github.com/josharian/impl@latest"

if [ "${INSTALL_GO_TOOLS}" = "true" ]; then
    echo "Installing common Go tools..."
    export PATH=${TARGET_GOROOT}/bin:${PATH}
    mkdir -p /tmp/gotools /usr/local/etc/vscode-dev-containers ${TARGET_GOPATH}/bin
    cd /tmp/gotools
    export GOPATH=/tmp/gotools
    export GOCACHE=/tmp/gotools/cache

    # Use go get for versions of go under 1.16
    go_install_command=install
    if [[ "1.16" > "$(go version | grep -oP 'go\K[0-9]+\.[0-9]+(\.[0-9]+)?')" ]]; then
        export GO111MODULE=on
        go_install_command=get
        echo "Go version < 1.16, using go get."
    fi 

    (echo "${GO_TOOLS}" | xargs -n 1 go ${go_install_command} -v )2>&1 | tee -a /usr/local/etc/vscode-dev-containers/go.log

    # Move Go tools into path and clean up
    if [ -d /tmp/gotools/bin ]; then
        mv /tmp/gotools/bin/* ${TARGET_GOPATH}/bin/
        rm -rf /tmp/gotools
    fi

    # Install golangci-lint from precompiled binares
    if [ "$GOLANGCILINT_VERSION" = "latest" ] || [ "$GOLANGCILINT_VERSION" = "" ]; then
        echo "Installing golangci-lint latest..."
        curl -fsSL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | \
            sh -s -- -b "${TARGET_GOPATH}/bin"
    else
        echo "Installing golangci-lint ${GOLANGCILINT_VERSION}..."
        curl -fsSL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | \
            sh -s -- -b "${TARGET_GOPATH}/bin" "v${GOLANGCILINT_VERSION}"
    fi
fi


chown -R "${USERNAME}:golang" "${TARGET_GOROOT}" "${TARGET_GOPATH}"
chmod -R g+r+w "${TARGET_GOROOT}" "${TARGET_GOPATH}"
find "${TARGET_GOROOT}" -type d -print0 | xargs -n 1 -0 chmod g+s
find "${TARGET_GOPATH}" -type d -print0 | xargs -n 1 -0 chmod g+s

# Clean up
clean_up

echo "Done!"



================================================
FILE: src/go/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, and RockyLinux distributions with the apt, yum, dnf, or microdnf package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/hugo/README.md
================================================

# Hugo (hugo)



## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/hugo:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a version. | string | latest |
| extended | Install Hugo extended for SASS/SCSS changes | boolean | false |



## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/hugo/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/hugo/devcontainer-feature.json
================================================
{
  "id": "hugo",
  "version": "1.1.3",
  "name": "Hugo",
  "documentationURL": "https://github.com/devcontainers/features/tree/main/src/hugo",
  "options": {
    "version": {
      "type": "string",
      "proposals": [
        "latest"
      ],
      "default": "latest",
      "description": "Select or enter a version."
    },
    "extended": {
      "type": "boolean",
      "default": false,
      "description": "Install Hugo extended for SASS/SCSS changes"
    }
  },
  "containerEnv": {
    "HUGO_DIR": "/usr/local/hugo",
    "PATH": "/usr/local/hugo/bin:${PATH}"
  },
  "customizations": {
    "vscode": {
      "settings": {
        "github.copilot.chat.codeGeneration.instructions": [
          {
            "text": "This dev container includes Hugo, a popular open-source static site generator written in Go, pre-installed and available on the `PATH`."
          }
        ]
      }
    }
  },
  "installsAfter": [
      "ghcr.io/devcontainers/features/common-utils"
  ]
}



================================================
FILE: src/hugo/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/hugo.md
# Maintainer: The VS Code and Codespaces Teams

VERSION="${VERSION:-"latest"}"

USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="${UPDATE_RC:-"true"}"

HUGO_DIR="${HUGO_DIR:-"/usr/local/hugo"}"

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

architecture="$(uname -m)"
if [ "${architecture}" != "amd64" ] && [ "${architecture}" != "x86_64" ] && [ "${architecture}" != "arm64" ] && [ "${architecture}" != "aarch64" ]; then
    echo "(!) Architecture $architecture unsupported"
    exit 1
fi

updaterc() {
    if [ "${UPDATE_RC}" = "true" ]; then
        echo "Updating /etc/bash.bashrc and /etc/zsh/zshrc..."
        if [[ "$(cat /etc/bash.bashrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/bash.bashrc
        fi
        if [ -f "/etc/zsh/zshrc" ] && [[ "$(cat /etc/zsh/zshrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/zsh/zshrc
        fi
    fi
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Install dependencies
check_packages curl ca-certificates tar

# Fetch latest version of Hugo if needed
if [ "${VERSION}" = "latest" ] || [ "${VERSION}" = "lts" ]; then
    export VERSION=$(curl -s https://api.github.com/repos/gohugoio/hugo/releases/latest | grep "tag_name" | awk '{print substr($2, 3, length($2)-4)}')
fi

# Install Hugo if it's missing
if ! hugo version &> /dev/null ; then
    if ! cat /etc/group | grep -e "^hugo:" > /dev/null 2>&1; then
        groupadd -r hugo
    fi
    usermod -a -G hugo "${USERNAME}"

    echo "Installing Hugo..."
    installation_dir="$HUGO_DIR/bin"
    mkdir -p "$installation_dir"

    # Install ARM or x86 version of hugo based on current machine architecture
    if [ "$(uname -m)" == "aarch64" ]; then
        arch="ARM64"
    else
        arch="64bit"
    fi

    # Install extended version of hugo if desired
    if [ "${EXTENDED}" = "true" ]; then
        extended="extended_"
    else
        extended=""
    fi

    hugo_filename="hugo_${extended}${VERSION}_Linux-${arch}.tar.gz"

    curl -fsSLO --compressed "https://github.com/gohugoio/hugo/releases/download/v${VERSION}/${hugo_filename}"
    tar -xzf "$hugo_filename" -C "$installation_dir"
    rm "$hugo_filename"

    updaterc "export HUGO_DIR=${installation_dir}"

    chown -R "${USERNAME}:hugo" "${HUGO_DIR}"
    chmod -R g+r+w "${HUGO_DIR}"
    find "${HUGO_DIR}" -type d -print0 | xargs -n 1 -0 chmod g+s
fi

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"



================================================
FILE: src/hugo/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/java/README.md
================================================

# Java (via SDKMAN!) (java)

Installs Java, SDKMAN! (if not installed), and needed dependencies.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/java:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a Java version to install | string | latest |
| additionalVersions | Enter additional Java versions, separated by commas. | string | - |
| jdkDistro | Select or enter a JDK distribution | string | ms |
| installGradle | Install Gradle, a build automation tool for multi-language software development | boolean | false |
| gradleVersion | Select or enter a Gradle version | string | latest |
| installMaven | Install Maven, a management tool for Java | boolean | false |
| mavenVersion | Select or enter a Maven version | string | latest |
| installAnt | Install Ant, a software tool for automating software build processes | boolean | false |
| antVersion | Select or enter an Ant version | string | latest |
| installGroovy | Install Groovy, powerful, optionally typed and dynamic language with static-typing and static compilation capabilities | boolean | false |
| groovyVersion | Select or enter a Groovy version | string | latest |

## Customizations

### VS Code Extensions

- `vscjava.vscode-java-pack`

## License

For the Java Feature from this repository, see [NOTICE.txt](https://github.com/devcontainers/features/tree/main/src/java/NOTICE.txt) for licensing information on JDK distributions.


## OS Support

Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, and RockyLinux distributions with the `apt`, `yum`, `dnf`, or `microdnf` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/java/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/java/devcontainer-feature.json
================================================
{
  "id": "java",
  "version": "1.6.3",
  "name": "Java (via SDKMAN!)",
  "documentationURL": "https://github.com/devcontainers/features/tree/main/src/java",
  "description": "Installs Java, SDKMAN! (if not installed), and needed dependencies.",
  "options": {
    "version": {
      "type": "string",
      "proposals": [
        "latest",
        "none",
        "21",
        "17",
        "11",
        "8"
      ],
      "default": "latest",
      "description": "Select or enter a Java version to install"
    },
    "additionalVersions": {
      "type": "string",
      "default": "",
      "description": "Enter additional Java versions, separated by commas."
    },
    "jdkDistro": {
      "type": "string",
      "proposals": [
        "ms",
        "open",
        "oracle",
        "tem",
        "amzn"
      ],
      "default": "ms",
      "description": "Select or enter a JDK distribution"
    },
    "installGradle": {
      "type": "boolean",
      "default": false,
      "description": "Install Gradle, a build automation tool for multi-language software development"
    },
    "gradleVersion": {
      "type": "string",
      "proposals": [
        "latest",
        "7.5.1",
        "6.9.3",
        "5.6.4"
      ],
      "default": "latest",
      "description": "Select or enter a Gradle version"
    },
    "installMaven": {
      "type": "boolean",
      "default": false,
      "description": "Install Maven, a management tool for Java"
    },
    "mavenVersion": {
      "type": "string",
      "proposals": [
        "latest",
        "3.8.6",
        "3.6.3",
        "3.5.4"
      ],
      "default": "latest",
      "description": "Select or enter a Maven version"
    },
    "installAnt": {
      "type": "boolean",
      "default": false,
      "description": "Install Ant, a software tool for automating software build processes"
    },
    "antVersion": {
      "type": "string",
      "proposals": [
        "latest",
        "1.10.12",
        "1.9.15"
      ],
      "default": "latest",
      "description": "Select or enter an Ant version"
    },
    "installGroovy": {
      "type": "boolean",
      "default": false,
      "description": "Install Groovy, powerful, optionally typed and dynamic language with static-typing and static compilation capabilities"
    },
    "groovyVersion": {
      "type": "string",
      "proposals": [
        "latest",
        "2.5.22",
        "3.0.19",
        "4.0.16"
      ],
      "default": "latest",
      "description": "Select or enter a Groovy version"
    }
  },
  "customizations": {
    "vscode": {
      "extensions": [
        "vscjava.vscode-java-pack"
      ],
      "settings": {
        "java.import.gradle.java.home": "/usr/local/sdkman/candidates/java/current",
        "github.copilot.chat.codeGeneration.instructions": [
          {
            "text": "This dev container includes Java, SDKMAN! and needed dependencies pre-installed and available on the `PATH`, along with the Java language extension pack for Java development."
          }
        ]
      }
    }
  },
  "containerEnv": {
    "SDKMAN_DIR": "/usr/local/sdkman",
    "JAVA_HOME": "/usr/local/sdkman/candidates/java/current",
    "PATH": "/usr/local/sdkman/bin:/usr/local/sdkman/candidates/java/current/bin:/usr/local/sdkman/candidates/gradle/current/bin:/usr/local/sdkman/candidates/maven/current/bin:/usr/local/sdkman/candidates/ant/current/bin:${PATH}"
  },
  "installsAfter": [
    "ghcr.io/devcontainers/features/common-utils"
  ]
}


================================================
FILE: src/java/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/java.md
# Maintainer: The VS Code and Codespaces Teams
#
# Syntax: ./java-debian.sh [JDK version] [SDKMAN_DIR] [non-root user] [Add to rc files flag]

JAVA_VERSION="${VERSION:-"latest"}"
INSTALL_GRADLE="${INSTALLGRADLE:-"false"}"
GRADLE_VERSION="${GRADLEVERSION:-"latest"}"
INSTALL_MAVEN="${INSTALLMAVEN:-"false"}"
MAVEN_VERSION="${MAVENVERSION:-"latest"}"
INSTALL_ANT="${INSTALLANT:-"false"}"
ANT_VERSION="${ANTVERSION:-"latest"}"
INSTALL_GROOVY="${INSTALLGROOVY:-"false"}"
GROOVY_VERSION="${GROOVYVERSION:-"latest"}"
JDK_DISTRO="${JDKDISTRO:-"ms"}"

export SDKMAN_DIR="${SDKMAN_DIR:-"/usr/local/sdkman"}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="${UPDATE_RC:-"true"}"

# Comma-separated list of java versions to be installed
# alongside JAVA_VERSION, but not set as default.
ADDITIONAL_VERSIONS="${ADDITIONALVERSIONS:-""}"

set -e

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Bring in ID, ID_LIKE, VERSION_ID, VERSION_CODENAME
. /etc/os-release
# Get an adjusted ID independent of distro variants
MAJOR_VERSION_ID=$(echo ${VERSION_ID} | cut -d . -f 1)
if [ "${ID}" = "debian" ] || [ "${ID_LIKE}" = "debian" ]; then
    ADJUSTED_ID="debian"
elif [[ "${ID}" = "rhel" || "${ID}" = "fedora" || "${ID}" = "mariner" || "${ID_LIKE}" = *"rhel"* || "${ID_LIKE}" = *"fedora"* || "${ID_LIKE}" = *"mariner"* ]]; then
    ADJUSTED_ID="rhel"
    if [[ "${ID}" = "rhel" ]] || [[ "${ID}" = *"alma"* ]] || [[ "${ID}" = *"rocky"* ]]; then
        VERSION_CODENAME="rhel${MAJOR_VERSION_ID}"
    else
        VERSION_CODENAME="${ID}${MAJOR_VERSION_ID}"
    fi
else
    echo "Linux distro ${ID} not supported."
    exit 1
fi

# Setup INSTALL_CMD & PKG_MGR_CMD
if type apt-get > /dev/null 2>&1; then
    PKG_MGR_CMD=apt-get
    INSTALL_CMD="${PKG_MGR_CMD} -y install --no-install-recommends"
elif type microdnf > /dev/null 2>&1; then
    PKG_MGR_CMD=microdnf
    INSTALL_CMD="${PKG_MGR_CMD} -y install --refresh --best --nodocs --noplugins --setopt=install_weak_deps=0"
elif type dnf > /dev/null 2>&1; then
    PKG_MGR_CMD=dnf
    INSTALL_CMD="${PKG_MGR_CMD} -y install"
elif type yum > /dev/null 2>&1; then
    PKG_MGR_CMD=yum
    INSTALL_CMD="${PKG_MGR_CMD} -y install"
else
    echo "(Error) Unable to find a supported package manager."
    exit 1
fi

pkg_manager_update() {
    case $ADJUSTED_ID in
        debian)
            if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
                echo "Running apt-get update..."
                ${PKG_MGR_CMD} update -y
            fi
            ;;
        rhel)
            if [ ${PKG_MGR_CMD} = "microdnf" ]; then
                if [ "$(ls /var/cache/yum/* 2>/dev/null | wc -l)" = 0 ]; then
                    echo "Running ${PKG_MGR_CMD} makecache ..."
                    ${PKG_MGR_CMD} makecache
                fi
            else
                if [ "$(ls /var/cache/${PKG_MGR_CMD}/* 2>/dev/null | wc -l)" = 0 ]; then
                    echo "Running ${PKG_MGR_CMD} check-update ..."
                    set +e
                        stderr_messages=$(${PKG_MGR_CMD} -q check-update 2>&1)
                        rc=$?
                        # centos 7 sometimes returns a status of 100 when it apears to work.
                        if [ $rc != 0 ] && [ $rc != 100 ]; then
                            echo "(Error) ${PKG_MGR_CMD} check-update produced the following error message(s):"
                            echo "${stderr_messages}"
                            exit 1
                        fi
                    set -e
                fi
            fi
            ;;
    esac
}

# Checks if packages are installed and installs them if not
check_packages() {
    case ${ADJUSTED_ID} in
        debian)
            if ! dpkg -s "$@" > /dev/null 2>&1; then
                pkg_manager_update
                ${INSTALL_CMD} "$@"
            fi
            ;;
        rhel)
            if ! rpm -q "$@" > /dev/null 2>&1; then
                pkg_manager_update
                ${INSTALL_CMD} "$@"
            fi
            ;;
    esac
}

if [ "${ADJUSTED_ID}" = "rhel" ] && [ "${VERSION_CODENAME-}" = "centos7" ]; then
    # As of 1 July 2024, mirrorlist.centos.org no longer exists.
    # Update the repo files to reference vault.centos.org.
    sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.repo
    sed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.repo
    sed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo
    yum update -y
    check_packages epel-release
fi

# Clean up
clean_up() {
    local pkg
    case ${ADJUSTED_ID} in
        debian)
            rm -rf /var/lib/apt/lists/*
            ;;
        rhel)
            for pkg in epel-release epel-release-latest packages-microsoft-prod; do
                ${PKG_MGR_CMD} -y remove $pkg 2>/dev/null || /bin/true
            done
            rm -rf /var/cache/dnf/* /var/cache/yum/*
            rm -f /etc/yum.repos.d/docker-ce.repo
            ;;
    esac
}

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

updaterc() {
    local _bashrc
    local _zshrc
    if [ "${UPDATE_RC}" = "true" ]; then
        case $ADJUSTED_ID in
            debian)
                _bashrc=/etc/bash.bashrc
                _zshrc=/etc/zsh/zshrc
                ;;
            rhel)
                _bashrc=/etc/bashrc
                _zshrc=/etc/zshrc
            ;;
        esac
        echo "Updating ${_bashrc} and ${_zshrc}..."
        if [[ "$(cat ${_bashrc})" != *"$1"* ]]; then
            echo -e "$1" >> "${_bashrc}"
        fi
        if [ -f "${_zshrc}" ] && [[ "$(cat ${_zshrc})" != *"$1"* ]]; then
            echo -e "$1" >> "${_zshrc}"
        fi
    fi
}

find_version_list() {
    prefix="$1"
    suffix="$2"
    install_type=$3
    ifLts="$4"
    version_list=$5
    java_ver=$6
    
    check_packages jq
    all_versions=$(curl -s https://api.adoptium.net/v3/info/available_releases)
    if [ "${ifLts}" = "true" ]; then 
        major_version=$(echo "$all_versions" | jq -r '.most_recent_lts')
    elif [ "${java_ver}" = "latest" ]; then
        major_version=$(echo "$all_versions" | jq -r '.most_recent_feature_release') 
    else
        major_version=$(echo "$java_ver" | cut -d '.' -f 1)
    fi
    
    # Remove the hardcoded fallback as this fails for new jdk latest version released ex: 24
    # Related Issue: https://github.com/devcontainers/features/issues/1308
    if [ "${JDK_DISTRO}" = "ms" ]; then
        # Check if the requested version is available in the 'ms' distribution
        echo "Check if OpenJDK is available for version ${major_version} for ${JDK_DISTRO} Distro"
        available_versions=$(su ${USERNAME} -c ". ${SDKMAN_DIR}/bin/sdkman-init.sh && sdk list ${install_type} | grep ${JDK_DISTRO} | grep -oE '[0-9]+(\.[0-9]+(\.[0-9]+)?)?' | sort -u")
        if echo "${available_versions}" | grep -q "^${major_version}"; then
            echo "JDK version ${major_version} is available in ${JDK_DISTRO}..."
        else
            echo "JDK version ${major_version} not available in  ${JDK_DISTRO}.... Switching to (tem)."
            JDK_DISTRO="tem"
        fi
    fi
    echo "JDK_DISTRO: ${JDK_DISTRO}"
    if [ "${install_type}" != "java" ]; then
        regex="${prefix}\\K[0-9]+\\.?[0-9]*\\.?[0-9]*${suffix}"
    else
        regex="${prefix}\\K${major_version}\\.?[0-9]*\\.?[0-9]*${suffix}${JDK_DISTRO}\\s*"
    fi
    declare -g ${version_list}="$(su ${USERNAME} -c ". \${SDKMAN_DIR}/bin/sdkman-init.sh && sdk list ${install_type} 2>&1 | grep -oP \"${regex}\" | tr -d ' ' | sort -rV")"
}

# Use SDKMAN to install something using a partial version match
sdk_install() {
    local install_type=$1
    local requested_version=$2
    local prefix=$3
    local suffix="${4:-"\\s*"}"
    local full_version_check=${5:-".*-[a-z]+"}
    local set_as_default=${6:-"true"}
    pkgs=("maven" "gradle" "ant" "groovy")
    pkg_vals="${pkgs[@]}"
    if [ "${requested_version}" = "none" ]; then return; fi
    if [ "${requested_version}" = "default" ]; then
        requested_version=""
    elif [[ "${pkg_vals}" =~ "${install_type}" ]] && [ "${requested_version}" = "latest" ]; then
        requested_version=""
    elif [ "${requested_version}" = "lts" ]; then
            find_version_list "$prefix" "$suffix" "$install_type" "true" version_list "${requested_version}"
            requested_version="$(echo "${version_list}" | head -n 1)"
    elif echo "${requested_version}" | grep -oE "${full_version_check}" > /dev/null 2>&1; then
        echo "${requested_version}"
    else 
        find_version_list "$prefix" "$suffix" "$install_type" "false" version_list "${requested_version}"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ]; then
            requested_version="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            requested_version="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|-|$)")"
            set -e
        fi
        if [ -z "${requested_version}" ] || ! echo "${version_list}" | grep "^${requested_version//./\\.}$" > /dev/null 2>&1; then
            echo -e "Version $2 not found. Available versions:\n${version_list}" >&2
            exit 1
        fi
    fi
    if [ "${set_as_default}" = "true" ]; then
        JAVA_VERSION=${requested_version}
    fi

    su ${USERNAME} -c "umask 0002 && . ${SDKMAN_DIR}/bin/sdkman-init.sh && sdk install ${install_type} ${requested_version} && sdk flush archives && sdk flush temp"
}

export DEBIAN_FRONTEND=noninteractive

architecture="$(uname -m)"
if [ "${architecture}" != "amd64" ] && [ "${architecture}" != "x86_64" ] && [ "${architecture}" != "arm64" ] && [ "${architecture}" != "aarch64" ]; then
    echo "(!) Architecture $architecture unsupported"
    exit 1
fi

# Install dependencies,
check_packages ca-certificates zip unzip sed findutils util-linux tar
# Make sure passwd (Debian) and shadow-utils RHEL family is installed
if [ ${ADJUSTED_ID} = "debian" ]; then
    check_packages passwd
elif [ ${ADJUSTED_ID} = "rhel" ]; then
    check_packages shadow-utils
fi
# minimal RHEL installs may not include curl, or includes curl-minimal instead.
# Install curl if the "curl" command is not present.
if ! type curl > /dev/null 2>&1; then
    check_packages curl
fi

# Install sdkman if not installed
if [ ! -d "${SDKMAN_DIR}" ]; then
    # Create sdkman group, dir, and set sticky bit
    if ! cat /etc/group | grep -e "^sdkman:" > /dev/null 2>&1; then
        groupadd -r sdkman
    fi
    usermod -a -G sdkman ${USERNAME}
    umask 0002
    # Install SDKMAN
    curl -sSL "https://get.sdkman.io?rcupdate=false" | bash
    chown -R "${USERNAME}:sdkman" ${SDKMAN_DIR}
    find ${SDKMAN_DIR} -type d -print0 | xargs -d '\n' -0 chmod g+s
    # Add sourcing of sdkman into bashrc/zshrc files (unless disabled)
    updaterc "export SDKMAN_DIR=${SDKMAN_DIR}\n. \${SDKMAN_DIR}/bin/sdkman-init.sh"
fi

sdk_install java ${JAVA_VERSION} "\\s*" "(\\.[a-z0-9]+)*-" ".*-[a-z]+$" "true"

# Additional java versions to be installed but not be set as default.
if [ ! -z "${ADDITIONAL_VERSIONS}" ]; then
    OLDIFS=$IFS
    IFS=","
        read -a additional_versions <<< "$ADDITIONAL_VERSIONS"
        for version in "${additional_versions[@]}"; do
            sdk_install java ${version} "\\s*" "(\\.[a-z0-9]+)*-" ".*-[a-z]+$" "false"
        done
    IFS=$OLDIFS
    su ${USERNAME} -c ". ${SDKMAN_DIR}/bin/sdkman-init.sh && sdk default java ${JAVA_VERSION}"
fi

# Install Ant
if [[ "${INSTALL_ANT}" = "true" ]] && ! ant -version > /dev/null 2>&1; then
    sdk_install ant ${ANT_VERSION}
fi

# Install Gradle
if [[ "${INSTALL_GRADLE}" = "true" ]] && ! gradle --version > /dev/null 2>&1; then
    sdk_install gradle ${GRADLE_VERSION}
fi

# Install Maven
if [[ "${INSTALL_MAVEN}" = "true" ]] && ! mvn --version > /dev/null 2>&1; then
    sdk_install maven ${MAVEN_VERSION}
fi

# Install Groovy
if [[ "${INSTALL_GROOVY}" = "true" ]] && ! groovy --version > /dev/null 2>&1; then
    sdk_install groovy "${GROOVY_VERSION}"
fi

# Clean up
clean_up

echo "Done!"



================================================
FILE: src/java/NOTES.md
================================================
## License

For the Java Feature from this repository, see [NOTICE.txt](https://github.com/devcontainers/features/tree/main/src/java/NOTICE.txt) for licensing information on JDK distributions.


## OS Support

Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, and RockyLinux distributions with the `apt`, `yum`, `dnf`, or `microdnf` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/java/wrapper.sh
================================================
#!/usr/bin/env bash
# Wrapper function that also installs JDK 11 if JDK 8 is selected since this is required for the Java extension

set -e

JAVA_VERSION="${1:-"default"}"
SDKMAN_DIR="${2:-"/usr/local/sdkman"}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="${4:-"true"}"
ADDITIONAL_JAVA_VERSION="11"

cd "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
chmod +x install.sh

is_jdk_8="false"
if echo "${JAVA_VERSION}" | grep -E '^8([\s\.]|$)' > /dev/null 2>&1; then
    is_jdk_8="true"
fi

# If the user selected JDK 8, install the JDK 11 as well since this is needed by the Java extension
if [ "${is_jdk_8}" = "true" ]; then
    echo "(*) Installing JDK ${ADDITIONAL_JAVA_VERSION} as Java VS Code extension requires a recent JDK..."
    ./install.sh "${ADDITIONAL_JAVA_VERSION}" "${SDKMAN_DIR}" "${USERNAME}" "${UPDATE_RC}"
    jdk_11_folder="$(ls --format=single-column ${SDKMAN_DIR}/candidates/java | grep -oE -m 1 '11\..+')"
    ln -s "${SDKMAN_DIR}/candidates/java/${jdk_11_folder}" /extension-java-home

    # Determine the appropriate non-root user
    username=""
    possible_users=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for current_user in "${POSSIBLE_USERS[@]}"; do
        if id -u ${current_user} > /dev/null 2>&1; then
            username=${current_user}
            break
        fi
    done
    if [ "${username}" = "" ]; then
        username=root
    fi
else
    ln -s ${SDKMAN_DIR}/candidates/java/current /extension-java-home
fi

echo "(*) Installing JDK ${JAVA_VERSION}..."
./install.sh "${JAVA_VERSION}" "${SDKMAN_DIR}" "${USERNAME}" "${UPDATE_RC}"
if [ "${is_jdk_8}" = "true" ]; then
    # Set current and default version to last SDK installed
    jdk_full_version="$(ls --format=single-column "${SDKMAN_DIR}/candidates/java" | sort -rV | grep -oE -m 1 "${JAVA_VERSION}\\..+" )"
    echo "(*) Setting default JDK to ${jdk_full_version}..."
    . ${SDKMAN_DIR}/bin/sdkman-init.sh 
    sdk use java "${jdk_full_version}"
    sdk default java "${jdk_full_version}"
fi


================================================
FILE: src/kubectl-helm-minikube/README.md
================================================

# Kubectl, Helm, and Minikube (kubectl-helm-minikube)

Installs latest version of kubectl, Helm, and optionally minikube. Auto-detects latest versions and installs needed dependencies.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/kubectl-helm-minikube:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a Kubernetes version to install | string | latest |
| helm | Select or enter a Helm version to install | string | latest |
| minikube | Select or enter a Minikube version to install | string | latest |

## Ingress and port forwarding

When configuring [Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/) for your Kubernetes cluster, note that by default Kubernetes will bind to a specific interface's IP rather than localhost or all interfaces. This is why you need to use the Kubernetes Node's IP when connecting - even if there's only one Node as in the case of Minikube. Port forwarding in Remote - Containers will allow you to specify `<ip>:<port>` in either the `forwardPorts` property or through the port forwarding UI in VS Code.

However, GitHub Codespaces does not yet support this capability, so you'll need to use `kubectl` to forward the port to localhost. This adds minimal overhead since everything is on the same machine. E.g.:

```bash
minikube start
minikube addons enable ingress
# Run this to forward to localhost in the background
nohup kubectl port-forward --pod-running-timeout=24h -n ingress-nginx service/ingress-nginx-controller :80 &
```


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/kubectl-helm-minikube/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/kubectl-helm-minikube/devcontainer-feature.json
================================================
{
    "id": "kubectl-helm-minikube",
    "version": "1.2.2",
    "name": "Kubectl, Helm, and Minikube",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/kubectl-helm-minikube",
    "description": "Installs latest version of kubectl, Helm, and optionally minikube. Auto-detects latest versions and installs needed dependencies.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "none",
                "1.23",
                "1.22",
                "1.21",
                "none"
            ],
            "default": "latest",
            "description": "Select or enter a Kubernetes version to install"
        },
        "helm": {
            "type": "string",
            "proposals": [
                "latest",
                "none"
            ],
            "default": "latest",
            "description": "Select or enter a Helm version to install"
        },
        "minikube": {
            "type": "string",
            "proposals": [
                "latest",
                "none"
            ],
            "default": "latest",
            "description": "Select or enter a Minikube version to install"
        }
    },
    "mounts": [
        {
            "source": "minikube-config",
            "target": "/home/vscode/.minikube",
            "type": "volume"
        }
    ],
    "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes kubectl, Helm, optionally minikube, and needed dependencies pre-installed and available on the `PATH`. When configuring Ingress for your Kubernetes cluster, note that by default Kubernetes will bind to a specific interface's IP rather than localhost or all interfaces. This is why you need to use the Kubernetes Node's IP when connecting - even if there's only one Node as in the case of Minikube."
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/kubectl-helm-minikube/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/kubectl-helm.md
# Maintainer: The VS Code and Codespaces Teams

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

KUBECTL_VERSION="${VERSION:-"latest"}"
HELM_VERSION="${HELM:-"latest"}"
MINIKUBE_VERSION="${MINIKUBE:-"latest"}" # latest is also valid

KUBECTL_SHA256="${KUBECTL_SHA256:-"automatic"}"
HELM_SHA256="${HELM_SHA256:-"automatic"}"
MINIKUBE_SHA256="${MINIKUBE_SHA256:-"automatic"}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"

HELM_GPG_KEYS_URI="https://raw.githubusercontent.com/helm/helm/main/KEYS"

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

USERHOME="/home/$USERNAME"
if [ "$USERNAME" = "root" ]; then
    USERHOME="/root"
fi

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    requested_version="${requested_version#v}"
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive

# Install dependencies
check_packages curl ca-certificates coreutils gnupg2 dirmngr bash-completion
if ! type git > /dev/null 2>&1; then
    check_packages git
fi

architecture="$(uname -m)"
case $architecture in
    x86_64) architecture="amd64";;
    aarch64 | armv8*) architecture="arm64";;
    aarch32 | armv7* | armvhf*) architecture="arm";;
    i?86) architecture="386";;
    *) echo "(!) Architecture $architecture unsupported"; exit 1 ;;
esac

if [ ${KUBECTL_VERSION} != "none" ]; then
    # Install the kubectl, verify checksum
    echo "Downloading kubectl..."
    if [ "${KUBECTL_VERSION}" = "latest" ] || [ "${KUBECTL_VERSION}" = "lts" ] || [ "${KUBECTL_VERSION}" = "current" ] || [ "${KUBECTL_VERSION}" = "stable" ]; then
        KUBECTL_VERSION="$(curl -sSL https://dl.k8s.io/release/stable.txt)"
    else
        find_version_from_git_tags KUBECTL_VERSION https://github.com/kubernetes/kubernetes
    fi
    if [ "${KUBECTL_VERSION::1}" != 'v' ]; then
        KUBECTL_VERSION="v${KUBECTL_VERSION}"
    fi
    curl -sSL -o /usr/local/bin/kubectl "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/${architecture}/kubectl"
    chmod 0755 /usr/local/bin/kubectl
    if [ "$KUBECTL_SHA256" = "automatic" ]; then
        KUBECTL_SHA256="$(curl -sSL "https://dl.k8s.io/${KUBECTL_VERSION}/bin/linux/${architecture}/kubectl.sha256")"
    fi
    ([ "${KUBECTL_SHA256}" = "dev-mode" ] || (echo "${KUBECTL_SHA256} */usr/local/bin/kubectl" | sha256sum -c -))
    if ! type kubectl > /dev/null 2>&1; then
        echo '(!) kubectl installation failed!'
        exit 1
    fi

    # kubectl bash completion
    kubectl completion bash > /etc/bash_completion.d/kubectl

    # kubectl zsh completion
    if [ -e "${USERHOME}/.oh-my-zsh" ]; then
        mkdir -p "${USERHOME}/.oh-my-zsh/completions"
        kubectl completion zsh > "${USERHOME}/.oh-my-zsh/completions/_kubectl"
        chown -R "${USERNAME}" "${USERHOME}/.oh-my-zsh"
    fi
fi

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    prev_version=${!variable_name#v}
    
    output=$(curl -s "$repo_url");

    check_packages jq

    message=$(echo "$output" | jq -r '.message')
    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="v${prev_version}"
    else 
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}

get_helm() {
    HELM_VERSION=$1
    helm_filename="helm-${HELM_VERSION}-linux-${architecture}.tar.gz"
    tmp_helm_filename="/tmp/helm/${helm_filename}"
    curl -sSL "https://get.helm.sh/${helm_filename}" -o "${tmp_helm_filename}"
    curl -sSL "https://github.com/helm/helm/releases/download/${HELM_VERSION}/${helm_filename}.asc" -o "${tmp_helm_filename}.asc"
}

# Get the list of GPG key servers that are reachable
get_gpg_key_servers() {
    declare -A keyservers_curl_map=(
        ["hkp://keyserver.ubuntu.com"]="http://keyserver.ubuntu.com:11371"
        ["hkp://keyserver.ubuntu.com:80"]="http://keyserver.ubuntu.com"
        ["hkps://keys.openpgp.org"]="https://keys.openpgp.org"
        ["hkp://keyserver.pgp.com"]="http://keyserver.pgp.com:11371"
    )

    local curl_args=""
    local keyserver_reachable=false  # Flag to indicate if any keyserver is reachable

    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        curl_args="--proxy ${KEYSERVER_PROXY}"
    fi

    for keyserver in "${!keyservers_curl_map[@]}"; do
        local keyserver_curl_url="${keyservers_curl_map[${keyserver}]}"
        if curl -s ${curl_args} --max-time 5 ${keyserver_curl_url} > /dev/null; then
            echo "keyserver ${keyserver}"
            keyserver_reachable=true
        else
            echo "(*) Keyserver ${keyserver} is not reachable." >&2
        fi
    done

    if ! $keyserver_reachable; then
        echo "(!) No keyserver is reachable." >&2
        exit 1
    fi
}

if [ ${HELM_VERSION} != "none" ]; then
    # Install Helm, verify signature and checksum
    echo "Downloading Helm..."
    helm_url="https://github.com/helm/helm"
    find_version_from_git_tags HELM_VERSION "${helm_url}"
    if [ "${HELM_VERSION::1}" != 'v' ]; then
        HELM_VERSION="v${HELM_VERSION}"
    fi
    mkdir -p /tmp/helm
    get_helm "${HELM_VERSION}"
    if grep -q "BlobNotFound" "${tmp_helm_filename}"; then
        echo -e "\n(!) Failed to fetch the latest artifacts for helm ${HELM_VERSION}..."
        repo_url=$(get_github_api_repo_url "${helm_url}")
        get_previous_version "${helm_url}" "${repo_url}" HELM_VERSION
        echo -e "\nAttempting to install ${HELM_VERSION}"
        get_helm "${HELM_VERSION}"
    fi
    export GNUPGHOME="/tmp/helm/gnupg"
    mkdir -p "${GNUPGHOME}"
    chmod 700 ${GNUPGHOME}
    curl -sSL "${HELM_GPG_KEYS_URI}" -o /tmp/helm/KEYS
    echo -e "disable-ipv6\n$(get_gpg_key_servers)" > ${GNUPGHOME}/dirmngr.conf
    gpg -q --import "/tmp/helm/KEYS"
    if ! gpg --verify "${tmp_helm_filename}.asc" > ${GNUPGHOME}/verify.log 2>&1; then
        echo "Verification failed!"
        cat /tmp/helm/gnupg/verify.log
        exit 1
    fi

    if [ "${HELM_SHA256}" = "automatic" ]; then
        curl -sSL "https://get.helm.sh/${helm_filename}.sha256" -o "${tmp_helm_filename}.sha256"
        curl -sSL "https://github.com/helm/helm/releases/download/${HELM_VERSION}/${helm_filename}.sha256.asc" -o "${tmp_helm_filename}.sha256.asc"
        if ! gpg --verify "${tmp_helm_filename}.sha256.asc" > /tmp/helm/gnupg/verify.log 2>&1; then
            echo "Verification failed!"
            cat /tmp/helm/gnupg/verify.log
            exit 1
        fi
        HELM_SHA256="$(cat "${tmp_helm_filename}.sha256")"
    fi

    ([ "${HELM_SHA256}" = "dev-mode" ] || (echo "${HELM_SHA256} *${tmp_helm_filename}" | sha256sum -c -))
    tar xf "${tmp_helm_filename}" -C /tmp/helm
    mv -f "/tmp/helm/linux-${architecture}/helm" /usr/local/bin/
    chmod 0755 /usr/local/bin/helm
    rm -rf /tmp/helm
    if ! type helm > /dev/null 2>&1; then
        echo '(!) Helm installation failed!'
        exit 1
    fi

    # helm bash completion
    helm completion bash > /etc/bash_completion.d/helm

    # helm zsh completion
    if [ -e "${USERHOME}/.oh-my-zsh" ]; then
        mkdir -p "${USERHOME}/.oh-my-zsh/completions"
        helm completion zsh > "${USERHOME}/.oh-my-zsh/completions/_helm"
        chown -R "${USERNAME}" "${USERHOME}/.oh-my-zsh"
    fi
fi

# Install Minikube, verify checksum
if [ "${MINIKUBE_VERSION}" != "none" ]; then
    echo "Downloading minikube..."
    if [ "${MINIKUBE_VERSION}" = "latest" ] || [ "${MINIKUBE_VERSION}" = "lts" ] || [ "${MINIKUBE_VERSION}" = "current" ] || [ "${MINIKUBE_VERSION}" = "stable" ]; then
        MINIKUBE_VERSION="latest"
    else
        find_version_from_git_tags MINIKUBE_VERSION https://github.com/kubernetes/minikube
        if [ "${MINIKUBE_VERSION::1}" != "v" ]; then
            MINIKUBE_VERSION="v${MINIKUBE_VERSION}"
        fi
    fi
    # latest is also valid in the download URLs 
    curl -sSL -o /usr/local/bin/minikube "https://storage.googleapis.com/minikube/releases/${MINIKUBE_VERSION}/minikube-linux-${architecture}"    
    chmod 0755 /usr/local/bin/minikube
    if [ "$MINIKUBE_SHA256" = "automatic" ]; then
        MINIKUBE_SHA256="$(curl -sSL "https://storage.googleapis.com/minikube/releases/${MINIKUBE_VERSION}/minikube-linux-${architecture}.sha256")"
    fi
    ([ "${MINIKUBE_SHA256}" = "dev-mode" ] || (echo "${MINIKUBE_SHA256} */usr/local/bin/minikube" | sha256sum -c -))
    if ! type minikube > /dev/null 2>&1; then
        echo '(!) minikube installation failed!'
        exit 1
    fi
    # Create minkube folder with correct privs in case a volume is mounted here
    mkdir -p "${USERHOME}/.minikube"
    chown -R $USERNAME "${USERHOME}/.minikube"
    chmod -R u+wrx "${USERHOME}/.minikube"
fi

if ! type docker > /dev/null 2>&1; then
    echo -e '\n(*) Warning: The docker command was not found.\n\nYou can use one of the following scripts to install it:\n\nhttps://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/docker-in-docker.md\n\nor\n\nhttps://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/docker.md'
fi

# Clean up
rm -rf /var/lib/apt/lists/*

echo -e "\nDone!"



================================================
FILE: src/kubectl-helm-minikube/NOTES.md
================================================
## Ingress and port forwarding

When configuring [Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/) for your Kubernetes cluster, note that by default Kubernetes will bind to a specific interface's IP rather than localhost or all interfaces. This is why you need to use the Kubernetes Node's IP when connecting - even if there's only one Node as in the case of Minikube. Port forwarding in Remote - Containers will allow you to specify `<ip>:<port>` in either the `forwardPorts` property or through the port forwarding UI in VS Code.

However, GitHub Codespaces does not yet support this capability, so you'll need to use `kubectl` to forward the port to localhost. This adds minimal overhead since everything is on the same machine. E.g.:

```bash
minikube start
minikube addons enable ingress
# Run this to forward to localhost in the background
nohup kubectl port-forward --pod-running-timeout=24h -n ingress-nginx service/ingress-nginx-controller :80 &
```


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/nix/README.md
================================================

# Nix Package Manager (nix)

Installs the Nix package manager and optionally a set of packages.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/nix:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Version of Nix to install. | string | latest |
| multiUser | Perform a multi-user install (instead of single user) | boolean | true |
| packages | Optional comma separated list of Nix packages to install in profile. | string | - |
| useAttributePath | Enable this option to use exact attribute path of the package in the Nixpkgs repository, aligning with the nix-env -iA command. | boolean | false |
| flakeUri | Optional URI to a Nix Flake to install in profile. | string | - |
| extraNixConfig | Optional comma separated list of extra lines to add to /etc/nix/nix.conf. | string | - |

## OS Support

This Feature should work on recent versions of Debian/Ubuntu, RedHat Enterprise Linux, Fedora, RockyLinux, and Alpine Linux.

## Location of Flakes

Currently `flakeUri` works best with a remote URI (e.g., `github:nixos/nixpkgs/nixpkgs-unstable#hello`) as local files need to be in the image.

> Proposed support for lifecycle hooks in Features ([#60](https://github.com/devcontainers/spec/issues/60)) would allow for expressions files or Flakes to exist in the source tree to be automatically installed on initial container startup, but today you will have to manually add the appropriate install command to `postCreateCommand` to your `devcontainer.json` instead.

## Multi-user vs. single-user installs

This Dev Container Feature supports two installation models for Nix: multi-user and single user. Multi-user is the default, but each has pros and cons.

| Installation Model | Pros | Cons |
| --- | --- | --- |
| *Multi-User* | Nix can be used with any user including root.<br /><br />Also still works if the UID or GID of any user is updated. | Only works with Nix 2.11 and up due to a Nix installer limitation.<br /><br />Container must run either: run as root (but `remoteUser` in devcontainer.json can be non-root), or includes `sudo` with the `remoteUser` being configured to use it. <br /><br />Note that automated start of the `nix-daemon` requires passwordless `sudo` if the container itself (e.g., `containerUser`) is not running as root. Manual startup using `sudo` can require a password, however (more next). |
| *Single-User* | Does not require the container to run as root or `sudo` to be included in the image. | Only works with the user specified in the `remoteUser` property or an auto-detected user. If this user's UID/GID is updated, that user will no longer be able to work with Nix. This is primarily a consideration when running on Linux where the UID/GID is sync'd to the local user. |

### Manually starting the Nix daemon

If you have `sudo` in your base image, but have a password set so automatic startup is not possible, you can manually start the Nix daemon by running the following command in a terminal:

```bash
sudo /usr/local/share/nix-entrypoint.sh
```

This same command can be used to restart the daemon if it has stopped for some reason. Logs are available at `/tmp/nix-daemon.log`.


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/nix/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/nix/devcontainer-feature.json
================================================
{
    "id": "nix",
    "version": "1.3.1",
    "name": "Nix Package Manager",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/nix",
    "description": "Installs the Nix package manager and optionally a set of packages.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "2.11"
            ],
            "default": "latest",
            "description": "Version of Nix to install."
        },
        "multiUser": {
            "type": "boolean",
            "default": true,
            "description": "Perform a multi-user install (instead of single user)"
        },
        "packages": {
            "type": "string",
            "default": "",
            "description": "Optional comma separated list of Nix packages to install in profile."
        },
        "useAttributePath": {
            "type": "boolean",
            "default": false,
            "description": "Enable this option to use exact attribute path of the package in the Nixpkgs repository, aligning with the nix-env -iA command."
        },
        "flakeUri": {
            "type": "string",
            "default": "",
            "description": "Optional URI to a Nix Flake to install in profile."
        },
        "extraNixConfig": {
            "type": "string",
            "default": "",
            "description": "Optional comma separated list of extra lines to add to /etc/nix/nix.conf."
        }
    },
    "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes the Nix package manager pre-installed and available on the `PATH`. Currently `flakeUri` works best with a remote URI (e.g., `github:nixos/nixpkgs/nixpkgs-unstable#hello`) as local files need to be in the image. The dev container supports two installation models for Nix: multi-user and single user. Multi-user is the default."
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ],
    "containerEnv": {
        "PATH": "/nix/var/nix/profiles/default/bin:/nix/var/nix/profiles/default/sbin:${PATH}"
    },
    "mounts": [
        {
            "source": "nix-store-${devcontainerId}",
            "target": "/nix",
            "type": "volume"
        }
    ],
    "entrypoint": "/usr/local/share/nix-entrypoint.sh"
}



================================================
FILE: src/nix/install.sh
================================================
#!/bin/bash
# Move to the same directory as this script
set -e
FEATURE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "${FEATURE_DIR}"

# Option defaults
VERSION="${VERSION:-"latest"}"
MULTIUSER="${MULTIUSER:-"true"}"
PACKAGES="${PACKAGES//,/ }"
USEATTRIBUTEPATH="${USEATTRIBUTEPATH:-"false"}"
FLAKEURI="${FLAKEURI:-""}"
EXTRANIXCONFIG="${EXTRANIXCONFIG:-""}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Import common utils
. ./utils.sh

detect_user USERNAME

if [ "${USERNAME}" = "root" ] && [ "${MULTIUSER}" != "true" ]; then
    echo "(!) A single user install is not allowed for root. Add a non-root user to your image or set multiUser to true in your feature configuration."
    exit 1
fi

# Verify dependencies
apt_get_update_if_exists
check_command curl "curl ca-certificates" "curl ca-certificates" "curl ca-certificates"
check_command gpg2 gnupg2 gnupg gnupg2
check_command dirmngr dirmngr dirmngr dirmngr
check_command xz xz-utils xz xz
check_command git git git git
check_command xargs findutils findutils findutils

# Determine version
find_version_from_git_tags VERSION https://github.com/NixOS/nix "tags/"

# Download and verify install per https://nixos.org/download.html#nix-verify-installation
tmpdir="$(mktemp -d)"
echo "(*) Downloading Nix installer..."
set +e
curl -sSLf -o "${tmpdir}/install-nix" https://releases.nixos.org/nix/nix-${VERSION}/install
exit_code=$?
set -e
if [ "$exit_code" != "0" ]; then
    # Handle situation where git tags are ahead of what was is available to actually download
    echo "(!) Nix version ${VERSION} failed to download. Attempting to fall back one version to retry..."
    find_prev_version_from_git_tags VERSION https://github.com/NixOS/nix "tags/"
    curl -sSLf -o "${tmpdir}/install-nix" https://releases.nixos.org/nix/nix-${VERSION}/install
fi
cd "${FEATURE_DIR}"

# Do a multi or single-user setup based on feature config
if [ "${MULTIUSER}" = "true" ]; then
    echo "(*) Performing multi-user install..."
    sh "${tmpdir}/install-nix" --daemon
else
    home_dir="$(eval echo ~${USERNAME})"
    if [ ! -e "${home_dir}" ]; then
        echo "(!) Home directory ${home_dir} does not exist for ${USERNAME}. Nix install will fail."
        exit 1
    fi
    echo "(*) Performing single-user install..."
    echo -e "\n**NOTE: Nix will only work for user ${USERNAME} on Linux if the host machine user's UID is $(id -u ${USERNAME}). You will need to chown /nix otherwise.**\n"
    # Install per https://nixos.org/manual/nix/stable/installation/installing-binary.html#single-user-installation
    mkdir -p /nix
    chown ${USERNAME} /nix ${tmpdir}
    su ${USERNAME} -c "sh \"${tmpdir}/install-nix\" --no-daemon --no-modify-profile"
    # nix installer does not update ~/.bashrc, and USER may or may not be defined, so update rc/profile files directly to handle that
    snippet='
    if [ "${PATH#*$HOME/.nix-profile/bin}" = "${PATH}" ]; then if [ -z "$USER" ]; then USER=$(whoami); fi; . $HOME/.nix-profile/etc/profile.d/nix.sh; fi
    '
    update_rc_file "$home_dir/.bashrc" "${snippet}"
    update_rc_file "$home_dir/.zshenv" "${snippet}"
    update_rc_file "$home_dir/.profile" "${snippet}"
fi
rm -rf "${tmpdir}" "/tmp/tmp-gnupg"

# Set nix config
mkdir -p /etc/nix
create_or_update_file /etc/nix/nix.conf 'sandbox = false'
if  [ ! -z "${FLAKEURI}" ] && [ "${FLAKEURI}" != "none" ]; then
    create_or_update_file /etc/nix/nix.conf 'experimental-features = nix-command flakes'
fi
# Extra nix config
if [ ! -z "${EXTRANIXCONFIG}" ]; then
    OLDIFS=$IFS
    IFS=","
        read -a extra_nix_config <<< "$EXTRANIXCONFIG"
        for line in "${extra_nix_config[@]}"; do
            create_or_update_file /etc/nix/nix.conf "$line"
        done
    IFS=$OLDIFS
fi

# Create entrypoint if needed
if [ ! -e "/usr/local/share/nix-entrypoint.sh" ]; then
    if [ "${MULTIUSER}" = "true" ]; then
        echo "(*) Setting up entrypoint..."
        cp -f nix-entrypoint.sh /usr/local/share/
    else
        echo -e '#!/bin/bash\nexec "$@"' > /usr/local/share/nix-entrypoint.sh
    fi
    chmod +x /usr/local/share/nix-entrypoint.sh
fi

# Install packages, flakes, etc if specified
chmod +x,o+r ${FEATURE_DIR} ${FEATURE_DIR}/post-install-steps.sh
if [ "${MULTIUSER}" = "true" ]; then
    /usr/local/share/nix-entrypoint.sh
    su ${USERNAME} -c "
        . /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
        ${FEATURE_DIR}/post-install-steps.sh
    "
else
    su ${USERNAME} -c "
        . \$HOME/.nix-profile/etc/profile.d/nix.sh
        ${FEATURE_DIR}/post-install-steps.sh
    "
fi

echo "Done!"



================================================
FILE: src/nix/nix-entrypoint.sh
================================================
#!/bin/bash
# Attempt to start daemon
set +e 
if ! pidof nix-daemon > /dev/null 2>&1; then
    start_ok=false
    if [ "$(id -u)" = "0" ]; then
        ( . /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh; /nix/var/nix/profiles/default/bin/nix-daemon > /tmp/nix-daemon.log 2>&1 ) &
        if [ "$?" = "0" ]; then
            start_ok=true
        fi
    elif type sudo > /dev/null 2>&1; then
        sudo -n sh -c '. /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh; /nix/var/nix/profiles/default/bin/nix-daemon > /tmp/nix-daemon.log 2>&1' &
        if [ "$?" = "0" ]; then
            start_ok=true
        fi
    fi
    if [ "${start_ok}" = "false" ]; then
            echo -e 'Failed to start nix-daemon as root. Set multiUser to false in your feature configuration if you would\nprefer to run the container as a non-root. You may also start the daemon manually if you have sudo\ninstalled and configured for your user by running "sudo -c nix-daemon &"'
    fi
fi
exec "$@"



================================================
FILE: src/nix/NOTES.md
================================================
## OS Support

This Feature should work on recent versions of Debian/Ubuntu, RedHat Enterprise Linux, Fedora, RockyLinux, and Alpine Linux.

## Location of Flakes

Currently `flakeUri` works best with a remote URI (e.g., `github:nixos/nixpkgs/nixpkgs-unstable#hello`) as local files need to be in the image.

> Proposed support for lifecycle hooks in Features ([#60](https://github.com/devcontainers/spec/issues/60)) would allow for expressions files or Flakes to exist in the source tree to be automatically installed on initial container startup, but today you will have to manually add the appropriate install command to `postCreateCommand` to your `devcontainer.json` instead.

## Multi-user vs. single-user installs

This Dev Container Feature supports two installation models for Nix: multi-user and single user. Multi-user is the default, but each has pros and cons.

| Installation Model | Pros | Cons |
| --- | --- | --- |
| *Multi-User* | Nix can be used with any user including root.<br /><br />Also still works if the UID or GID of any user is updated. | Only works with Nix 2.11 and up due to a Nix installer limitation.<br /><br />Container must run either: run as root (but `remoteUser` in devcontainer.json can be non-root), or includes `sudo` with the `remoteUser` being configured to use it. <br /><br />Note that automated start of the `nix-daemon` requires passwordless `sudo` if the container itself (e.g., `containerUser`) is not running as root. Manual startup using `sudo` can require a password, however (more next). |
| *Single-User* | Does not require the container to run as root or `sudo` to be included in the image. | Only works with the user specified in the `remoteUser` property or an auto-detected user. If this user's UID/GID is updated, that user will no longer be able to work with Nix. This is primarily a consideration when running on Linux where the UID/GID is sync'd to the local user. |

### Manually starting the Nix daemon

If you have `sudo` in your base image, but have a password set so automatic startup is not possible, you can manually start the Nix daemon by running the following command in a terminal:

```bash
sudo /usr/local/share/nix-entrypoint.sh
```

This same command can be used to restart the daemon if it has stopped for some reason. Logs are available at `/tmp/nix-daemon.log`.


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/nix/post-install-steps.sh
================================================
#!/bin/bash
set -e
echo "(*) Executing post-installation steps..."

# if not starts with "nixpkgs." add it as prefix to package name
add_nixpkgs_prefix() {
  local packages=$1
  local -a addr
  IFS=' ' read -ra addr <<<"$packages"
  for i in "${!addr[@]}"; do
    if [[ ${addr[i]} != nixpkgs.* ]]; then
      addr[i]="nixpkgs.${addr[i]}"
    fi
  done
  IFS=' ' echo "${addr[*]}"
}

# Install list of packages in profile if specified.
if [ ! -z "${PACKAGES}" ] && [ "${PACKAGES}" != "none" ]; then
  if [ "${USEATTRIBUTEPATH}" = "true" ]; then
    PACKAGES=$(add_nixpkgs_prefix "$PACKAGES")
    echo "Installing packages \"${PACKAGES}\" in profile..."
    nix-env -iA ${PACKAGES}
  else
    echo "Installing packages \"${PACKAGES}\" in profile..."
    nix-env --install ${PACKAGES}
  fi
fi

# Install Nix flake in profile if specified
if [ ! -z "${FLAKEURI}" ] && [ "${FLAKEURI}" != "none" ]; then
    echo "Installing flake ${FLAKEURI} in profile..."
    nix profile install "${FLAKEURI}"
fi

nix-collect-garbage --delete-old
nix-store --optimise



================================================
FILE: src/nix/utils.sh
================================================
# Function to run apt-get if needed
apt_get_update_if_needed()
{
    export DEBIAN_FRONTEND=noninteractive
    if [ ! -d "/var/lib/apt/lists" ] || [ "$(ls /var/lib/apt/lists/ | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update
    else
        echo "Skipping apt-get update."
    fi
}

# Function to run apt-get if command exists
apt_get_update_if_exists()
{
    if type apt-get > /dev/null 2>&1; then
        apt-get update
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if type dpkg > /dev/null 2>&1 && dpkg -s $1 > /dev/null 2>&1; then
        return 0
    elif type apk > /dev/null 2>&1 && apk -e info $2 > /dev/null 2>&1; then
        return 0
    elif type rpm > /dev/null 2>&1 && rpm -q $3 > /dev/null 2>&1; then
        return 0
    else
        echo "Unable to find package manager to check for packages."
        exit 1
    fi
    install_packages "$@"
    return $?
}

# Checks if command exists, installs it if not
# check_command <command> "<apt packages to install>" "<apk packages to install>" "<dnf/yum packages to install>"
check_command() {
    command_to_check=$1
    shift
    if type "${command_to_check}" > /dev/null 2>&1; then
        return 0
    fi
    install_packages "$@"
    return $?
}

# Installs packages using the appropriate package manager (apt, apk, dnf, or yum)
# install_packages "<apt packages to install>" "<apk packages to install>" "<dnf/yum packages to install>"
install_packages() {
    if type apt-get > /dev/null 2>&1; then
        apt_get_update_if_needed
        apt-get -y install --no-install-recommends $1
    elif type apk > /dev/null 2>&1; then
        apk add $2
    elif type dnf > /dev/null 2>&1; then
        dnf install -y $3
    elif type yum > /dev/null 2>&1; then
        yum install -y $3
    else
        echo "Unable to find package manager to install ${command_to_check}"
        exit 1
    fi
}

# If in automatic mode, determine if a user already exists, if not use root
detect_user() {
    local user_variable_name=${1:-username}
    local possible_users=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    if [ "${!user_variable_name}" = "auto" ] || [ "${!user_variable_name}" = "automatic" ]; then
        declare -g ${user_variable_name}=""
        for current_user in ${possible_users[@]}; do
            if id -u "${current_user}" > /dev/null 2>&1; then
                declare -g ${user_variable_name}="${current_user}"
                break
            fi
        done
    fi
    if [ "${!user_variable_name}" = "" ] || [ "${!user_variable_name}" = "none" ] || ! id -u "${!user_variable_name}" > /dev/null 2>&1; then
        declare -g ${user_variable_name}=root
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6

    local escaped_separator=${separator//./\\.}
    local break_fix_digit_regex
    if [ "${last_part_optional}" = "true" ]; then
        break_fix_digit_regex="(${escaped_separator}[0-9]+)?"
    else
        break_fix_digit_regex="${escaped_separator}[0-9]+"
    fi    
    local version_regex="[0-9]+${escaped_separator}[0-9]+${break_fix_digit_regex}${version_suffix_regex//./\\.}"
    # If we're passed a matching version number, just return it, otherwise look for a version
    if ! echo "${requested_version}" | grep -E "^${versionMatchRegex}$" > /dev/null 2>&1; then
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${prefix}\\K${version_regex}$" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|${version_suffix_regex//./\\.}|$)")"
            set -e
        fi
        if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
            echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
            exit 1
        fi
    fi
    echo "Adjusted ${variable_name}=${!variable_name}"
}

# Soft version matching that resolves a version for a given package in the *current apt-cache*
# Return value is stored in first argument (the unprocessed version)
apt_cache_version_soft_match() {
    # Version
    local variable_name="$1"
    local requested_version=${!variable_name}
    # Package Name
    local package_name="$2"
    # Exit on no match?
    local exit_on_no_match="${3:-true}"

    # Ensure we've exported useful variables
    . /etc/os-release
    local architecture="$(dpkg --print-architecture)"
    
    dot_escaped="${requested_version//./\\.}"
    dot_plus_escaped="${dot_escaped//+/\\+}"
    # Regex needs to handle debian package version number format: https://www.systutorials.com/docs/linux/man/5-deb-version/
    version_regex="^(.+:)?${dot_plus_escaped}([\\.\\+ ~:-]|$)"
    set +e # Don't exit if finding version fails - handle gracefully
        fuzzy_version="$(apt-cache madison ${package_name} | awk -F"|" '{print $2}' | sed -e 's/^[ \t]*//' | grep -E -m 1 "${version_regex}")"
    set -e
    if [ -z "${fuzzy_version}" ]; then
        echo "(!) No full or partial for package \"${package_name}\" match found in apt-cache for \"${requested_version}\" on OS ${ID} ${VERSION_CODENAME} (${architecture})."

        if $exit_on_no_match; then
            echo "Available versions:"
            apt-cache madison ${package_name} | awk -F"|" '{print $2}' | grep -oP '^(.+:)?\K.+'
            exit 1 # Fail entire script
        else
            echo "Continuing to fallback method (if available)"
            return 1;
        fi
    fi

    # Globally assign fuzzy_version to this value
    # Use this value as the return value of this function
    declare -g ${variable_name}="=${fuzzy_version}"
    echo "${variable_name}=${!variable_name}"
}

# Checks if a marker file exists with the correct contents
# check_marker <marker path> [argument to be validated]...
check_marker() {
    local marker_path="$1"
    shift
    local verifier_string="$(echo "$@")"
    if [ -e "${marker_path}" ] && [ "${verifier_string}" = "$(cat ${marker_path})" ]; then
        return 1
    else 
        return 0
    fi
}

# Updates marker for future checking
# update_marker <marker path> [argument to be validated]...
update_marker() {
    local marker_path="$1"
    shift
    mkdir -p "$(dirname "${marker_path}")"
    echo "$(echo "$@")" > "${marker_path}"
}

# run_if_exists <command> <command arguments>...
run_if_exists() {
    if [ -e "$1" ]; then
        "$@"
    fi
}

# run_as_user_if_exists <username> <command> <command arguments>...
run_as_user_if_exists() {
    local username=$1
    shift
    if [ -e "$1" ]; then
        local command_string="$@"
        su "${username}" -c "${command_string//"/\\"}"
    fi
}

# symlink_if_ne <source> <target>
symlink_if_ne() {
    if [ ! -e "$2" ]; then
        ln -s "$1" "$2"
    fi
}

# Update a rc/profile file if it exists and string is not already present
update_rc_file() {
    # see if folder containing file exists
    local rc_file_folder="$(dirname "$1")"
    if [ ! -d "${rc_file_folder}" ]; then
        echo "${rc_file_folder} does not exist. Skipping update of $1."
    elif [ ! -e "$1" ] || [[ "$(cat "$1")" != *"$2"* ]]; then
        echo "$2" >> "$1"
    fi
}

# Update a file if with string if not already present
# create_or_update_file <file> <string>
create_or_update_file() {
    if [ ! -e "$1" ] || [[ "$(cat "$1")" != *"$2"* ]]; then
        echo "$2" >> "$1"
    fi
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
    major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
    minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
    breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

    if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
        ((major=major-1))
        declare -g ${variable_name}="${major}"
        # Look for latest version from previous major release
        find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
    # Handle situations like Go's odd version pattern where "0" releases omit the last part
    elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
        ((minor=minor-1))
        declare -g ${variable_name}="${major}.${minor}"
        # Look for latest version from previous minor release
        find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
    else
        ((breakfix=breakfix-1))
        if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
            declare -g ${variable_name}="${major}.${minor}"
        else 
            declare -g ${variable_name}="${major}.${minor}.${breakfix}"
        fi
    fi

    set -e
}


================================================
FILE: src/node/README.md
================================================

# Node.js (via nvm), yarn and pnpm (node)

Installs Node.js, nvm, yarn, pnpm, and needed dependencies.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/node:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a Node.js version to install | string | lts |
| nodeGypDependencies | Install dependencies to compile native node modules (node-gyp)? | boolean | true |
| nvmInstallPath | The path where NVM will be installed. | string | /usr/local/share/nvm |
| pnpmVersion | Select or enter the PNPM version to install | string | latest |
| nvmVersion | Version of NVM to install. | string | latest |
| installYarnUsingApt | On Debian and Ubuntu systems, you have the option to install Yarn globally via APT. If you choose not to use this option, Yarn will be set up using Corepack instead. This choice is specific to Debian and Ubuntu; for other Linux distributions, Yarn is always installed using Corepack, with a fallback to installation via NPM if an error occurs. | boolean | true |

## Customizations

### VS Code Extensions

- `dbaeumer.vscode-eslint`

## Using nvm from postCreateCommand or another lifecycle command

Certain operations like `postCreateCommand` run non-interactive, non-login shells. Unfortunately, `nvm` is really particular that it needs to be "sourced" before it is used, which can only happen automatically with interactive and/or login shells. Fortunately, this is easy to work around:

Just can source the `nvm` startup script before using it:

```json
"postCreateCommand": ". ${NVM_DIR}/nvm.sh && nvm install --lts"
```

Note that typically the default shell in these cases is `sh` not `bash`, so use `. ${NVM_DIR}/nvm.sh` instead of `source ${NVM_DIR}/nvm.sh`.

Alternatively, you can start up an interactive shell which will in turn source `nvm`:

```json
"postCreateCommand": "bash -i -c 'nvm install --lts'"
```



## OS Support

Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, and Rocky Linux distributions with the `apt`, `yum`, `dnf`, or `microdnf` package manager installed.

**Note**:  RedHat 7 Family (RedHat, CentOS, etc.) must use Node versions less than 18 due to its system libraries and long-term support (LTS) policies.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/node/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/node/devcontainer-feature.json
================================================
{
    "id": "node",
    "version": "1.6.3",
    "name": "Node.js (via nvm), yarn and pnpm",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/node",
    "description": "Installs Node.js, nvm, yarn, pnpm, and needed dependencies.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "lts",
                "latest",
                "none",
                "22",
                "20"
            ],
            "default": "lts",
            "description": "Select or enter a Node.js version to install"
        },
        "nodeGypDependencies": {
            "type": "boolean",
            "default": true,
            "description": "Install dependencies to compile native node modules (node-gyp)?"
        },
        "nvmInstallPath": {
            "type": "string",
            "default": "/usr/local/share/nvm",
            "description": "The path where NVM will be installed."
        },
        "pnpmVersion": {
            "type": "string",
            "proposals": [
                "latest",
                "8.8.0",
                "8.0.0",
                "7.30.0",
                "6.14.8",
                "5.18.10",
                "none"
            ],
            "default": "latest",
            "description": "Select or enter the PNPM version to install"
        },
        "nvmVersion": {
            "type": "string",
            "proposals": [
                "latest",
                "0.39"
            ],
            "default": "latest",
            "description": "Version of NVM to install."
        },
        "installYarnUsingApt": {
            "type": "boolean",
            "default": true,
            "description": "On Debian and Ubuntu systems, you have the option to install Yarn globally via APT. If you choose not to use this option, Yarn will be set up using Corepack instead. This choice is specific to Debian and Ubuntu; for other Linux distributions, Yarn is always installed using Corepack, with a fallback to installation via NPM if an error occurs."
        }
    },
    "customizations": {
        "vscode": {
            "extensions": [
                "dbaeumer.vscode-eslint"
            ],
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes `node`, `npm` and `eslint` pre-installed and available on the `PATH` for Node.js and JavaScript development."
                    }
                ]
            }
        }
    },
    "containerEnv": {
        "NVM_DIR": "/usr/local/share/nvm",
        "NVM_SYMLINK_CURRENT": "true",
        "PATH": "/usr/local/share/nvm/current/bin:${PATH}"
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}


================================================
FILE: src/node/install.sh
================================================
#!/bin/bash
#-------------------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://github.com/devcontainers/features/blob/main/LICENSE for license information.
#-------------------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/devcontainers/features/tree/main/src/node
# Maintainer: The Dev Container spec maintainers

export NODE_VERSION="${VERSION:-"lts"}"
export PNPM_VERSION="${PNPMVERSION:-"latest"}"
export NVM_VERSION="${NVMVERSION:-"latest"}"
export NVM_DIR="${NVMINSTALLPATH:-"/usr/local/share/nvm"}"
INSTALL_TOOLS_FOR_NODE_GYP="${NODEGYPDEPENDENCIES:-true}"
export INSTALL_YARN_USING_APT="${INSTALLYARNUSINGAPT:-true}"  # only concerns Debian-based systems

# Comma-separated list of node versions to be installed (with nvm)
# alongside NODE_VERSION, but not set as default.
ADDITIONAL_VERSIONS="${ADDITIONALVERSIONS:-""}"

USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="${UPDATE_RC:-"true"}"

set -e

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Bring in ID, ID_LIKE, VERSION_ID, VERSION_CODENAME
. /etc/os-release
# Get an adjusted ID independent of distro variants
MAJOR_VERSION_ID=$(echo ${VERSION_ID} | cut -d . -f 1)
if [ "${ID}" = "debian" ] || [ "${ID_LIKE}" = "debian" ]; then
    ADJUSTED_ID="debian"
elif [[ "${ID}" = "rhel" || "${ID}" = "fedora" || "${ID}" = "mariner" || "${ID_LIKE}" = *"rhel"* || "${ID_LIKE}" = *"fedora"* || "${ID_LIKE}" = *"mariner"* ]]; then
    ADJUSTED_ID="rhel"
    if [[ "${ID}" = "rhel" ]] || [[ "${ID}" = *"alma"* ]] || [[ "${ID}" = *"rocky"* ]]; then
        VERSION_CODENAME="rhel${MAJOR_VERSION_ID}"
    else
        VERSION_CODENAME="${ID}${MAJOR_VERSION_ID}"
    fi
else
    echo "Linux distro ${ID} not supported."
    exit 1
fi

if [ "${ADJUSTED_ID}" = "rhel" ] && [ "${VERSION_CODENAME-}" = "centos7" ]; then
    # As of 1 July 2024, mirrorlist.centos.org no longer exists.
    # Update the repo files to reference vault.centos.org.
    sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.repo
    sed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.repo
    sed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo
fi

# Setup INSTALL_CMD & PKG_MGR_CMD
if type apt-get > /dev/null 2>&1; then
    PKG_MGR_CMD=apt-get
    INSTALL_CMD="${PKG_MGR_CMD} -y install --no-install-recommends"
elif type microdnf > /dev/null 2>&1; then
    PKG_MGR_CMD=microdnf
    INSTALL_CMD="${PKG_MGR_CMD} -y install --refresh --best --nodocs --noplugins --setopt=install_weak_deps=0"
elif type dnf > /dev/null 2>&1; then
    PKG_MGR_CMD=dnf
    INSTALL_CMD="${PKG_MGR_CMD} -y install"
else
    PKG_MGR_CMD=yum
    INSTALL_CMD="${PKG_MGR_CMD} -y install"
fi

# Clean up
clean_up() {
    case ${ADJUSTED_ID} in
        debian)
            rm -rf /var/lib/apt/lists/*
            ;;
        rhel)
            rm -rf /var/cache/dnf/* /var/cache/yum/*
            rm -f /etc/yum.repos.d/yarn.repo
            ;;
    esac
}
clean_up

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

updaterc() {
    local _bashrc
    local _zshrc
    if [ "${UPDATE_RC}" = "true" ]; then
        case $ADJUSTED_ID in
            debian)
                _bashrc=/etc/bash.bashrc
                _zshrc=/etc/zsh/zshrc
                ;;
            rhel)
                _bashrc=/etc/bashrc
                _zshrc=/etc/zshrc
            ;;
        esac
        echo "Updating ${_bashrc} and ${_zshrc}..."
        if [[ "$(cat ${_bashrc})" != *"$1"* ]]; then
            echo -e "$1" >> "${_bashrc}"
        fi
        if [ -f "${_zshrc}" ] && [[ "$(cat ${_zshrc})" != *"$1"* ]]; then
            echo -e "$1" >> "${_zshrc}"
        fi
    fi
}

pkg_mgr_update() {
    case $ADJUSTED_ID in
        debian)
            if [ "$(find /var/lib/apt/lists/* 2>/dev/null | wc -l)" = "0" ]; then
                echo "Running apt-get update..."
                ${PKG_MGR_CMD} update -y
            fi
            ;;
        rhel)
            if [ ${PKG_MGR_CMD} = "microdnf" ]; then
                if [ "$(ls /var/cache/yum/* 2>/dev/null | wc -l)" = 0 ]; then
                    echo "Running ${PKG_MGR_CMD} makecache ..."
                    ${PKG_MGR_CMD} makecache
                fi
            else
                if [ "$(ls /var/cache/${PKG_MGR_CMD}/* 2>/dev/null | wc -l)" = 0 ]; then
                    echo "Running ${PKG_MGR_CMD} check-update ..."
                    set +e
                        stderr_messages=$(${PKG_MGR_CMD} -q check-update 2>&1)
                        rc=$?
                        # centos 7 sometimes returns a status of 100 when it apears to work.
                        if [ $rc != 0 ] && [ $rc != 100 ]; then
                            echo "(Error) ${PKG_MGR_CMD} check-update produced the following error message(s):"
                            echo "${stderr_messages}"
                            exit 1
                        fi
                    set -e
                fi
            fi
            ;;
    esac
}

# Checks if packages are installed and installs them if not
check_packages() {
    case ${ADJUSTED_ID} in
        debian)
            if ! dpkg -s "$@" > /dev/null 2>&1; then
                pkg_mgr_update
                ${INSTALL_CMD} "$@"
            fi
            ;;
        rhel)
            if ! rpm -q "$@" > /dev/null 2>&1; then
                pkg_mgr_update
                ${INSTALL_CMD} "$@"
            fi
            ;;
    esac
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

install_yarn() {
    if [ "${ADJUSTED_ID}" = "debian" ] && [ "${INSTALL_YARN_USING_APT}" = "true" ]; then
        # for backward compatiblity with existing devcontainer features, install yarn
        # via apt-get on Debian systems
        if ! type yarn >/dev/null 2>&1; then
            # Import key safely (new method rather than deprecated apt-key approach) and install
            curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | gpg --dearmor > /usr/share/keyrings/yarn-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/yarn-archive-keyring.gpg] https://dl.yarnpkg.com/debian/ stable main" > /etc/apt/sources.list.d/yarn.list
            apt-get update
            apt-get -y install --no-install-recommends yarn
        else
            echo "Yarn is already installed."
        fi
    else
        local _ver=${1:-node}
        # on non-debian systems or if user opted not to use APT, prefer corepack
        # Fallback to npm based installation of yarn.
        # But try to leverage corepack if possible
        # From https://yarnpkg.com:
        # The preferred way to manage Yarn is by-project and through Corepack, a tool
        # shipped by default with Node.js. Modern releases of Yarn aren't meant to be
        # installed globally, or from npm.
        if ! bash -c ". '${NVM_DIR}/nvm.sh' && nvm use ${_ver} && type yarn >/dev/null 2>&1"; then
            if bash -c ". '${NVM_DIR}/nvm.sh' && nvm use ${_ver} && type corepack >/dev/null 2>&1"; then
                su ${USERNAME} -c "umask 0002 && . '${NVM_DIR}/nvm.sh' && nvm use ${_ver} && corepack enable"
            fi
            if ! bash -c ". '${NVM_DIR}/nvm.sh' && nvm use ${_ver} && type yarn >/dev/null 2>&1"; then
                # Yum/DNF want to install nodejs dependencies, we'll use NPM to install yarn
                su ${USERNAME} -c "umask 0002 && . '${NVM_DIR}/nvm.sh' && nvm use ${_ver} && npm install --global yarn"
            fi
        else
            echo "Yarn already installed."
        fi
    fi
}

# Mariner does not have awk installed by default, this can cause
# problems is username is auto* and later when we try to install
# node via npm.
if ! type awk >/dev/null 2>&1; then
    check_packages awk
fi

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive

if ( [ -n "${VERSION_CODENAME}" ] && [[ "bionic" = *"${VERSION_CODENAME}"* ]] ) || [[ "rhel7" = *"${ADJUSTED_ID}${MAJOR_VERSION_ID}"* ]]; then
    node_major_version=$(echo "${NODE_VERSION}" | cut -d . -f 1)
    if [[ "${node_major_version}" -ge 18 ]] || [[ "${NODE_VERSION}" = "lts" ]] || [[ "${NODE_VERSION}" = "latest" ]]; then
        echo "(!) Unsupported distribution version '${VERSION_CODENAME}' for Node >= 18. Details: https://github.com/nodejs/node/issues/42351#issuecomment-1068424442"
        exit 1
    fi
fi

# Install dependencies
case ${ADJUSTED_ID} in
    debian)
        check_packages apt-transport-https curl ca-certificates tar gnupg2 dirmngr
        ;;
    rhel)
        check_packages ca-certificates tar gnupg2 which findutils util-linux tar
        # minimal RHEL installs may not include curl, or includes curl-minimal instead.
        # Install curl if the "curl" command is not present.
        if ! type curl > /dev/null 2>&1; then
            check_packages curl
        fi
        ;;
esac

if ! type git > /dev/null 2>&1; then
    check_packages git
fi

# Adjust node version if required
if [ "${NODE_VERSION}" = "none" ]; then
    export NODE_VERSION=
elif [ "${NODE_VERSION}" = "lts" ]; then
    export NODE_VERSION="lts/*"
elif [ "${NODE_VERSION}" = "latest" ]; then
    export NODE_VERSION="node"
fi

find_version_from_git_tags NVM_VERSION "https://github.com/nvm-sh/nvm"

# Install snipppet that we will run as the user
nvm_install_snippet="$(cat << EOF
set -e
umask 0002
# Do not update profile - we'll do this manually
export PROFILE=/dev/null
curl -so- "https://raw.githubusercontent.com/nvm-sh/nvm/v${NVM_VERSION}/install.sh" | bash ||  {
    PREV_NVM_VERSION=$(curl -s https://api.github.com/repos/nvm-sh/nvm/releases/latest | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
    curl -so- "https://raw.githubusercontent.com/nvm-sh/nvm/\${PREV_NVM_VERSION}/install.sh" | bash
    NVM_VERSION="\${PREV_NVM_VERSION}"
}
[ -s "${NVM_DIR}/nvm.sh" ] && source "${NVM_DIR}/nvm.sh"
if [ "${NODE_VERSION}" != "" ]; then
    nvm alias default "${NODE_VERSION}"
fi
EOF
)"

# Snippet that should be added into rc / profiles
nvm_rc_snippet="$(cat << EOF
export NVM_DIR="${NVM_DIR}"
[ -s "\$NVM_DIR/nvm.sh" ] && . "\$NVM_DIR/nvm.sh"
[ -s "\$NVM_DIR/bash_completion" ] && . "\$NVM_DIR/bash_completion"
EOF
)"

# Create a symlink to the installed version for use in Dockerfile PATH statements
export NVM_SYMLINK_CURRENT=true

# Create nvm group to the user's UID or GID to change while still allowing access to nvm
if ! cat /etc/group | grep -e "^nvm:" > /dev/null 2>&1; then
    groupadd -r nvm
fi
usermod -a -G nvm ${USERNAME}

# Install nvm (which also installs NODE_VERSION), otherwise
# use nvm to install the specified node version. Always use
# umask 0002 so both the owner so that everything is u+rw,g+rw
umask 0002
if [ ! -d "${NVM_DIR}" ]; then
    # Create nvm dir, and set sticky bit
    mkdir -p "${NVM_DIR}"
    chown "${USERNAME}:nvm" "${NVM_DIR}"
    chmod g+rws "${NVM_DIR}"
    su ${USERNAME} -c "${nvm_install_snippet}" 2>&1
    # Update rc files
    if [ "${UPDATE_RC}" = "true" ]; then
        updaterc "${nvm_rc_snippet}"
    fi
else
    echo "NVM already installed."
    if [ "${NODE_VERSION}" != "" ]; then
        su ${USERNAME} -c "umask 0002 && . '$NVM_DIR/nvm.sh' && nvm install '${NODE_VERSION}' && nvm alias default '${NODE_VERSION}'"
    fi
fi

# Possibly install yarn (puts yarn in per-Node install on RHEL, uses system yarn on Debian)
install_yarn

# Additional node versions to be installed but not be set as
# default we can assume the nvm is the group owner of the nvm
# directory and the sticky bit on directories so any installed
# files will have will have the correct ownership (nvm)
if [ ! -z "${ADDITIONAL_VERSIONS}" ]; then
    OLDIFS=$IFS
    IFS=","
        read -a additional_versions <<< "$ADDITIONAL_VERSIONS"
        for ver in "${additional_versions[@]}"; do
            su ${USERNAME} -c "umask 0002 && . '$NVM_DIR/nvm.sh' && nvm install '${ver}'"
            # possibly install yarn (puts yarn in per-Node install on RHEL, uses system yarn on Debian)
            install_yarn "${ver}"
        done

        # Ensure $NODE_VERSION is on the $PATH
        if [ "${NODE_VERSION}" != "" ]; then
                su ${USERNAME} -c "umask 0002 && . '$NVM_DIR/nvm.sh' && nvm use default"
        fi
    IFS=$OLDIFS
fi

# Install pnpm
if [ ! -z "${PNPM_VERSION}" ] && [ "${PNPM_VERSION}" = "none" ]; then
    echo "Ignoring installation of PNPM"
else
    if bash -c ". '${NVM_DIR}/nvm.sh' && type npm >/dev/null 2>&1"; then
        (
            . "${NVM_DIR}/nvm.sh"
            [ ! -z "$http_proxy" ] && npm set proxy="$http_proxy"
            [ ! -z "$https_proxy" ] && npm set https-proxy="$https_proxy"
            [ ! -z "$no_proxy" ] && npm set noproxy="$no_proxy"
            npm install -g pnpm@$PNPM_VERSION --force
        )
    else
        echo "Skip installing pnpm because npm is missing"
    fi
fi

# If enabled, verify "python3", "make", "gcc", "g++" commands are available so node-gyp works - https://github.com/nodejs/node-gyp
if [ "${INSTALL_TOOLS_FOR_NODE_GYP}" = "true" ]; then
    echo "Verifying node-gyp OS requirements..."
    to_install=""
    if ! type make > /dev/null 2>&1; then
        to_install="${to_install} make"
    fi
    if ! type gcc > /dev/null 2>&1; then
        to_install="${to_install} gcc"
    fi
    if ! type g++ > /dev/null 2>&1; then
        if [ ${ADJUSTED_ID} = "debian" ]; then
            to_install="${to_install} g++"
        elif [ ${ADJUSTED_ID} = "rhel" ]; then
            to_install="${to_install} gcc-c++"
        fi
    fi
    if ! type python3 > /dev/null 2>&1; then
        if [ ${ADJUSTED_ID} = "debian" ]; then
            to_install="${to_install} python3-minimal"
        elif [ ${ADJUSTED_ID} = "rhel" ]; then
            to_install="${to_install} python3"
        fi
    fi
    if [ ! -z "${to_install}" ]; then
        pkg_mgr_update
        check_packages ${to_install}
    fi
fi


# Clean up
su ${USERNAME} -c "umask 0002 && . '$NVM_DIR/nvm.sh' && nvm clear-cache"
clean_up

# Ensure privs are correct for installed node versions. Unfortunately the
# way nvm installs node versions pulls privs from the tar which does not
# have group write set. We need this when the gid/uid is updated.
mkdir -p "${NVM_DIR}/versions"
chmod -R g+rw "${NVM_DIR}/versions"

echo "Done!"



================================================
FILE: src/node/NOTES.md
================================================
## Using nvm from postCreateCommand or another lifecycle command

Certain operations like `postCreateCommand` run non-interactive, non-login shells. Unfortunately, `nvm` is really particular that it needs to be "sourced" before it is used, which can only happen automatically with interactive and/or login shells. Fortunately, this is easy to work around:

Just can source the `nvm` startup script before using it:

```json
"postCreateCommand": ". ${NVM_DIR}/nvm.sh && nvm install --lts"
```

Note that typically the default shell in these cases is `sh` not `bash`, so use `. ${NVM_DIR}/nvm.sh` instead of `source ${NVM_DIR}/nvm.sh`.

Alternatively, you can start up an interactive shell which will in turn source `nvm`:

```json
"postCreateCommand": "bash -i -c 'nvm install --lts'"
```



## OS Support

Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, and Rocky Linux distributions with the `apt`, `yum`, `dnf`, or `microdnf` package manager installed.

**Note**:  RedHat 7 Family (RedHat, CentOS, etc.) must use Node versions less than 18 due to its system libraries and long-term support (LTS) policies.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/nvidia-cuda/README.md
================================================

# NVIDIA CUDA (nvidia-cuda)

Installs shared libraries for NVIDIA CUDA.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/nvidia-cuda:2": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| installCudnn | Additionally install CUDA Deep Neural Network (cuDNN) shared library | boolean | false |
| installCudnnDev | Additionally install CUDA Deep Neural Network (cuDNN) development libraries and headers | boolean | false |
| installNvtx | Additionally install NVIDIA Tools Extension (NVTX) | boolean | false |
| installToolkit | Additionally install NVIDIA CUDA Toolkit | boolean | false |
| cudaVersion | Version of CUDA to install | string | 11.8 |
| cudnnVersion | Version of cuDNN to install | string | automatic |

## Compatibility

This Feature adds shared libraries for NVIDIA CUDA and is only useful for devcontainers that run on a host machine with an NVIDIA GPU. Within your devcontainer, use the `nvidia-smi` command to ensure that your GPU is available for CUDA.

If the `nvidia-smi` command is not available within your devcontainer, you may need to complete the following steps:

### Install the NVIDIA Container Toolkit

Follow [NVIDIA's instructions to install the NVIDIA Container Toolkit](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html) on your host machine. The NVIDIA Container Toolkit is available on a variety of Linux distributions. Make sure you have installed the NVIDIA driver for your Linux distribution before installing the NVIDIA Container Toolkit.

### Enable GPU passthrough

Enable GPU passthrough to your devcontainer by using `hostRequirements`. Here's an example of a devcontainer with this property:

```json
{
  "hostRequirements": {
    "gpu": "optional" 
  }
}
```

> Note: Setting `gpu` property's value to `true` will work with GPU machine types, but fail with CPUs. Hence, setting it to `optional` works in both cases. See [schema](https://containers.dev/implementors/json_schema/#base-schema) for more configuration details.



## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/nvidia-cuda/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/nvidia-cuda/devcontainer-feature.json
================================================
{
  "id": "nvidia-cuda",
  "version": "2.0.0",
  "name": "NVIDIA CUDA",
  "description": "Installs shared libraries for NVIDIA CUDA.",
  "documentationURL": "https://github.com/devcontainers/features/tree/main/src/nvidia-cuda",
  "options": {
    "installCudnn": {
      "type": "boolean",
      "default": false,
      "description": "Additionally install CUDA Deep Neural Network (cuDNN) shared library"
    },
    "installCudnnDev": {
      "type": "boolean",
      "default": false,
      "description": "Additionally install CUDA Deep Neural Network (cuDNN) development libraries and headers"
    },
    "installNvtx": {
      "type": "boolean",
      "default": false,
      "description": "Additionally install NVIDIA Tools Extension (NVTX)"
    },
    "installToolkit": {
      "type": "boolean",
      "default": false,
      "description": "Additionally install NVIDIA CUDA Toolkit"
    },
    "cudaVersion": {
      "type": "string",
      "proposals": [
        "12.5",
        "12.4",
        "12.3",
        "12.2",
        "12.1",
        "12.0",
        "11.8",
        "11.7",
        "11.6",
        "11.5",
        "11.4",
        "11.3",
        "11.2"
      ],
      "default": "11.8",
      "description": "Version of CUDA to install"
    },
    "cudnnVersion": {
      "type": "string",
      "proposals": [
        "automatic",
        "8.9.5.29",
        "8.9.4.25",
        "8.9.3.28",
        "8.9.2.26",
        "8.9.1.23",
        "8.9.0.131",
        "8.8.1.3",
        "8.8.0.121",
        "8.7.0.84",
        "8.6.0.163",
        "8.5.0.96",
        "8.4.1.50",
        "8.4.0.27",
        "8.3.3.40",
        "8.3.2.44",
        "8.3.1.22",
        "8.3.0.98",
        "8.2.4.15",
        "8.2.2.26",
        "8.2.1.32",
        "8.2.0.53",
        "8.1.1.33",
        "8.1.0.77",
        "9.0.0.312",
        "9.1.0.70",
        "9.1.1.17",
        "9.2.0.82",
        "9.2.1.18",
        "9.3.0.75",
        "9.4.0.58"
      ],
      "default": "automatic",
      "description": "Version of cuDNN to install"
    }
  },
  "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes shared libraries for NVIDIA CUDA pre-installed and available on the `PATH`. It's only useful for dev containers that run on a host machine with an NVIDIA GPU. Within your dev container, use the `nvidia-smi` command to ensure that your GPU is available for CUDA. If the `nvidia-smi` command is not available, you may need to follow NVIDIA's instructions to install the NVIDIA Container Toolkit on your host machine."
                    }
                ]
            }
        }
    },
  "installsAfter": [
      "ghcr.io/devcontainers/features/common-utils"
  ]
}



================================================
FILE: src/nvidia-cuda/install.sh
================================================
#!/usr/bin/env bash

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

INSTALL_CUDNN=${INSTALLCUDNN}
INSTALL_CUDNNDEV=${INSTALLCUDNNDEV}
INSTALL_NVTX=${INSTALLNVTX}
INSTALL_TOOLKIT=${INSTALLTOOLKIT}
CUDA_VERSION=${CUDAVERSION}
CUDNN_VERSION=${CUDNNVERSION}

. /etc/os-release 

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

if [ $VERSION_CODENAME = "bookworm" ] || [ $VERSION_CODENAME = "jammy" ] && [ $CUDA_VERSION \< 11.7 ]; then  
    echo "(!) Unsupported distribution version '${VERSION_CODENAME}' for CUDA < 11.7"
    exit 1
fi  

export DEBIAN_FRONTEND=noninteractive

check_packages wget ca-certificates

# Determine system architecture and set NVIDIA repository URL accordingly
ARCH=$(uname -m)
case $ARCH in
    x86_64)
        NVIDIA_ARCH="x86_64"
        ;;
    aarch64 | arm64)
        NVIDIA_ARCH="arm64"
        ;;
    *)
        echo "Unsupported architecture: $ARCH"
        exit 1
        ;;
esac

# Add NVIDIA's package repository to apt so that we can download packages
# Updating the repo to ubuntu2204 as ubuntu 20.04 is going out of support. 
NVIDIA_REPO_URL="https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/$NVIDIA_ARCH"
KEYRING_PACKAGE="cuda-keyring_1.0-1_all.deb"
KEYRING_PACKAGE_URL="$NVIDIA_REPO_URL/$KEYRING_PACKAGE"
KEYRING_PACKAGE_PATH="$(mktemp -d)"
KEYRING_PACKAGE_FILE="$KEYRING_PACKAGE_PATH/$KEYRING_PACKAGE"
wget -O "$KEYRING_PACKAGE_FILE" "$KEYRING_PACKAGE_URL"
apt-get install -yq "$KEYRING_PACKAGE_FILE"
apt-get update -yq

# Ensure that the requested version of CUDA is available
cuda_pkg="cuda-libraries-${CUDA_VERSION/./-}"
nvtx_pkg="cuda-nvtx-${CUDA_VERSION/./-}"
toolkit_pkg="cuda-toolkit-${CUDA_VERSION/./-}"
if ! apt-cache show "$cuda_pkg"; then
    echo "The requested version of CUDA is not available: CUDA $CUDA_VERSION"
    if [ "$NVIDIA_ARCH" = "arm64" ]; then
        echo "Note: arm64 supports limited CUDA versions. Please check available versions:"
        echo "https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/arm64"
    fi
    exit 1
fi

echo "Installing CUDA libraries..."
apt-get install -yq "$cuda_pkg"
apt-get update -yq --fix-missing

# auto find recent cudnn version
major_cuda_version=$(echo "${CUDA_VERSION}" | cut -d '.' -f 1)
if [ "$CUDNN_VERSION" = "automatic" ]; then
    if [[ "$CUDA_VERSION" < "12.3" ]]; then
        CUDNN_VERSION=$(apt-cache policy libcudnn8 | grep "$CUDA_VERSION" | grep -Eo '^[^-1+]*' | sort -V | tail -n1 | xargs)
    else
        CUDNN_VERSION=$(apt-cache policy libcudnn9-cuda-$major_cuda_version | grep "Candidate" | awk '{print $2}' | grep -Eo '^[^-+]*')
    fi
fi
major_cudnn_version=$(echo "${CUDNN_VERSION}" | cut -d '.' -f 1)

if [ "$INSTALL_CUDNN" = "true" ]; then
    # Ensure that the requested version of cuDNN is available AND compatible
    #if major cudnn version is 9, then we need to install libcudnn9-cuda-<major_cuda_version>_<CUDNN_VERSION>-1 package
    #else we need to install libcudnn8_<CUDNN_VERSION>-1+cuda<CUDA_VERSION>" package
    if [[ $major_cudnn_version -ge "9" ]]
    then
        cudnn_pkg_version="libcudnn9-cuda-${major_cuda_version}=${CUDNN_VERSION}-1"
    else
        cudnn_pkg_version="libcudnn8=${CUDNN_VERSION}-1+cuda${CUDA_VERSION}"
    fi

    if ! apt-cache show "$cudnn_pkg_version"; then
        echo "The requested version of cuDNN is not available: cuDNN $CUDNN_VERSION for CUDA $CUDA_VERSION"
        if [ "$NVIDIA_ARCH" = "arm64" ]; then
            echo "Note: arm64 has limited cuDNN package availability"
        fi
        exit 1
    fi

    echo "Installing cuDNN libraries..."
    apt-get install -yq "$cudnn_pkg_version"
fi

if [ "$INSTALL_CUDNNDEV" = "true" ]; then
    # Ensure that the requested version of cuDNN development package is available AND compatible
    #if major cudnn version is 9, then we need to install libcudnn9-dev-cuda-<major_cuda_version>_<CUDNN_VERSION>-1 package
    #else we need to install libcudnn8-dev_<CUDNN_VERSION>-1+cuda<CUDA_VERSION>" package
    if [[ $major_cudnn_version -ge "9" ]]
    then
        cudnn_dev_pkg_version="libcudnn9-dev-cuda-${major_cuda_version}=${CUDNN_VERSION}-1"
    else
        cudnn_dev_pkg_version="libcudnn8-dev=${CUDNN_VERSION}-1+cuda${CUDA_VERSION}"
    fi
    if ! apt-cache show "$cudnn_dev_pkg_version"; then
        echo "The requested version of cuDNN development package is not available: cuDNN $CUDNN_VERSION for CUDA $CUDA_VERSION"
        if [ "$NVIDIA_ARCH" = "arm64" ]; then
            echo "Note: arm64 has limited cuDNN development package availability"
        fi
        exit 1
    fi

    echo "Installing cuDNN dev libraries..."
    apt-get install -yq "$cudnn_dev_pkg_version"
fi

if [ "$INSTALL_NVTX" = "true" ]; then
    echo "Installing NVTX..."
    apt-get install -yq "$nvtx_pkg"
fi

if [ "$INSTALL_TOOLKIT" = "true" ]; then
    echo "Installing CUDA Toolkit..."
    apt-get install -yq "$toolkit_pkg"
fi

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"



================================================
FILE: src/nvidia-cuda/NOTES.md
================================================
## Compatibility

This Feature adds shared libraries for NVIDIA CUDA and is only useful for devcontainers that run on a host machine with an NVIDIA GPU. Within your devcontainer, use the `nvidia-smi` command to ensure that your GPU is available for CUDA.

If the `nvidia-smi` command is not available within your devcontainer, you may need to complete the following steps:

### Install the NVIDIA Container Toolkit

Follow [NVIDIA's instructions to install the NVIDIA Container Toolkit](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html) on your host machine. The NVIDIA Container Toolkit is available on a variety of Linux distributions. Make sure you have installed the NVIDIA driver for your Linux distribution before installing the NVIDIA Container Toolkit.

### Enable GPU passthrough

Enable GPU passthrough to your devcontainer by using `hostRequirements`. Here's an example of a devcontainer with this property:

```json
{
  "hostRequirements": {
    "gpu": "optional" 
  }
}
```

> Note: Setting `gpu` property's value to `true` will work with GPU machine types, but fail with CPUs. Hence, setting it to `optional` works in both cases. See [schema](https://containers.dev/implementors/json_schema/#base-schema) for more configuration details.



## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/oryx/README.md
================================================

# Oryx (oryx)

Installs the oryx CLI

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/oryx:1": {}
}
```





## OS Support

See [supportedPlatformVersions.md](https://github.com/microsoft/Oryx/blob/main/doc/supportedPlatformVersions.md) on the Oryx repository for supported platforms.  Notably, `oryx` does not support Debian "jammy".

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/oryx/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/oryx/devcontainer-feature.json
================================================
{
    "id": "oryx",
    "version": "1.4.1",
    "name": "Oryx",
    "description": "Installs the oryx CLI",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/oryx",
    "containerEnv": {
        "ORYX_SDK_STORAGE_BASE_URL": "https://oryx-cdn.microsoft.io",
        "ENABLE_DYNAMIC_INSTALL": "true",
        "DYNAMIC_INSTALL_ROOT_DIR": "/opt",
        "ORYX_PREFER_USER_INSTALLED_SDKS": "true",
        "ORYX_DIR": "/usr/local/oryx",
        "DEBIAN_FLAVOR": "focal-scm",
        "PATH": "/usr/local/oryx:${PATH}"
    },
    "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes the oryx CLI pre-installed and available on the `PATH`."
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils",
        "ghcr.io/devcontainers/features/dotnet"
    ]
}



================================================
FILE: src/oryx/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------


USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="${UPDATE_RC:-"true"}"

MICROSOFT_GPG_KEYS_URI="https://packages.microsoft.com/keys/microsoft.asc"

set -eu

# Clean up
rm -rf /var/lib/apt/lists/*

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

function updaterc() {
    if [ "${UPDATE_RC}" = "true" ]; then
        echo "Updating /etc/bash.bashrc and /etc/zsh/zshrc..."
        if [[ "$(cat /etc/bash.bashrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/bash.bashrc
        fi
        if [ -f "/etc/zsh/zshrc" ] && [[ "$(cat /etc/zsh/zshrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/zsh/zshrc
        fi
    fi
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

install_dotnet_with_script()
{
    local version="$1"
    CURRENT_DIR=$(dirname "${BASH_SOURCE[0]}")
    DOTNET_INSTALL_SCRIPT="$CURRENT_DIR/scripts/vendor/dotnet-install.sh"
    DOTNET_INSTALL_DIR='/usr/share/dotnet'

    check_packages icu-devtools

    "$DOTNET_INSTALL_SCRIPT" \
        --version "$version" \
        --install-dir "$DOTNET_INSTALL_DIR" \
        --no-path

    DOTNET_BINARY="dotnet"
    export PATH="${PATH}:/usr/share/dotnet"
}

install_dotnet_using_apt() {
    echo "Attempting to auto-install dotnet..."
    install_from_microsoft_feed=false
    apt_get_update
    DOTNET_INSTALLATION_PACKAGE="dotnet8"
    apt-get -yq install $DOTNET_INSTALLATION_PACKAGE || install_from_microsoft_feed="true"

    if [ "${install_from_microsoft_feed}" = "true" ]; then
        echo "Attempting install from microsoft apt feed..."
        curl -sSL ${MICROSOFT_GPG_KEYS_URI} | gpg --dearmor > /usr/share/keyrings/microsoft-archive-keyring.gpg
        echo "deb [arch=${architecture} signed-by=/usr/share/keyrings/microsoft-archive-keyring.gpg] https://packages.microsoft.com/repos/microsoft-${ID}-${VERSION_CODENAME}-prod ${VERSION_CODENAME} main" > /etc/apt/sources.list.d/microsoft.list
        apt-get update -y
        DOTNET_INSTALLATION_PACKAGE="dotnet-sdk-8.0"
        DOTNET_SKIP_FIRST_TIME_EXPERIENCE="true" apt-get install -yq $DOTNET_INSTALLATION_PACKAGE
    fi

    DOTNET_BINARY="/usr/bin/dotnet"
    echo -e "Finished attempt to install dotnet.  Sdks installed:\n"
    dotnet --list-sdks

    # Clean up
    apt-get clean -y
    rm -rf /var/lib/apt/lists/*
}

. /etc/os-release
architecture="$(dpkg --print-architecture)"

# Currently, oryx is not supported with "jammy"
if [[ "jammy" = *"${VERSION_CODENAME}"* ]]; then
    echo "(!) Unsupported distribution version '${VERSION_CODENAME}'."
    exit 1
fi

# If we don't already have Oryx installed, install it now.
if  oryx --version > /dev/null ; then
    echo "oryx is already installed. Skipping installation."
    # Clean up
    rm -rf /var/lib/apt/lists/*
    exit 0
fi

echo "Installing Oryx..."

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive

# Install dependencies
check_packages git sudo curl ca-certificates apt-transport-https gnupg2 dirmngr libc-bin moreutils

if ! cat /etc/group | grep -e "^oryx:" > /dev/null 2>&1; then
    groupadd -r oryx
fi
usermod -a -G oryx "${USERNAME}"

# Required to decide if we want to clean up dotnet later.
DOTNET_INSTALLATION_PACKAGE=""
DOTNET_BINARY=""

if dotnet --version > /dev/null ; then
    DOTNET_BINARY=$(which dotnet)
    RUNTIME_VERSIONS=$(dotnet --list-runtimes | awk '{print $2}' | sort | uniq)
fi

MAJOR_VERSION_ID=$(echo $(dotnet --version) | cut -d . -f 1)
PATCH_VERSION_ID=$(echo $(dotnet --version) | cut -d . -f 3)

PINNED_SDK_VERSION=""
# Oryx needs to be built with .NET 8
if [[ "${DOTNET_BINARY}" = "" ]] || [[ $MAJOR_VERSION_ID != "8" ]] || [[ $MAJOR_VERSION_ID = "8" && ${PATCH_VERSION_ID} -ne "202" ]] ; then
    echo "'dotnet 8' was not detected. Attempting to install .NET 8 to build oryx."
    # The oryx build fails with .Net 8.0.201, see https://github.com/devcontainers/images/issues/974
    # Pinning it to a working version until the upstream Oryx repo updates the dependency
    # install_dotnet_using_apt
    PINNED_SDK_VERSION="8.0.202"
    install_dotnet_with_script ${PINNED_SDK_VERSION}
    if ! dotnet --version > /dev/null ; then
        echo "(!) Please install Dotnet before installing Oryx"
        exit 1
    fi
fi

BUILD_SCRIPT_GENERATOR=/usr/local/buildscriptgen
ORYX=/usr/local/oryx
GIT_ORYX=/opt/tmp/oryx-repo

mkdir -p ${BUILD_SCRIPT_GENERATOR}
mkdir -p ${ORYX}

git clone --depth=1 https://github.com/microsoft/Oryx $GIT_ORYX

if [[ "${PINNED_SDK_VERSION}" != "" ]]; then
    cd $GIT_ORYX
    dotnet new globaljson --sdk-version ${PINNED_SDK_VERSION}
fi

SOLUTION_FILE_NAME="Oryx.sln"
echo "Building solution '$SOLUTION_FILE_NAME'..."

cd $GIT_ORYX
${DOTNET_BINARY} build "$SOLUTION_FILE_NAME" -c Debug

${DOTNET_BINARY} publish -property:ValidateExecutableReferencesMatchSelfContained=false -r linux-x64 -o ${BUILD_SCRIPT_GENERATOR} -c Release $GIT_ORYX/src/BuildScriptGeneratorCli/BuildScriptGeneratorCli.csproj --self-contained true
${DOTNET_BINARY} publish -r linux-x64 -o ${BUILD_SCRIPT_GENERATOR} -c Release $GIT_ORYX/src/BuildServer/BuildServer.csproj --self-contained true

chmod a+x ${BUILD_SCRIPT_GENERATOR}/GenerateBuildScript

ln -s ${BUILD_SCRIPT_GENERATOR}/GenerateBuildScript ${ORYX}/oryx
cp -f $GIT_ORYX/images/build/benv.sh ${ORYX}/benv
cp -f $GIT_ORYX/images/build/logger.sh ${ORYX}/logger

ORYX_INSTALL_DIR="/opt"
mkdir -p "${ORYX_INSTALL_DIR}"

# Directory used by the oryx tool to cache the automatically installed python packages from `requirements.txt`
PIP_CACHE_DIR="/usr/local/share/pip-cache/lib"
mkdir -p ${PIP_CACHE_DIR}

updaterc "export ORYX_SDK_STORAGE_BASE_URL=https://oryx-cdn.microsoft.io && export ENABLE_DYNAMIC_INSTALL=true && DYNAMIC_INSTALL_ROOT_DIR=$ORYX_INSTALL_DIR && ORYX_PREFER_USER_INSTALLED_SDKS=true && export DEBIAN_FLAVOR=focal-scm"

chown -R "${USERNAME}:oryx" "${ORYX_INSTALL_DIR}" "${BUILD_SCRIPT_GENERATOR}" "${ORYX}" "${PIP_CACHE_DIR}"
chmod -R g+r+w "${ORYX_INSTALL_DIR}" "${BUILD_SCRIPT_GENERATOR}" "${ORYX}" "${PIP_CACHE_DIR}"
find "${ORYX_INSTALL_DIR}" -type d -print0 | xargs -n 1 -0 chmod g+s
find "${BUILD_SCRIPT_GENERATOR}" -type d -print0 | xargs -n 1 -0 chmod g+s
find "${ORYX}" -type d -print0 | xargs -n 1 -0 chmod g+s
find "${PIP_CACHE_DIR}" -type d -print0 | xargs -n 1 -0 chmod g+s

# /opt/tmp/build and /opt/tmp/images is required by Oryx for dynamically installing platforms
cp -rf $GIT_ORYX/build /opt/tmp
cp -rf $GIT_ORYX/images /opt/tmp

# Clean up
rm -rf $GIT_ORYX

# Remove NuGet installed by the build/buildSln.sh
rm -rf /root/.nuget
rm -rf /root/.local/share/NuGet

# Remove dotnet if installed by the oryx feature
if [[ "${DOTNET_INSTALLATION_PACKAGE}" != "" ]]; then
    apt purge -yq $DOTNET_INSTALLATION_PACKAGE
fi

if [[ "${PINNED_SDK_VERSION}" != "" ]]; then
    rm -f ${GIT_ORYX}/global.json
    rm -rf /usr/share/dotnet/sdk/$PINNED_SDK_VERSION
    NEW_RUNTIME_VERSIONS=$(dotnet --list-runtimes | awk '{print $2}' | sort | uniq)
    if [ -n "${RUNTIME_VERSIONS:-}" ]; then
        SDK_INSTALLED_RUNTIME=$(echo "$NEW_RUNTIME_VERSIONS" | grep -vxFf <(echo "$RUNTIME_VERSIONS"))
    else
        SDK_INSTALLED_RUNTIME="$NEW_RUNTIME_VERSIONS"
    fi
    rm -rf /usr/share/dotnet/shared/Microsoft.NETCore.App/$SDK_INSTALLED_RUNTIME
    rm -rf /usr/share/dotnet/shared/Microsoft.AspNetCore.App/$SDK_INSTALLED_RUNTIME
    rm -rf /usr/share/dotnet/templates/$SDK_INSTALLED_RUNTIME
fi


# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"


================================================
FILE: src/oryx/NOTES.md
================================================


## OS Support

See [supportedPlatformVersions.md](https://github.com/microsoft/Oryx/blob/main/doc/supportedPlatformVersions.md) on the Oryx repository for supported platforms.  Notably, `oryx` does not support Debian "jammy".

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/php/README.md
================================================

# PHP (php)



## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/php:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a PHP version | string | latest |
| installComposer | Install PHP Composer? | boolean | true |

## Customizations

### VS Code Extensions

- `xdebug.php-debug`
- `bmewburn.vscode-intelephense-client`
- `xdebug.php-pack`
- `devsense.phptools-vscode`



## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/php/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/php/devcontainer-feature.json
================================================
{
    "id": "php",
    "version": "1.1.4",
    "name": "PHP",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/php",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "8",
                "8.2",
                "8.2.0",
                "none"
            ],
            "default": "latest",
            "description": "Select or enter a PHP version"
        },
        "installComposer": {
            "type": "boolean",
            "default": true,
            "description": "Install PHP Composer?"
        }
    },
    "customizations": {
        "vscode": {
            "extensions": [
                "xdebug.php-debug",
                "bmewburn.vscode-intelephense-client",
                "xdebug.php-pack",
                "devsense.phptools-vscode"
            ],
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes PHP pre-installed and available on the `PATH`, along with PHP language extensions for PHP development."
                    }
                ]
            }
        }
    },
    "containerEnv": {
        "PHP_PATH": "/usr/local/php/current",
        "PATH": "/usr/local/php/current/bin:${PATH}"
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/php/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Maintainer: The VS Code and Codespaces Teams

set -eux

# Clean up
rm -rf /var/lib/apt/lists/*

PHP_VERSION="${VERSION:-"latest"}"
INSTALL_COMPOSER="${INSTALLCOMPOSER:-"true"}"
OVERRIDE_DEFAULT_VERSION="${OVERRIDEDEFAULTVERSION:-"true"}"

export PHP_DIR="${PHP_DIR:-"/usr/local/php"}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="${UPDATE_RC:-"true"}"

# Comma-separated list of php versions to be installed
# alongside PHP_VERSION, but not set as default.
ADDITIONAL_VERSIONS="${ADDITIONALVERSIONS:-""}"

export DEBIAN_FRONTEND=noninteractive

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi


# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# If in automatic mode, determine if a user already exists, if not use vscode
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ]; then
    USERNAME=root
    USER_UID=0
    USER_GID=0
fi

architecture="$(uname -m)"
if [ "${architecture}" != "amd64" ] && [ "${architecture}" != "x86_64" ] && [ "${architecture}" != "arm64" ] && [ "${architecture}" != "aarch64" ]; then
    echo "(!) Architecture $architecture unsupported"
    exit 1
fi

updaterc() {
    if [ "${UPDATE_RC}" = "true" ]; then
        echo "Updating /etc/bash.bashrc and /etc/zsh/zshrc..."
        if [[ "$(cat /etc/bash.bashrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/bash.bashrc
        fi
        if [ -f "/etc/zsh/zshrc" ] && [[ "$(cat /etc/zsh/zshrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/zsh/zshrc
        fi
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
            echo "Running apt-get update..."
            apt-get update -y
        fi
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    echo "${!variable_name}"
    echo "$(echo "${requested_version}" | grep -o "." | wc -l)"
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    echo "${!variable_name}"
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Install PHP Composer
addcomposer() {
    "${PHP_SRC}" -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
    HASH="$(wget -q -O - https://composer.github.io/installer.sig)"
    "${PHP_SRC}" -r "if (hash_file('sha384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
    "${PHP_SRC}" composer-setup.php --install-dir="/usr/local/bin" --filename=composer
    "${PHP_SRC}" -r "unlink('composer-setup.php');"
}

init_php_install() {
    PHP_INSTALL_DIR="${PHP_DIR}/${PHP_VERSION}"
    if [ -d "${PHP_INSTALL_DIR}" ]; then
        echo "(!) PHP version ${PHP_VERSION} already exists."
        exit 1
    fi

    if ! cat /etc/group | grep -e "^php:" > /dev/null 2>&1; then
        groupadd -r php
    fi
    usermod -a -G php "${USERNAME}"
    PHP_URL="https://www.php.net/distributions/php-${PHP_VERSION}.tar.gz"

    PHP_INI_DIR="${PHP_INSTALL_DIR}/ini"
    CONF_DIR="${PHP_INI_DIR}/conf.d"
    mkdir -p "${CONF_DIR}";

    PHP_EXT_DIR="${PHP_INSTALL_DIR}/extensions"
    mkdir -p "${PHP_EXT_DIR}"

    PHP_SRC_DIR="/usr/src/php"
    mkdir -p $PHP_SRC_DIR
    cd $PHP_SRC_DIR
}

install_previous_version() {
    PHP_VERSION=$1
    if [[ "$ORIGINAL_PHP_VERSION" == "latest" ]]; then
        find_prev_version_from_git_tags PHP_VERSION https://github.com/php/php-src "tags/php-"
        echo -e "\nAttempting to install previous version v${PHP_VERSION}"
        init_php_install
        wget -O php.tar.xz "$PHP_URL"
    else 
        echo -e "\nFailed to install v$PHP_VERSION"
    fi
}

install_php() {
    PHP_VERSION="$1"

    init_php_install
    
    wget -O php.tar.xz "$PHP_URL" || install_previous_version "$PHP_VERSION"

    tar -xf $PHP_SRC_DIR/php.tar.xz -C "$PHP_SRC_DIR" --strip-components=1
    cd $PHP_SRC_DIR;

    # PHP 7.4+, the pecl/pear installers are officially deprecated and are removed in PHP 8+
    # Thus, requiring an explicit "--with-pear"
    IFS="."
    read -a versions <<< "${PHP_VERSION}"
    PHP_MAJOR_VERSION=${versions[0]}
    PHP_MINOR_VERSION=${versions[1]}

    VERSION_CONFIG=""
    if (( $(($PHP_MAJOR_VERSION)) >= 8 )) || (( $(($PHP_MAJOR_VERSION)) == 7 && $(($PHP_MINOR_VERSION)) >= 4 )); then 
        VERSION_CONFIG="--with-pear"
    fi

    ./configure --prefix="${PHP_INSTALL_DIR}" --with-config-file-path="$PHP_INI_DIR" --with-config-file-scan-dir="$CONF_DIR" --enable-option-checking=fatal --with-curl --with-libedit --enable-mbstring --with-openssl --with-zlib --with-password-argon2 --with-sodium=shared "$VERSION_CONFIG" EXTENSION_DIR="$PHP_EXT_DIR";

    make -j "$(nproc)"
    find -type f -name '*.a' -delete
    make install
    find "${PHP_INSTALL_DIR}" -type f -executable -exec strip --strip-all '{}' + || true
    make clean

    cp -v $PHP_SRC_DIR/php.ini-* "$PHP_INI_DIR/";
    cp "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini"

    # Install xdebug
    "${PHP_INSTALL_DIR}/bin/pecl" install xdebug
    XDEBUG_INI="${CONF_DIR}/xdebug.ini"

    echo "zend_extension=${PHP_EXT_DIR}/xdebug.so" > "${XDEBUG_INI}"
    echo "xdebug.mode = debug" >> "${XDEBUG_INI}"
    echo "xdebug.start_with_request = yes" >> "${XDEBUG_INI}"
    echo "xdebug.client_port = 9003" >> "${XDEBUG_INI}"
}

if [ "${PHP_VERSION}" != "none" ]; then
    # Persistent / runtime dependencies
    RUNTIME_DEPS="wget ca-certificates git build-essential xz-utils curl"

    # PHP dependencies
    PHP_DEPS="libssl-dev libcurl4-openssl-dev libedit-dev libsqlite3-dev libxml2-dev zlib1g-dev libsodium-dev libonig-dev"

    . /etc/os-release

    if [ "${VERSION_CODENAME}" = "bionic" ]; then
        PHP_DEPS="${PHP_DEPS} libargon2-0-dev"
    else
        PHP_DEPS="${PHP_DEPS} libargon2-dev"
    fi

    # Dependencies required for running "phpize"
    PHPIZE_DEPS="autoconf dpkg-dev file g++ gcc libc-dev make pkg-config re2c"

    # Install dependencies
    check_packages $RUNTIME_DEPS $PHP_DEPS $PHPIZE_DEPS

    # storing value of PHP_VERSION before it changes
    ORIGINAL_PHP_VERSION=$PHP_VERSION
    find_version_from_git_tags PHP_VERSION https://github.com/php/php-src "tags/php-"
    install_php "${PHP_VERSION}"

    PHP_SRC="${PHP_INSTALL_DIR}/bin/php"
else
    set +e
        PHP_SRC=$(which php)
    set -e
fi

# Install PHP Composer if needed
if [[ "${INSTALL_COMPOSER}" = "true" ]]; then
    if [ -z "${PHP_SRC}" ]; then
        echo "(!) Could not install Composer. PHP not found."
        exit 1
    fi

    addcomposer
fi

# Additional php versions to be installed but not be set as default.
if [ ! -z "${ADDITIONAL_VERSIONS}" ]; then
    OLDIFS=$IFS
    IFS=","
        read -a additional_versions <<< "$ADDITIONAL_VERSIONS"
        for version in "${additional_versions[@]}"; do
            OVERRIDE_DEFAULT_VERSION="false"
            install_php "${version}"
        done
    IFS=$OLDIFS
fi

if [ "${PHP_VERSION}" != "none" ]; then
    CURRENT_DIR="${PHP_DIR}/current"
    if [[ ! -d "${CURRENT_DIR}" ]]; then
        ln -s -r "${PHP_INSTALL_DIR}" ${CURRENT_DIR}
    fi

    if [ "${OVERRIDE_DEFAULT_VERSION}" = "true" ]; then
        if [[ $(ls -l ${CURRENT_DIR}) != *"-> ${PHP_INSTALL_DIR}"* ]] ; then
            rm "${CURRENT_DIR}"
            ln -s -r "${PHP_INSTALL_DIR}" "${CURRENT_DIR}"
        fi
    fi

    rm -rf "${PHP_SRC_DIR}"
    updaterc "if [[ \"\${PATH}\" != *\"${CURRENT_DIR}\"* ]]; then export PATH=\"${CURRENT_DIR}/bin:\${PATH}\"; fi"

    chown -R "${USERNAME}:php" "${PHP_DIR}"
    chmod -R g+r+w "${PHP_DIR}"
    find "${PHP_DIR}" -type d -print0 | xargs -n 1 -0 chmod g+s
fi

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"



================================================
FILE: src/php/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/powershell/README.md
================================================

# PowerShell (powershell)

Installs PowerShell along with needed dependencies. Useful for base Dockerfiles that often are missing required install dependencies like gpg.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/powershell:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a version of PowerShell. | string | latest |
| modules | Optional comma separated list of PowerShell modules to install. If you need to install a specific version of a module, use '==' to specify the version (e.g. 'az.resources==2.5.0') | string | - |
| powershellProfileURL | Optional (publicly accessible) URL to download PowerShell profile. | string | - |

## Customizations

### VS Code Extensions

- `ms-vscode.powershell`



## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/powershell/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/powershell/devcontainer-feature.json
================================================
{
    "id": "powershell",
    "version": "1.5.1",
    "name": "PowerShell",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/powershell",
    "description": "Installs PowerShell along with needed dependencies. Useful for base Dockerfiles that often are missing required install dependencies like gpg.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "none",
                "7.4",
                "7.3",
                "7.2"
            ],
            "default": "latest",
            "description": "Select or enter a version of PowerShell."
        },
        "modules": {
            "type": "string",
            "default": "",
            "description": "Optional comma separated list of PowerShell modules to install. If you need to install a specific version of a module, use '==' to specify the version (e.g. 'az.resources==2.5.0')"
        },
        "powershellProfileURL": {
            "type": "string",
            "default": "",
            "description": "Optional (publicly accessible) URL to download PowerShell profile."
        }
    },
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-vscode.powershell"
            ]
        },
        "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes PowerShell along with needed dependencies pre-installed and available on the `PATH`, along with the PowerShell extension."
                    }
                ]
            }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/powershell/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/powershell.md
# Maintainer: The VS Code and Codespaces Teams

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

POWERSHELL_VERSION=${VERSION:-"latest"}
POWERSHELL_MODULES="${MODULES:-""}"
POWERSHELL_PROFILE_URL="${POWERSHELLPROFILEURL}"

MICROSOFT_GPG_KEYS_URI="https://packages.microsoft.com/keys/microsoft.asc"
#MICROSOFT_GPG_KEYS_URI=$(curl https://packages.microsoft.com/keys/microsoft.asc -o /usr/share/keyrings/microsoft-archive-keyring.gpg)
POWERSHELL_ARCHIVE_ARCHITECTURES_UBUNTU="amd64"
POWERSHELL_ARCHIVE_ARCHITECTURES_ALMALINUX="x86_64"
POWERSHELL_ARCHIVE_VERSION_CODENAMES="stretch buster bionic focal bullseye jammy bookworm noble"

#These key servers are used to verify the authenticity of packages and repositories.
#keyservers for ubuntu and almalinux are different so we need to specify both
GPG_KEY_SERVERS="keyserver hkp://keyserver.ubuntu.com
keyserver hkp://keyserver.ubuntu.com:80
keyserver hkps://keys.openpgp.org
keyserver hkp://keyserver.pgp.com
keyserver hkp://keyserver.fedoraproject.org
keyserver hkps://keys.openpgp.org
keyserver hkp://pgp.mit.edu
keyserver hkp://keyserver.redhat.com"


if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Clean up package manager cache
clean_cache() {
    if [ -d "/var/cache/apt" ]; then
        apt-get clean
    fi
    if [ -d "/var/cache/dnf" ]; then
        rm -rf /var/cache/dnf/*
    fi
}
# Install dependencies for RHEL/CentOS/AlmaLinux (DNF-based systems)
install_using_dnf() {
   dnf remove -y curl-minimal
   dnf install -y curl gnupg2 ca-certificates dnf-plugins-core
   dnf clean all
   dnf makecache
   curl --version
}

# Install PowerShell on RHEL/CentOS/AlmaLinux-based systems (DNF)
install_powershell_dnf() {
    # Install wget, if not already installed
    dnf install -y wget

    # Download Microsoft GPG key
    curl https://packages.microsoft.com/keys/microsoft.asc -o /usr/share/keyrings/microsoft-archive-keyring.gpg
    ls -l /usr/share/keyrings/microsoft-archive-keyring.gpg

    # Install necessary dependencies
    dnf install -y krb5-libs libicu openssl-libs zlib

    # Add Microsoft PowerShell repository 
        curl "https://packages.microsoft.com/config/rhel/9.0/prod.repo" > /etc/yum.repos.d/microsoft.repo
    
    # Install PowerShell
     dnf install --assumeyes powershell
}


# Detect the package manager and OS
detect_package_manager() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        if [[ "$ID" == "ubuntu" || "$ID" == "debian" ]]; then
            echo "Detected Debian/Ubuntu-based system"
            install_using_apt
            install_pwsh
        elif [[ "$ID" == "centos" || "$ID" == "rhel" || "$ID" == "almalinux" ]]; then
            echo "Detected RHEL/CentOS/AlmaLinux-based system"
            install_using_dnf
            install_powershell_dnf
            install_pwsh
        else
            echo "Unsupported Linux distribution: $ID"
            exit 1
        fi
    else
        echo "Could not detect OS"
        exit 1
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
   check_packages() {
    if command -v dpkg > /dev/null 2>&1; then
        # If dpkg exists, assume APT-based system (Debian/Ubuntu)
        for package in "$@"; do
            if ! dpkg -s "$package" > /dev/null 2>&1; then
                echo "Package $package not installed. Installing using apt-get..."
                apt-get update
                apt-get install -y --no-install-recommends "$package"
            else
                echo "Package $package is already installed (APT)."
            fi
        done
        elif command -v dnf > /dev/null 2>&1; then
    for package in "$@"; do
        if ! dnf list installed "$package" > /dev/null 2>&1; then
            echo "Package $package not installed. Installing using dnf..."
            dnf install -y "$package"
        else
            echo "Package $package is already installed (DNF)."
        fi
    done
else
    echo "Unsupported package manager. Neither APT nor DNF found."
    return 1
fi

   
}

install_using_apt() {
    # Install dependencies
    check_packages apt-transport-https curl ca-certificates gnupg2 dirmngr
    # Import key safely (new 'signed-by' method rather than deprecated apt-key approach) and install
   
    curl -sSL ${MICROSOFT_GPG_KEYS_URI} | gpg --dearmor > /usr/share/keyrings/microsoft-archive-keyring.gpg
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/microsoft-archive-keyring.gpg] https://packages.microsoft.com/repos/microsoft-${ID}-${VERSION_CODENAME}-prod ${VERSION_CODENAME} main" > /etc/apt/sources.list.d/microsoft.list
    

    # Update lists
    apt-get update -yq

    # Soft version matching for CLI
    if [ "${POWERSHELL_VERSION}" = "latest" ] || [ "${POWERSHELL_VERSION}" = "lts" ] || [ "${POWERSHELL_VERSION}" = "stable" ]; then
        # Empty, meaning grab whatever "latest" is in apt repo
        version_suffix=""
    else    
        version_suffix="=$(apt-cache madison powershell | awk -F"|" '{print $2}' | sed -e 's/^[ \t]*//' | grep -E -m 1 "^(${POWERSHELL_VERSION})(\.|$|\+.*|-.*)")"

        if [ -z ${version_suffix} ] || [ ${version_suffix} = "=" ]; then
            echo "Provided POWERSHELL_VERSION (${POWERSHELL_VERSION}) was not found in the apt-cache for this package+distribution combo";
            return 1
        fi
        echo "version_suffix ${version_suffix}"
    fi

    apt-get install -yq powershell${version_suffix} || return 1
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");
    check_packages jq
    message=$(echo "$output" | jq -r '.message')
    
    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="${prev_version}"
    else 
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}


install_prev_pwsh() {
    pwsh_url=$1
    repo_url=$(get_github_api_repo_url $pwsh_url)
    echo -e "\n(!) Failed to fetch the latest artifacts for powershell v${POWERSHELL_VERSION}..."
    get_previous_version $pwsh_url $repo_url POWERSHELL_VERSION
    echo -e "\nAttempting to install v${POWERSHELL_VERSION}"
    install_pwsh "${POWERSHELL_VERSION}"
}

install_pwsh() {
    POWERSHELL_VERSION=$1
    powershell_filename="powershell-${POWERSHELL_VERSION}-linux-${architecture}.tar.gz"
    powershell_target_path="/opt/microsoft/powershell/$(echo ${POWERSHELL_VERSION} | grep -oE '[^\.]+' | head -n 1)"
    mkdir -p /tmp/pwsh "${powershell_target_path}"
    cd /tmp/pwsh
    curl -sSL -o "${powershell_filename}" "https://github.com/PowerShell/PowerShell/releases/download/v${POWERSHELL_VERSION}/${powershell_filename}"
}

install_using_github() {
    # Fall back on direct download if no apt package exists in microsoft pool
    check_packages curl ca-certificates gnupg2 dirmngr libc6 libgcc1 libgssapi-krb5-2 libstdc++6 libunwind8 libuuid1 zlib1g libicu[0-9][0-9]
    if ! type git > /dev/null 2>&1; then
        check_packages git
    fi

     if [ "${architecture}" = "amd64" ]; then
        architecture="x64"
    fi
    pwsh_url="https://github.com/PowerShell/PowerShell"
    find_version_from_git_tags POWERSHELL_VERSION $pwsh_url
    install_pwsh "${POWERSHELL_VERSION}"
    if grep -q "Not Found" "${powershell_filename}"; then 
        install_prev_pwsh $pwsh_url
    fi
    
    # downlaod the latest version of powershell and extracting the file to powershell directory
    wget https://github.com/PowerShell/PowerShell/releases/download/v${POWERSHELL_VERSION}/${powershell_filename}
    mkdir ~/powershell
    tar -xvf powershell-${POWERSHELL_VERSION}-linux-x64.tar.gz -C ~/powershell


    powershell_archive_sha256="$(cat release.html | tr '\n' ' ' | sed 's|<[^>]*>||g' | grep -oP "${powershell_filename}\s+\K[0-9a-fA-F]{64}" || echo '')"
    if [ -z "${powershell_archive_sha256}" ]; then
        echo "(!) WARNING: Failed to retrieve SHA256 for archive. Skipping validaiton."
    else
        echo "SHA256: ${powershell_archive_sha256}"
        echo "${powershell_archive_sha256} *${powershell_filename}" | sha256sum -c -
    fi
    tar xf "${powershell_filename}" -C "${powershell_target_path}"
    chmod 755 "${powershell_target_path}/pwsh"
    ln -sf "${powershell_target_path}/pwsh" /usr/bin/pwsh
    add-shell "/usr/bin/pwsh"
    cd /tmp
    rm -rf /tmp/pwsh
}

if ! type pwsh >/dev/null 2>&1; then
    export DEBIAN_FRONTEND=noninteractive
    
    # Source /etc/os-release to get OS info
    . /etc/os-release
    architecture="$(uname -m)"
    if [[ "$ID" == "ubuntu" || "$ID" == "debian" ]]; then
        POWERSHELL_ARCHIVE_ARCHITECTURES="${POWERSHELL_ARCHIVE_ARCHITECTURES_UBUNTU}"
    elif [[ "$ID" == "centos" || "$ID" == "rhel" || "$ID" == "almalinux" ]]; then
        POWERSHELL_ARCHIVE_ARCHITECTURES="${POWERSHELL_ARCHIVE_ARCHITECTURES_ALMALINUX}"
    fi

    if [[ "${POWERSHELL_ARCHIVE_ARCHITECTURES}" = *"${POWERSHELL_ARCHIVE_ARCHITECTURES_UBUNTU}"* ]] && [[  "${POWERSHELL_ARCHIVE_VERSION_CODENAMES}" = *"${VERSION_CODENAME}"* ]]; then
        install_using_apt || use_github="true"
    elif [[ "${POWERSHELL_ARCHIVE_ARCHITECTURES}" = *"${POWERSHELL_ARCHIVE_ARCHITECTURES_ALMALINUX}"* ]]; then 
        install_using_dnf && install_powershell_dnf || use_github="true"
    
    else 
       use_github="true"
    fi

    if [ "${use_github}" = "true" ]; then
        echo "Attempting install from GitHub release..."
        install_using_github
    fi
else
    echo "PowerShell is already installed."
fi

# If PowerShell modules are requested, loop through and install
if [ ${#POWERSHELL_MODULES[@]} -gt 0 ]; then
    echo "Installing PowerShell Modules: ${POWERSHELL_MODULES}"
    modules=(`echo ${POWERSHELL_MODULES} | tr ',' ' '`)
    for i in "${modules[@]}"
    do
        module_parts=(`echo ${i} | tr '==' ' '`)
        module_name="${module_parts[0]}"  
        args="-Name ${module_name} -AllowClobber -Force -Scope AllUsers"  
        if [ "${#module_parts[@]}" -eq 2 ]; then
            module_version="${module_parts[1]}"
            echo "Installing ${module_name} v${module_version}"
            args+=" -RequiredVersion ${module_version}"
        else
            echo "Installing latest version for ${i} module"
        fi

        pwsh -Command "Install-Module $args" || continue
    done
fi


# If URL for powershell profile is provided, download it to '/opt/microsoft/powershell/7/profile.ps1'
if [ -n "$POWERSHELL_PROFILE_URL" ]; then
    echo "Downloading PowerShell Profile from: $POWERSHELL_PROFILE_URL"
    # Get profile path from currently installed pwsh
    profilePath=$(pwsh -noni -c '$PROFILE.AllUsersAllHosts')
    sudo -E curl -sSL -o "$profilePath" "$POWERSHELL_PROFILE_URL"
fi

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"


================================================
FILE: src/powershell/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/python/README.md
================================================

# Python (python)

Installs the provided version of Python, as well as PIPX, and other common Python utilities.  JupyterLab is conditionally installed with the python feature. Note: May require source code compilation.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/python:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select a Python version to install. | string | os-provided |
| installTools | Flag indicating whether or not to install the tools specified via the 'toolsToInstall' option. Default is 'true'. | boolean | true |
| toolsToInstall | Comma-separated list of tools to install when 'installTools' is true. Defaults to a set of common Python tools like pylint. | string | flake8,autopep8,black,yapf,mypy,pydocstyle,pycodestyle,bandit,pipenv,virtualenv,pytest,pylint |
| optimize | Optimize Python for performance when compiled (slow) | boolean | false |
| enableShared | Enable building a shared Python library | boolean | false |
| installPath | The path where python will be installed. | string | /usr/local/python |
| installJupyterlab | Install JupyterLab, a web-based interactive development environment for notebooks | boolean | false |
| configureJupyterlabAllowOrigin | Configure JupyterLab to accept HTTP requests from the specified origin | string | - |
| httpProxy | Connect to GPG keyservers using a proxy for fetching source code signatures by configuring this option | string | - |

## Customizations

### VS Code Extensions

- `ms-python.python`
- `ms-python.vscode-pylance`
- `ms-python.autopep8`



## OS Support

This Feature should work on recent versions of Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, and RockyLinux distributions with the apt, yum, dnf, or microdnf package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/python/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/python/devcontainer-feature.json
================================================
{
  "id": "python",
  "version": "1.7.1",
  "name": "Python",
  "documentationURL": "https://github.com/devcontainers/features/tree/main/src/python",
  "description": "Installs the provided version of Python, as well as PIPX, and other common Python utilities.  JupyterLab is conditionally installed with the python feature. Note: May require source code compilation.",
  "options": {
    "version": {
      "type": "string",
      "proposals": [
        "latest",
        "os-provided",
        "none",
        "3.12",
        "3.11",
        "3.10",
        "3.9",
        "3.8",
        "3.7",
        "3.6"
      ],
      "default": "os-provided",
      "description": "Select a Python version to install."
    },
    "installTools": {
      "type": "boolean",
      "default": true,
      "description": "Flag indicating whether or not to install the tools specified via the 'toolsToInstall' option. Default is 'true'."
    },
    "toolsToInstall": {
      "type": "string",
      "default": "flake8,autopep8,black,yapf,mypy,pydocstyle,pycodestyle,bandit,pipenv,virtualenv,pytest,pylint",
      "description": "Comma-separated list of tools to install when 'installTools' is true. Defaults to a set of common Python tools like pylint."
    },
    "optimize": {
      "type": "boolean",
      "default": false,
      "description": "Optimize Python for performance when compiled (slow)"
    },
    "enableShared": {
      "type": "boolean",
      "default": false,
      "description": "Enable building a shared Python library"
    },
    "installPath": {
      "type": "string",
      "default": "/usr/local/python",
      "description": "The path where python will be installed."
    },
    "installJupyterlab": {
      "type": "boolean",
      "default": false,
      "description": "Install JupyterLab, a web-based interactive development environment for notebooks"
    },
    "configureJupyterlabAllowOrigin": {
      "type": "string",
      "default": "",
      "description": "Configure JupyterLab to accept HTTP requests from the specified origin"
    },
    "httpProxy": {
      "type": "string",
      "default": "",
      "description": "Connect to GPG keyservers using a proxy for fetching source code signatures by configuring this option"
    }
  },
  "containerEnv": {
    "PYTHON_PATH": "/usr/local/python/current",
    "PIPX_HOME": "/usr/local/py-utils",
    "PIPX_BIN_DIR": "/usr/local/py-utils/bin",
    "PATH": "/usr/local/python/current/bin:/usr/local/py-utils/bin:/usr/local/jupyter:${PATH}"
  },
  "customizations": {
    "vscode": {
      "extensions": [
        "ms-python.python",
        "ms-python.vscode-pylance",
        "ms-python.autopep8"
      ],
      "settings": {
        "github.copilot.chat.codeGeneration.instructions": [
          {
            "text": "This dev container includes `python3` and `pip3` pre-installed and available on the `PATH`, along with the Python language extensions for Python development."
          }
        ],
        "python.defaultInterpreterPath": "/usr/local/python/current/bin/python",
        "[python]": {
          "editor.defaultFormatter": "ms-python.autopep8"
        }
      }
    }
  },
  "installsAfter": [
    "ghcr.io/devcontainers/features/common-utils",
    "ghcr.io/devcontainers/features/oryx"
  ]
}


================================================
FILE: src/python/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/python.md
# Maintainer: The VS Code and Codespaces Teams

PYTHON_VERSION="${VERSION:-"latest"}" # 'system' or 'os-provided' checks the base image first, else installs 'latest'
INSTALL_PYTHON_TOOLS="${INSTALLTOOLS:-"true"}"
SKIP_VULNERABILITY_PATCHING="${SKIPVULNERABILITYPATCHING:-"false"}"
OPTIMIZE_BUILD_FROM_SOURCE="${OPTIMIZE:-"false"}"
ENABLE_SHARED_FROM_SOURCE="${ENABLESHARED:-"false"}"
PYTHON_INSTALL_PATH="${INSTALLPATH:-"/usr/local/python"}"
OVERRIDE_DEFAULT_VERSION="${OVERRIDEDEFAULTVERSION:-"true"}"

export PIPX_HOME=${PIPX_HOME:-"/usr/local/py-utils"}

USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="${UPDATE_RC:-"true"}"
USE_ORYX_IF_AVAILABLE="${USEORYXIFAVAILABLE:-"true"}"

INSTALL_JUPYTERLAB="${INSTALLJUPYTERLAB:-"false"}"
CONFIGURE_JUPYTERLAB_ALLOW_ORIGIN="${CONFIGUREJUPYTERLABALLOWORIGIN:-""}"

# Comma-separated list of python versions to be installed
# alongside PYTHON_VERSION, but not set as default.
ADDITIONAL_VERSIONS="${ADDITIONALVERSIONS:-""}"

# Comma-separated list of additional tools to be installed via pipx.
IFS="," read -r -a DEFAULT_UTILS <<< "${TOOLSTOINSTALL:-flake8,autopep8,black,yapf,mypy,pydocstyle,pycodestyle,bandit,pipenv,virtualenv,pytest}"

PYTHON_SOURCE_GPG_KEYS="64E628F8D684696D B26995E310250568 2D347EA6AA65421D FB9921286F5E1540 3A5CA953F73C700D 04C367C218ADD4FF 0EDDC5F26A45C816 6AF053F07D9DC8D2 C9BE28DEE6DF025C 126EB563A74B06BF D9866941EA5BBD71 ED9D77D5 A821E680E5FA6305"

KEYSERVER_PROXY="${HTTPPROXY:-"${HTTP_PROXY:-""}"}"

set -e

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Bring in ID, ID_LIKE, VERSION_ID, VERSION_CODENAME
. /etc/os-release
# Get an adjusted ID independent of distro variants
MAJOR_VERSION_ID=$(echo ${VERSION_ID} | cut -d . -f 1)
if [ "${ID}" = "debian" ] || [ "${ID_LIKE}" = "debian" ]; then
    ADJUSTED_ID="debian"
elif [[ "${ID}" = "rhel" || "${ID}" = "fedora" || "${ID}" = "mariner" || "${ID_LIKE}" = *"rhel"* || "${ID_LIKE}" = *"fedora"* || "${ID_LIKE}" = *"mariner"* ]]; then
    ADJUSTED_ID="rhel"
    if [[ "${ID}" = "rhel" ]] || [[ "${ID}" = *"alma"* ]] || [[ "${ID}" = *"rocky"* ]]; then
        VERSION_CODENAME="rhel${MAJOR_VERSION_ID}"
    else
        VERSION_CODENAME="${ID}${MAJOR_VERSION_ID}"
    fi
else
    echo "Linux distro ${ID} not supported."
    exit 1
fi

if [ "${ADJUSTED_ID}" = "rhel" ] && [ "${VERSION_CODENAME-}" = "centos7" ]; then
    # As of 1 July 2024, mirrorlist.centos.org no longer exists.
    # Update the repo files to reference vault.centos.org.
    sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.repo
    sed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.repo
    sed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo
fi

# To find some devel packages, some rhel need to enable specific extra repos, but not on RedHat ubi images...
INSTALL_CMD_ADDL_REPO=""
if [ ${ADJUSTED_ID} = "rhel" ] && [ ${ID} != "rhel" ]; then
    if [ ${MAJOR_VERSION_ID} = "8" ]; then
        INSTALL_CMD_ADDL_REPOS="--enablerepo powertools"
    elif [ ${MAJOR_VERSION_ID} = "9" ]; then
        INSTALL_CMD_ADDL_REPOS="--enablerepo crb"
    fi
fi

# Setup INSTALL_CMD & PKG_MGR_CMD
if type apt-get > /dev/null 2>&1; then
    PKG_MGR_CMD=apt-get
    INSTALL_CMD="${PKG_MGR_CMD} -y install --no-install-recommends"
elif type microdnf > /dev/null 2>&1; then
    PKG_MGR_CMD=microdnf
    INSTALL_CMD="${PKG_MGR_CMD} ${INSTALL_CMD_ADDL_REPOS} -y install --refresh --best --nodocs --noplugins --setopt=install_weak_deps=0"
elif type dnf > /dev/null 2>&1; then
    PKG_MGR_CMD=dnf
    INSTALL_CMD="${PKG_MGR_CMD} ${INSTALL_CMD_ADDL_REPOS} -y install --refresh --best --nodocs --noplugins --setopt=install_weak_deps=0"
else
    PKG_MGR_CMD=yum
    INSTALL_CMD="${PKG_MGR_CMD} ${INSTALL_CMD_ADDL_REPOS} -y install --noplugins --setopt=install_weak_deps=0"
fi

# Clean up
clean_up() {
    case ${ADJUSTED_ID} in
        debian)
            rm -rf /var/lib/apt/lists/*
            ;;
        rhel)
            rm -rf /var/cache/dnf/* /var/cache/yum/*
            rm -rf /tmp/yum.log
            rm -rf ${GPG_INSTALL_PATH}
            ;;
    esac
}
clean_up



updaterc() {
    local _bashrc
    local _zshrc
    if [ "${UPDATE_RC}" = "true" ]; then
        case $ADJUSTED_ID in
            debian) echo "Updating /etc/bash.bashrc and /etc/zsh/zshrc..."
                _bashrc=/etc/bash.bashrc
                _zshrc=/etc/zsh/zshrc
                ;;
            rhel) echo "Updating /etc/bashrc and /etc/zshrc..."
                _bashrc=/etc/bashrc
                _zshrc=/etc/zshrc
            ;;
        esac
        if [[ "$(cat ${_bashrc})" != *"$1"* ]]; then
            echo -e "$1" >> ${_bashrc}
        fi
        if [ -f "${_zshrc}" ] && [[ "$(cat ${_zshrc})" != *"$1"* ]]; then
            echo -e "$1" >> ${_zshrc}
        fi
    fi
}

# Get the list of GPG key servers that are reachable
get_gpg_key_servers() {
    declare -A keyservers_curl_map=(
        ["hkp://keyserver.ubuntu.com"]="http://keyserver.ubuntu.com:11371"
        ["hkp://keyserver.ubuntu.com:80"]="http://keyserver.ubuntu.com"
        ["hkps://keys.openpgp.org"]="https://keys.openpgp.org"
        ["hkp://keyserver.pgp.com"]="http://keyserver.pgp.com:11371"
    )

    local curl_args=""
    local keyserver_reachable=false  # Flag to indicate if any keyserver is reachable

    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        curl_args="--proxy ${KEYSERVER_PROXY}"
    fi

    for keyserver in "${!keyservers_curl_map[@]}"; do
        local keyserver_curl_url="${keyservers_curl_map[${keyserver}]}"
        if curl -s ${curl_args} --max-time 5 ${keyserver_curl_url} > /dev/null; then
            echo "keyserver ${keyserver}"
            keyserver_reachable=true
        else
            echo "(*) Keyserver ${keyserver} is not reachable." >&2
        fi
    done

    if ! $keyserver_reachable; then
        echo "(!) No keyserver is reachable." >&2
        exit 1
    fi
}

# Import the specified key in a variable name passed in as
receive_gpg_keys() {
    local keys=${!1}
    local keyring_args=""
    local gpg_cmd="gpg"
    if [ ! -z "$2" ]; then
        mkdir -p "$(dirname \"$2\")"
        keyring_args="--no-default-keyring --keyring $2"
    fi
    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        keyring_args="${keyring_args} --keyserver-options http-proxy=${KEYSERVER_PROXY}"
    fi

    # Install curl
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi

    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    echo -e "disable-ipv6\n$(get_gpg_key_servers)" > ${GNUPGHOME}/dirmngr.conf
    # GPG key download sometimes fails for some reason and retrying fixes it.
    local retry_count=0
    local gpg_ok="false"
    set +e
    until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "5" ];
    do
        echo "(*) Downloading GPG key..."
        ( echo "${keys}" | xargs -n 1 gpg -q ${keyring_args} --recv-keys) 2>&1 && gpg_ok="true"
        if [ "${gpg_ok}" != "true" ]; then
            echo "(*) Failed getting key, retrying in 10s..."
            (( retry_count++ ))
            sleep 10s
        fi
    done
    set -e
    if [ "${gpg_ok}" = "false" ]; then
        echo "(!) Failed to get gpg key."
        exit 1
    fi
}
# RHEL7/CentOS7 has an older gpg that does not have dirmngr
# Iterate through keyservers until we have all the keys downloaded
receive_gpg_keys_centos7() {
    local keys=${!1}
    local keyring_args=""
    local gpg_cmd="gpg"
    if [ ! -z "$2" ]; then
        mkdir -p "$(dirname \"$2\")"
        keyring_args="--no-default-keyring --keyring $2"
    fi
    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        keyring_args="${keyring_args} --keyserver-options http-proxy=${KEYSERVER_PROXY}"
    fi

    # Install curl
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi

    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    # GPG key download sometimes fails for some reason and retrying fixes it.
    local retry_count=0
    local gpg_ok="false"
    num_keys=$(echo ${keys} | wc -w)
    set +e
        echo "(*) Downloading GPG keys..."
        until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "5" ]; do
            for keyserver in $(echo "$(get_gpg_key_servers)" | sed 's/keyserver //'); do
                ( echo "${keys}" | xargs -n 1 gpg -q ${keyring_args} --recv-keys --keyserver=${keyserver} ) 2>&1
                downloaded_keys=$(gpg --list-keys | grep ^pub | wc -l)
                if [[ ${num_keys} = ${downloaded_keys} ]]; then
                    gpg_ok="true"
                    break
                fi
            done
            if [ "${gpg_ok}" != "true" ]; then
                echo "(*) Failed getting key, retrying in 10s..."
                (( retry_count++ ))
                sleep 10s
            fi
        done
    set -e
    if [ "${gpg_ok}" = "false" ]; then
        echo "(!) Failed to get gpg key."
        exit 1
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}


# Use Oryx to install something using a partial version match
oryx_install() {
    local platform=$1
    local requested_version=$2
    local target_folder=${3:-none}
    local ldconfig_folder=${4:-none}
    echo "(*) Installing ${platform} ${requested_version} using Oryx..."
    check_packages jq
    # Soft match if full version not specified
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local version_list="$(oryx platforms --json | jq -r ".[] | select(.Name == \"${platform}\") | .Versions | sort | reverse | @tsv" | tr '\t' '\n' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$')"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            requested_version="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            requested_version="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
        if [ -z "${requested_version}" ] || ! echo "${version_list}" | grep "^${requested_version//./\\.}$" > /dev/null 2>&1; then
            echo -e "(!) Oryx does not support ${platform} version $2\nValid values:\n${version_list}" >&2
            return 1
        fi
        echo "(*) Using ${requested_version} in place of $2."
    fi

    export ORYX_ENV_TYPE=vsonline-present ORYX_PREFER_USER_INSTALLED_SDKS=true ENABLE_DYNAMIC_INSTALL=true DYNAMIC_INSTALL_ROOT_DIR=/opt
    oryx prep --skip-detection --platforms-and-versions "${platform}=${requested_version}"
    local opt_folder="/opt/${platform}/${requested_version}"
    if [ "${target_folder}" != "none" ] && [ "${target_folder}" != "${opt_folder}" ]; then
        ln -s "${opt_folder}" "${target_folder}"
    fi
    # Update library path add to conf
    if [ "${ldconfig_folder}" != "none" ]; then
        echo "/opt/${platform}/${requested_version}/lib" >> "/etc/ld.so.conf.d/${platform}.conf"
        ldconfig
    fi
}

pkg_mgr_update() {
    case $ADJUSTED_ID in
        debian)
            if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
                echo "Running apt-get update..."
                ${PKG_MGR_CMD} update -y
            fi
            ;;
        rhel)
            if [ ${PKG_MGR_CMD} = "microdnf" ]; then
                if [ "$(ls /var/cache/yum/* 2>/dev/null | wc -l)" = 0 ]; then
                    echo "Running ${PKG_MGR_CMD} makecache ..."
                    ${PKG_MGR_CMD} makecache
                fi
            else
                if [ "$(ls /var/cache/${PKG_MGR_CMD}/* 2>/dev/null | wc -l)" = 0 ]; then
                    echo "Running ${PKG_MGR_CMD} check-update ..."
                    set +e
                    ${PKG_MGR_CMD} check-update
                    rc=$?
                    if [ $rc != 0 ] && [ $rc != 100 ]; then
                        exit 1
                    fi
                    set -e
                fi
            fi
            ;;
    esac
}

# Checks if packages are installed and installs them if not
check_packages() {
    case ${ADJUSTED_ID} in
        debian)
            if ! dpkg -s "$@" > /dev/null 2>&1; then
                pkg_mgr_update
                ${INSTALL_CMD} "$@"
            fi
            ;;
        rhel)
            if ! rpm -q "$@" > /dev/null 2>&1; then
                pkg_mgr_update
                ${INSTALL_CMD} "$@"
            fi
            ;;
    esac
}

add_symlink() {
    if [[ ! -d "${CURRENT_PATH}" ]]; then
        ln -s -r "${INSTALL_PATH}" "${CURRENT_PATH}"
    fi

    if [ "${OVERRIDE_DEFAULT_VERSION}" = "true" ]; then
        if [[ $(ls -l ${CURRENT_PATH}) != *"-> ${INSTALL_PATH}"* ]] ; then
            rm "${CURRENT_PATH}"
            ln -s -r "${INSTALL_PATH}" "${CURRENT_PATH}"
        fi
    fi
}

install_openssl3() {
    mkdir /tmp/openssl3
    (
        cd /tmp/openssl3
        openssl3_version="3.0"
        # Find version using soft match
        find_version_from_git_tags openssl3_version "https://github.com/openssl/openssl" "openssl-"
        local tgz_filename="openssl-${openssl3_version}.tar.gz"
        local tgz_url="https://github.com/openssl/openssl/releases/download/openssl-${openssl3_version}/${tgz_filename}"
        echo "Downloading ${tgz_filename}..."
        curl -sSL -o "/tmp/openssl3/${tgz_filename}" "${tgz_url}"
        tar xzf ${tgz_filename}
        cd openssl-${openssl3_version}
        ./config --libdir=lib
        make -j $(nproc)
        make install_dev
    )
    rm -rf /tmp/openssl3
}

install_prev_vers_cpython() {
    VERSION=$1
    echo -e "\n(!) Failed to fetch the latest artifacts for cpython ${VERSION}..."
    find_prev_version_from_git_tags VERSION https://github.com/python/cpython
    echo -e "\nAttempting to install ${VERSION}"
    install_cpython "${VERSION}"
}

install_cpython() {
    VERSION=$1
    INSTALL_PATH="${PYTHON_INSTALL_PATH}/${VERSION}"

    # Check if the specified Python version is already installed
    if [ -d "${INSTALL_PATH}" ]; then
        echo "(!) Python version ${VERSION} already exists."
    else
        mkdir -p /tmp/python-src ${INSTALL_PATH}
        cd /tmp/python-src
        cpython_tgz_filename="Python-${VERSION}.tgz"
        cpython_tgz_url="https://www.python.org/ftp/python/${VERSION}/${cpython_tgz_filename}"
        echo "Downloading ${cpython_tgz_filename}..."
        curl -sSL -o "/tmp/python-src/${cpython_tgz_filename}" "${cpython_tgz_url}"
    fi
}

install_from_source() {
    VERSION=$1
    echo "(*) Building Python ${VERSION} from source..."
    if ! type git > /dev/null 2>&1; then
        check_packages git
    fi

    # Find version using soft match
    find_version_from_git_tags VERSION "https://github.com/python/cpython"

    # Some platforms/os versions need modern versions of openssl installed
    # via common package repositories, for now rhel-7 family, use case statement to
    # make it easy to expand
    SSL_INSTALL_PATH="/usr/local"
    case ${VERSION_CODENAME} in
        centos7|rhel7)
            check_packages perl-IPC-Cmd
            install_openssl3
            ADDL_CONFIG_ARGS="--with-openssl=${SSL_INSTALL_PATH} --with-openssl-rpath=${SSL_INSTALL_PATH}/lib"
            ;;
    esac

    install_cpython "${VERSION}"
    if [ -f "/tmp/python-src/${cpython_tgz_filename}" ]; then
        if grep -q "404 Not Found" "/tmp/python-src/${cpython_tgz_filename}"; then
            install_prev_vers_cpython "${VERSION}"
        fi
    fi;
    # Verify signature
    if [[ ${VERSION_CODENAME} = "centos7" ]] || [[ ${VERSION_CODENAME} = "rhel7" ]]; then
        receive_gpg_keys_centos7 PYTHON_SOURCE_GPG_KEYS
    else
        receive_gpg_keys PYTHON_SOURCE_GPG_KEYS
    fi
    echo "Downloading ${cpython_tgz_filename}.asc..."
    curl -sSL -o "/tmp/python-src/${cpython_tgz_filename}.asc" "${cpython_tgz_url}.asc"
    gpg --verify "${cpython_tgz_filename}.asc"

    # Update min protocol for testing only - https://bugs.python.org/issue41561
    if [ -f /etc/pki/tls/openssl.cnf ]; then
        cp /etc/pki/tls/openssl.cnf /tmp/python-src/
    else
        cp /etc/ssl/openssl.cnf /tmp/python-src/
    fi
    sed -i -E 's/MinProtocol[=\ ]+.*/MinProtocol = TLSv1.0/g' /tmp/python-src/openssl.cnf
    export OPENSSL_CONF=/tmp/python-src/openssl.cnf

    # Untar and build
    tar -xzf "/tmp/python-src/${cpython_tgz_filename}" -C "/tmp/python-src" --strip-components=1
    local config_args=""
    if [ "${OPTIMIZE_BUILD_FROM_SOURCE}" = "true" ]; then
        config_args="${config_args} --enable-optimizations"
    fi
    if [ "${ENABLESHARED}" = "true" ]; then
        config_args=" ${config_args} --enable-shared"
        # need double-$: LDFLAGS ends up in Makefile $$ becomes $ when evaluated.
        # backslash needed for shell that Make calls escape the $.
        export LDFLAGS="${LDFLAGS} -Wl,-rpath="'\$$ORIGIN'"/../lib"
    fi
    if [ -n "${ADDL_CONFIG_ARGS}" ]; then
        config_args="${config_args} ${ADDL_CONFIG_ARGS}"
    fi
    ./configure --prefix="${INSTALL_PATH}" --with-ensurepip=install ${config_args}
    make -j 8
    make install

    cd /tmp
    rm -rf /tmp/python-src ${GNUPGHOME} /tmp/vscdc-settings.env

    ln -s "${INSTALL_PATH}/bin/python3" "${INSTALL_PATH}/bin/python"
    ln -s "${INSTALL_PATH}/bin/pip3" "${INSTALL_PATH}/bin/pip"
    ln -s "${INSTALL_PATH}/bin/idle3" "${INSTALL_PATH}/bin/idle"
    ln -s "${INSTALL_PATH}/bin/pydoc3" "${INSTALL_PATH}/bin/pydoc"
    ln -s "${INSTALL_PATH}/bin/python3-config" "${INSTALL_PATH}/bin/python-config"

    add_symlink

}

install_using_oryx() {
    VERSION=$1
    INSTALL_PATH="${PYTHON_INSTALL_PATH}/${VERSION}"

    # Check if the specified Python version is already installed
    if [ -d "${INSTALL_PATH}" ]; then
        echo "(!) Python version ${VERSION} already exists."
    else
        # The python install root path may not exist, so create it
        mkdir -p "${PYTHON_INSTALL_PATH}"
        oryx_install "python" "${VERSION}" "${INSTALL_PATH}" "lib" || return 1

        ln -s "${INSTALL_PATH}/bin/idle3" "${INSTALL_PATH}/bin/idle"
        ln -s "${INSTALL_PATH}/bin/pydoc3" "${INSTALL_PATH}/bin/pydoc"
        ln -s "${INSTALL_PATH}/bin/python3-config" "${INSTALL_PATH}/bin/python-config"

        add_symlink
    fi
}

sudo_if() {
    COMMAND="$*"
    if [ "$(id -u)" -eq 0 ] && [ "$USERNAME" != "root" ]; then
        su - "$USERNAME" -c "$COMMAND"
    else
        $COMMAND
    fi
}

install_user_package() {
    INSTALL_UNDER_ROOT="$1"
    PACKAGE="$2"

    if [ "$INSTALL_UNDER_ROOT" = true ]; then
        sudo_if "${PYTHON_SRC}" -m pip install --upgrade --no-cache-dir "$PACKAGE"
    else
        sudo_if "${PYTHON_SRC}" -m pip install --user --upgrade --no-cache-dir "$PACKAGE"
    fi
}

add_user_jupyter_config() {
    CONFIG_DIR="$1"
    CONFIG_FILE="$2"

    # Make sure the config file exists or create it with proper permissions
    test -d "$CONFIG_DIR" || sudo_if mkdir "$CONFIG_DIR"
    test -f "$CONFIG_FILE" || sudo_if touch "$CONFIG_FILE"

    # Don't write the same config more than once
    grep -q "$3" "$CONFIG_FILE" || echo "$3" >> "$CONFIG_FILE"
}

install_python() {
    version=$1
    # If the os-provided versions are "good enough", detect that and bail out.
    if [ ${version} = "os-provided" ] || [ ${version} = "system" ]; then
        if [ ${ADJUSTED_ID} = "debian" ]; then
            check_packages python3 python3-doc python3-pip python3-venv python3-dev python3-tk
        else
            if [ ${ID} != "mariner" ]; then
                check_packages python3 python3-pip python3-devel python3-tkinter
            else
                check_packages python3 python3-pip python3-devel
            fi
        fi
        INSTALL_PATH="/usr"

        local current_bin_path="${CURRENT_PATH}/bin"
        if [ "${OVERRIDE_DEFAULT_VERSION}" = "true" ]; then
            rm -rf "${current_bin_path}"
        fi
        if [ ! -d "${current_bin_path}" ] ; then
            mkdir -p "${current_bin_path}"
            # Add an interpreter symlink but point it to "/usr" since python is at /usr/bin/python, add other alises
            ln -s "${INSTALL_PATH}/bin/python3" "${current_bin_path}/python3"
            ln -s "${INSTALL_PATH}/bin/python3" "${current_bin_path}/python"
            ln -s "${INSTALL_PATH}/bin/pydoc3" "${current_bin_path}/pydoc3"
            ln -s "${INSTALL_PATH}/bin/pydoc3" "${current_bin_path}/pydoc"
            ln -s "${INSTALL_PATH}/bin/python3-config" "${current_bin_path}/python3-config"
            ln -s "${INSTALL_PATH}/bin/python3-config" "${current_bin_path}/python-config"
        fi

        should_install_from_source=false
    elif [ ${ADJUSTED_ID} = "debian" ] && [ "$(dpkg --print-architecture)" = "amd64" ] && [ "${USE_ORYX_IF_AVAILABLE}" = "true" ] && type oryx > /dev/null 2>&1; then
        install_using_oryx $version || should_install_from_source=true
    else
        should_install_from_source=true
    fi
    if [ "${should_install_from_source}" = "true" ]; then
        install_from_source $version
    fi
}

python_is_externally_managed() {
    local _python_cmd=$1
    local python_stdlib_dir=$(
        ${_python_cmd} -c '
import sys
import sysconfig
sys.prefix == sys.base_prefix and print(sysconfig.get_path("stdlib", sysconfig.get_default_scheme()))'
    )
    if [ -f ${python_stdlib_dir}/EXTERNALLY-MANAGED ]; then
        return 0
    else
        return 1
    fi
}

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# Some distributions do not install awk by default (e.g. Mariner)
if ! type awk >/dev/null 2>&1; then
    check_packages awk
fi

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive

# General requirements

REQUIRED_PKGS=""
case ${ADJUSTED_ID} in
    debian)
        REQUIRED_PKGS="${REQUIRED_PKGS} \
            ca-certificates \
            curl \
            dirmngr \
            gcc \
            gnupg2 \
            libbz2-dev \
            libffi-dev \
            libgdbm-dev \
            liblzma-dev \
            libncurses5-dev \
            libreadline-dev \
            libsqlite3-dev \
            libssl-dev \
            libxml2-dev \
            libxmlsec1-dev \
            make \
            tar \
            tk-dev \
            uuid-dev \
            xz-utils \
            zlib1g-dev"
        ;;
    rhel)
        REQUIRED_PKGS="${REQUIRED_PKGS} \
            bzip2-devel \
            ca-certificates \
            findutils \
            gcc \
            gnupg2 \
            libffi-devel \
            libxml2-devel \
            make \
            ncurses-devel \
            openssl-devel \
            shadow-utils \
            sqlite-devel \
            tar \
            which \
            xz-devel \
            xz \
            zlib-devel"
        if ! type curl >/dev/null 2>&1; then
            REQUIRED_PKGS="${REQUIRED_PKGS} \
                curl"
        fi
        # Mariner does not have tk-devel package available, RedHat ubi8 and ubi9 do not have tk-devel
        if [ ${ID} != "mariner" ] && [ ${ID} != "rhel" ]; then
            REQUIRED_PKGS="${REQUIRED_PKGS} \
                tk-devel"
        fi
        # Redhat ubi8 and ubi9 do not have some packages by default, only add them
        # if we're not on RedHat ...
        if [ ${ID} != "rhel" ]; then
            REQUIRED_PKGS="${REQUIRED_PKGS} \
                gdbm-devel \
                readline-devel \
                uuid-devel \
                xmlsec1-devel"
        fi
        ;;
esac

check_packages ${REQUIRED_PKGS}

# Function to get the major version from a SemVer string
get_major_version() {
    local version="$1"
    echo "$version" | cut -d '.' -f 1
}

# Install Python from source if needed
if [ "${PYTHON_VERSION}" != "none" ]; then
    if ! cat /etc/group | grep -e "^python:" > /dev/null 2>&1; then
        groupadd -r python
    fi
    usermod -a -G python "${USERNAME}"
    CURRENT_PATH="${PYTHON_INSTALL_PATH}/current"
    install_python ${PYTHON_VERSION}

    # Additional python versions to be installed but not be set as default.
    if [ ! -z "${ADDITIONAL_VERSIONS}" ]; then
        OLD_INSTALL_PATH="${INSTALL_PATH}"
        OLDIFS=$IFS
        IFS=","
            read -a additional_versions <<< "$ADDITIONAL_VERSIONS"
            major_version=$(get_major_version ${VERSION})
            if type apt-get > /dev/null 2>&1; then
                # Debian/Ubuntu: Use update-alternatives
                update-alternatives --install ${CURRENT_PATH} python${major_version} ${PYTHON_INSTALL_PATH}/${VERSION} $((${#additional_versions[@]}+1))
                update-alternatives --set python${major_version} ${PYTHON_INSTALL_PATH}/${VERSION}
            elif type dnf > /dev/null 2>&1 || type yum > /dev/null 2>&1 || type microdnf > /dev/null 2>&1; then
                # Fedora/RHEL/CentOS: Use alternatives
                alternatives --install ${CURRENT_PATH} python${major_version} ${PYTHON_INSTALL_PATH}/${VERSION} $((${#additional_versions[@]}+1))
                alternatives --set python${major_version} ${PYTHON_INSTALL_PATH}/${VERSION}
            fi
            for i in "${!additional_versions[@]}"; do
                version=${additional_versions[$i]}
                OVERRIDE_DEFAULT_VERSION="false"
                install_python $version
                if type apt-get > /dev/null 2>&1; then
                    # Debian/Ubuntu: Use update-alternatives
                    update-alternatives --install ${CURRENT_PATH} python${major_version} ${PYTHON_INSTALL_PATH}/${VERSION} $((${i}+1))
                elif type dnf > /dev/null 2>&1 || type yum > /dev/null 2>&1 || type microdnf > /dev/null 2>&1; then
                    # Fedora/RHEL/CentOS: Use alternatives
                    alternatives --install ${CURRENT_PATH} python${major_version} ${PYTHON_INSTALL_PATH}/${VERSION} $((${i}+1))
                fi
            done
        INSTALL_PATH="${OLD_INSTALL_PATH}"
        IFS=$OLDIFS
    fi

    if [ ${PYTHON_VERSION} != "os-provided" ] && [ ${PYTHON_VERSION} != "system" ]; then
        updaterc "if [[ \"\${PATH}\" != *\"${CURRENT_PATH}/bin\"* ]]; then export PATH=${CURRENT_PATH}/bin:\${PATH}; fi"
        PATH="${INSTALL_PATH}/bin:${PATH}"
    fi

    # Updates the symlinks for os-provided, or the installed python version in other cases
    chown -R "${USERNAME}:python" "${PYTHON_INSTALL_PATH}"
    chmod -R g+r+w "${PYTHON_INSTALL_PATH}"
    find "${PYTHON_INSTALL_PATH}" -type d -print0 | xargs -0 -n 1 chmod g+s

    PYTHON_SRC="${INSTALL_PATH}/bin/python3"
    if ! type pip >/dev/null 2>&1 && type pip3 >/dev/null 2>&1; then
        ln -s /usr/bin/pip3 /usr/bin/pip
    fi
else
    PYTHON_SRC=$(which python)
fi

# Install Python tools if needed
if [[ "${INSTALL_PYTHON_TOOLS}" = "true" ]] && [[ -n "${PYTHON_SRC}" ]]; then
    echo 'Installing Python tools...'
    export PIPX_BIN_DIR="${PIPX_HOME}/bin"
    PATH="${PATH}:${PIPX_BIN_DIR}"

    # Create pipx group, dir, and set sticky bit
    if ! cat /etc/group | grep -e "^pipx:" > /dev/null 2>&1; then
        groupadd -r pipx
    fi
    usermod -a -G pipx ${USERNAME}
    umask 0002
    mkdir -p ${PIPX_BIN_DIR}
    chown -R "${USERNAME}:pipx" ${PIPX_HOME}
    chmod -R g+r+w "${PIPX_HOME}"
    find "${PIPX_HOME}" -type d -print0 | xargs -0 -n 1 chmod g+s

    # Update pip if not using os provided python
    if [[ -n "${PYTHON_SRC}" ]] && [[ ${PYTHON_VERSION} != "os-provided" ]] && [[ ${PYTHON_VERSION} != "system" ]] && [[ ${PYTHON_VERSION} != "none" ]]; then
        echo "Updating pip..."
        ${PYTHON_SRC} -m pip install --no-cache-dir --upgrade pip
    fi

    # Install tools
    export PYTHONUSERBASE=/tmp/pip-tmp
    export PIP_CACHE_DIR=/tmp/pip-tmp/cache
    PIPX_DIR=""
    if ! type pipx > /dev/null 2>&1; then
        if python_is_externally_managed ${PYTHON_SRC}; then
            check_packages pipx
        else
            pip3 install --disable-pip-version-check --no-cache-dir --user pipx 2>&1
            /tmp/pip-tmp/bin/pipx install --pip-args=--no-cache-dir pipx
            PIPX_DIR="/tmp/pip-tmp/bin/"
        fi
    fi
    for util in "${DEFAULT_UTILS[@]}"; do
        if ! type ${util} > /dev/null 2>&1; then
            "${PIPX_DIR}pipx" install --system-site-packages --pip-args '--no-cache-dir --force-reinstall' ${util}
        else
            echo "${util} already installed. Skipping."
        fi
    done

    # Temporary: Removes â€œsetup toolsâ€ metadata directory due to https://github.com/advisories/GHSA-r9hx-vwmv-q579
    if [[ $SKIP_VULNERABILITY_PATCHING = "false" ]]; then
        VULNERABLE_VERSIONS=("3.10" "3.11")
        RUN_TIME_PY_VER_DETECT=$(${PYTHON_SRC} --version 2>&1)
        PY_MAJOR_MINOR_VER=${RUN_TIME_PY_VER_DETECT:7:4};
        if [[ ${VULNERABLE_VERSIONS[*]} =~ $PY_MAJOR_MINOR_VER ]]; then
            rm -rf  ${PIPX_HOME}/shared/lib/"python${PY_MAJOR_MINOR_VER}"/site-packages/setuptools-65.5.0.dist-info
            if [[ -e "/usr/local/lib/python${PY_MAJOR_MINOR_VER}/ensurepip/_bundled/setuptools-65.5.0-py3-none-any.whl" ]]; then
                # remove the vulnerable setuptools-65.5.0-py3-none-any.whl file
                rm /usr/local/lib/python${PY_MAJOR_MINOR_VER}/ensurepip/_bundled/setuptools-65.5.0-py3-none-any.whl
                # create and change to the setuptools_downloaded directory
                mkdir -p /tmp/setuptools_downloaded
                cd /tmp/setuptools_downloaded
                # download the source distribution for setuptools using pip
                pip download setuptools==65.5.1 --no-binary :all:
                # extract the filename of the setuptools-*.tar.gz file
                filename=$(find . -maxdepth 1 -type f)
                # create a directory to store unpacked contents of the source distribution
                mkdir -p /tmp/setuptools_src_dist
                # extract the contents inside the new directory
                tar -xzf $filename -C /tmp/setuptools_src_dist
                # move to the setuptools-* directory inside /setuptools_src_dist
                cd /tmp/setuptools_src_dist/setuptools-65.5.1/
                # look for setup.py file in the current directory and create a wheel file
                python setup.py bdist_wheel
                # move inside the dist directory in pwd
                cd dist
                # copy this file to the ensurepip/_bundled directory
                cp setuptools-65.5.1-py3-none-any.whl /usr/local/lib/python${PY_MAJOR_MINOR_VER}/ensurepip/_bundled/
                # replace the version in __init__.py file with the installed version
                sed -i 's/_SETUPTOOLS_VERSION = \"65\.5\.0\"/_SETUPTOOLS_VERSION = "65.5.1"/g' /usr/local/lib/"python${PY_MAJOR_MINOR_VER}"/ensurepip/__init__.py
                # cleanup created dir's
                rm -rf /tmp/setuptools_downloaded /tmp/setuptools_src_dist
            fi
        fi
    fi

    rm -rf /tmp/pip-tmp

    updaterc "export PIPX_HOME=\"${PIPX_HOME}\""
    updaterc "export PIPX_BIN_DIR=\"${PIPX_BIN_DIR}\""
    updaterc "if [[ \"\${PATH}\" != *\"\${PIPX_BIN_DIR}\"* ]]; then export PATH=\"\${PATH}:\${PIPX_BIN_DIR}\"; fi"
fi

# Install JupyterLab if needed
if [ "${INSTALL_JUPYTERLAB}" = "true" ]; then
    if [ -z "${PYTHON_SRC}" ]; then
        echo "(!) Could not install Jupyterlab. Python not found."
        exit 1
    fi

    INSTALL_UNDER_ROOT=true
    if [ "$(id -u)" -eq 0 ] && [ "$USERNAME" != "root" ]; then
        INSTALL_UNDER_ROOT=false
    fi

    install_user_package $INSTALL_UNDER_ROOT jupyterlab
    install_user_package $INSTALL_UNDER_ROOT jupyterlab-git

    # Create a symlink to the JupyterLab binary for non root users
    if [ "$INSTALL_UNDER_ROOT" = false ]; then
        JUPYTER_INPATH=/home/${USERNAME}/.local/bin
        if [ ! -d "$JUPYTER_INPATH" ]; then
            echo "Error: $JUPYTER_INPATH does not exist."
            exit 1
        fi
        JUPYTER_PATH=/usr/local/jupyter
        ln -s "$JUPYTER_INPATH" "$JUPYTER_PATH"
    fi

    # Configure JupyterLab if needed
    if [ -n "${CONFIGURE_JUPYTERLAB_ALLOW_ORIGIN}" ]; then
        # Resolve config directory
        CONFIG_DIR="/root/.jupyter"
        if [ "$INSTALL_UNDER_ROOT" = false ]; then
            CONFIG_DIR="/home/$USERNAME/.jupyter"
        fi

        CONFIG_FILE="$CONFIG_DIR/jupyter_server_config.py"

        add_user_jupyter_config $CONFIG_DIR $CONFIG_FILE "c.ServerApp.allow_origin = '${CONFIGURE_JUPYTERLAB_ALLOW_ORIGIN}'"
        add_user_jupyter_config $CONFIG_DIR $CONFIG_FILE "c.NotebookApp.allow_origin = '${CONFIGURE_JUPYTERLAB_ALLOW_ORIGIN}'"
    fi
fi

# Clean up
clean_up

echo "Done!"



================================================
FILE: src/python/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, and RockyLinux distributions with the apt, yum, dnf, or microdnf package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/ruby/README.md
================================================

# Ruby (via rvm) (ruby)

Installs Ruby, rvm, rbenv, common Ruby utilities, and needed dependencies.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/ruby:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a Ruby version to install | string | latest |

## Customizations

### VS Code Extensions

- `shopify.ruby-lsp`



## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/ruby/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/ruby/devcontainer-feature.json
================================================
{
    "id": "ruby",
    "version": "1.3.2",
    "name": "Ruby (via rvm)",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/ruby",
    "description": "Installs Ruby, rvm, rbenv, common Ruby utilities, and needed dependencies.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "none",
                "3.4",
                "3.2"
            ],
            "default": "latest",
            "description": "Select or enter a Ruby version to install"
        }
    },
    "customizations": {
        "vscode": {
            "extensions": [
                "shopify.ruby-lsp"
            ],
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes Ruby, rvm, rbenv, common Ruby utilities, and needed dependencies pre-installed and available on the `PATH`, along with the Ruby language extension for Ruby development."
                    }
                ]
            }
        }
    },
    "containerEnv": {
        "GEM_PATH": "/usr/local/rvm/gems/default:/usr/local/rvm/gems/default@global",
        "GEM_HOME": "/usr/local/rvm/gems/default",
        "MY_RUBY_HOME": "/usr/local/rvm/rubies/default",
        "PATH": "/usr/local/rvm/gems/default/bin:/usr/local/rvm/gems/default@global/bin:/usr/local/rvm/rubies/default/bin:/usr/local/share/rbenv/bin:${PATH}"
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/ruby/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/ruby.md
# Maintainer: The VS Code and Codespaces Teams

RUBY_VERSION="${VERSION:-"latest"}"

USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="${UPDATE_RC:-"true"}"
INSTALL_RUBY_TOOLS="${INSTALL_RUBY_TOOLS:-"true"}"

# Comma-separated list of ruby versions to be installed (with rvm)
# alongside RUBY_VERSION, but not set as default.
ADDITIONAL_VERSIONS="${ADDITIONALVERSIONS:-""}"

# Note: ruby-debug-ide will install the right version of debase if missing and
# installing debase directly fails on Ruby 3.1.0 as of 1/7/2022, so omitting.
# installing ruby-debug-ide on debian fails, so omitting.
DEFAULT_GEMS="rake"

RVM_GPG_KEYS="409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB"

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

updaterc() {
    if [ "${UPDATE_RC}" = "true" ]; then
        echo "Updating /etc/bash.bashrc and /etc/zsh/zshrc..."
        if [[ "$(cat /etc/bash.bashrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/bash.bashrc
        fi
        if [ -f "/etc/zsh/zshrc" ] && [[ "$(cat /etc/zsh/zshrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/zsh/zshrc
        fi
    fi
}

# Get the list of GPG key servers that are reachable
get_gpg_key_servers() {
    declare -A keyservers_curl_map=(
        ["hkp://keyserver.ubuntu.com"]="http://keyserver.ubuntu.com:11371"
        ["hkp://keyserver.ubuntu.com:80"]="http://keyserver.ubuntu.com"
        ["hkps://keys.openpgp.org"]="https://keys.openpgp.org"
        ["hkp://keyserver.pgp.com"]="http://keyserver.pgp.com:11371"
    )

    local curl_args=""
    local keyserver_reachable=false  # Flag to indicate if any keyserver is reachable

    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        curl_args="--proxy ${KEYSERVER_PROXY}"
    fi

    for keyserver in "${!keyservers_curl_map[@]}"; do
        local keyserver_curl_url="${keyservers_curl_map[${keyserver}]}"
        if curl -s ${curl_args} --max-time 5 ${keyserver_curl_url} > /dev/null; then
            echo "keyserver ${keyserver}"
            keyserver_reachable=true
        else
            echo "(*) Keyserver ${keyserver} is not reachable." >&2
        fi
    done

    if ! $keyserver_reachable; then
        echo "(!) No keyserver is reachable." >&2
        exit 1
    fi
}

# Import the specified key in a variable name passed in as 
receive_gpg_keys() {
    local keys=${!1}
    local keyring_args=""
    if [ ! -z "$2" ]; then
        keyring_args="--no-default-keyring --keyring \"$2\""
    fi

    # Install curl
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi

    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    echo -e "disable-ipv6\n$(get_gpg_key_servers)" > ${GNUPGHOME}/dirmngr.conf
    # GPG key download sometimes fails for some reason and retrying fixes it.
    local retry_count=0
    local gpg_ok="false"
    set +e
    until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "5" ]; 
    do
        echo "(*) Downloading GPG key..."
        ( echo "${keys}" | xargs -n 1 gpg -q ${keyring_args} --recv-keys) 2>&1 && gpg_ok="true"
        if [ "${gpg_ok}" != "true" ]; then
            echo "(*) Failed getting key, retrying in 10s..."
            (( retry_count++ ))
            sleep 10s
        fi
    done
    set -e
    if [ "${gpg_ok}" = "false" ]; then
        echo "(!) Failed to get gpg key."
        exit 1
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive

architecture="$(uname -m)"
if [ "${architecture}" != "amd64" ] && [ "${architecture}" != "x86_64" ] && [ "${architecture}" != "arm64" ] && [ "${architecture}" != "aarch64" ]; then
    echo "(!) Architecture $architecture unsupported"
    exit 1
fi

# Install dependencies
# Removed software-properties-common package from here as it has been removed for debian trixie(13)
check_packages curl ca-certificates build-essential gnupg2 libreadline-dev \
    procps dirmngr gawk autoconf automake bison libffi-dev libgdbm-dev libncurses5-dev \
    libsqlite3-dev libtool libyaml-dev pkg-config sqlite3 zlib1g-dev libgmp-dev libssl-dev
if ! type git > /dev/null 2>&1; then
    check_packages git
fi

# Conditionally install software-properties-common (skip on Debian Trixie)
if type apt-get >/dev/null 2>&1; then
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        if [ "${ID}" = "debian" ] && [ "${VERSION_CODENAME}" = "trixie" ]; then
            echo "Skipping software-properties-common on Debian Trixie."
        else
            check_packages software-properties-common
        fi
    else
        # Fallback for apt-based systems without /etc/os-release
        check_packages software-properties-common
    fi
fi

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    variable_name=$3
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");

    #install jq
    check_packages jq

    message=$(echo "$output" | jq -r '.message')

    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v" "_"
        declare -g ${variable_name}="${prev_version}"
    else 
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name' | tr '_' '.')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}


# Figure out correct version of a three part version number is not passed
RUBY_URL="https://github.com/ruby/ruby"
ORIGINAL_RUBY_VERSION=$RUBY_VERSION
find_version_from_git_tags RUBY_VERSION $RUBY_URL "tags/v" "_"

set_rvm_install_args() {
    RUBY_VERSION=$1
    if [ "${RUBY_VERSION}" = "none" ]; then
        RVM_INSTALL_ARGS=""
    elif [[ "$(ruby -v)" = *"${RUBY_VERSION}"* ]]; then
        echo "(!) Ruby is already installed with version ${RUBY_VERSION}. Skipping..."
        RVM_INSTALL_ARGS=""
    else
        if [ "${RUBY_VERSION}" = "latest" ] || [ "${RUBY_VERSION}" = "current" ] || [ "${RUBY_VERSION}" = "lts" ]; then
            RVM_INSTALL_ARGS="--ruby"
            RUBY_VERSION=""
        else
            RVM_INSTALL_ARGS="--ruby=${RUBY_VERSION}"
        fi
        if [ "${INSTALL_RUBY_TOOLS}" = "true" ]; then
            SKIP_GEM_INSTALL="true"
        else 
            DEFAULT_GEMS=""
        fi
    fi
}

install_previous_version() {
    if [[ $ORIGINAL_RUBY_VERSION == "latest" ]]; then
        repo_url=$(get_github_api_repo_url "$RUBY_URL")
        get_previous_version "${RUBY_URL}" "${repo_url}" RUBY_VERSION
        set_rvm_install_args $RUBY_VERSION
        curl -sSL https://get.rvm.io | bash -s stable --ignore-dotfiles ${RVM_INSTALL_ARGS} --with-default-gems="${DEFAULT_GEMS}" 2>&1
    else 
        echo "Failed to install Ruby version $ORIGINAL_RUBY_VERSION. Exiting..."
    fi
}

# Just install Ruby if RVM already installed
if rvm --version > /dev/null; then
    echo "Ruby Version Manager already exists."
    if [[ "$(ruby -v)" = *"${RUBY_VERSION}"* ]]; then
        echo "(!) Ruby is already installed with version ${RUBY_VERSION}. Skipping..."
    elif [ "${RUBY_VERSION}" != "none" ]; then
        echo "Installing specified Ruby version."
        su ${USERNAME} -c "rvm install ruby ${RUBY_VERSION}"
    fi
    SKIP_GEM_INSTALL="false"
    SKIP_RBENV_RBUILD="true"
else
    # Install RVM
    receive_gpg_keys RVM_GPG_KEYS
    # Determine appropriate settings for rvm installer
    set_rvm_install_args $RUBY_VERSION
    # Create rvm group as a system group to reduce the odds of conflict with local user UIDs
    if ! cat /etc/group | grep -e "^rvm:" > /dev/null 2>&1; then
        groupadd -r rvm
    fi
    # Install rvm
    curl -sSL https://get.rvm.io | bash -s stable --ignore-dotfiles ${RVM_INSTALL_ARGS} --with-default-gems="${DEFAULT_GEMS}" 2>&1 || install_previous_version
    usermod -aG rvm ${USERNAME}
    source /usr/local/rvm/scripts/rvm
    rvm fix-permissions system
    rm -rf ${GNUPGHOME}
fi

if [ "${INSTALL_RUBY_TOOLS}" = "true" ]; then   
    # Non-root user may not have "gem" in path when script is run and no ruby version
    # is installed by rvm, so handle this by using root's default gem in this case
    ROOT_GEM="$(which gem || echo "")"
    ${ROOT_GEM} install ${DEFAULT_GEMS}
fi

# VS Code server usually first in the path, so silence annoying rvm warning (that does not apply) and then source it
updaterc "if ! grep rvm_silence_path_mismatch_check_flag \$HOME/.rvmrc > /dev/null 2>&1; then echo 'rvm_silence_path_mismatch_check_flag=1' >> \$HOME/.rvmrc; fi\nsource /usr/local/rvm/scripts/rvm > /dev/null 2>&1"

# Additional ruby versions to be installed but not be set as default.
if [ ! -z "${ADDITIONAL_VERSIONS}" ]; then
    OLDIFS=$IFS
    IFS=","
        read -a additional_versions <<< "$ADDITIONAL_VERSIONS"
        for version in "${additional_versions[@]}"; do
            # Figure out correct version of a three part version number is not passed
            find_version_from_git_tags version $RUBY_URL "tags/v" "_"
            source /usr/local/rvm/scripts/rvm
            rvm install ruby ${version}
        done
    IFS=$OLDIFS
fi

# Install rbenv/ruby-build for good measure
if [ "${SKIP_RBENV_RBUILD}" != "true" ]; then

    if [[ ! -d "/usr/local/share/rbenv" ]]; then
        git clone --depth=1 \
            -c core.eol=lf \
            -c core.autocrlf=false \
            -c fsck.zeroPaddedFilemode=ignore \
            -c fetch.fsck.zeroPaddedFilemode=ignore \
            -c receive.fsck.zeroPaddedFilemode=ignore \
            https://github.com/rbenv/rbenv.git /usr/local/share/rbenv
    fi

    if [[ ! -d "/usr/local/share/ruby-build" ]]; then
        git clone --depth=1 \
            -c core.eol=lf \
            -c core.autocrlf=false \
            -c fsck.zeroPaddedFilemode=ignore \
            -c fetch.fsck.zeroPaddedFilemode=ignore \
            -c receive.fsck.zeroPaddedFilemode=ignore \
            https://github.com/rbenv/ruby-build.git /usr/local/share/ruby-build
        mkdir -p /root/.rbenv/plugins

        ln -s /usr/local/share/ruby-build /root/.rbenv/plugins/ruby-build
    fi

    if [ "${USERNAME}" != "root" ]; then
        mkdir -p /home/${USERNAME}/.rbenv/plugins

        if [[ ! -d "/home/${USERNAME}/.rbenv/plugins/ruby-build" ]]; then
            ln -s /usr/local/share/ruby-build /home/${USERNAME}/.rbenv/plugins/ruby-build
        fi

        # Oryx expects ruby to be installed in this specific path, else it breaks the oryx magic for ruby projects.
        if [ ! -f /usr/local/rvm/gems/default/bin/ruby ]; then
            ln -s /usr/local/rvm/rubies/default/bin/ruby /usr/local/rvm/gems/default/bin
        fi

        chown -R "${USERNAME}:rvm" "/home/${USERNAME}/.rbenv/"
        chmod -R g+r+w "/home/${USERNAME}/.rbenv"
        find "/home/${USERNAME}/.rbenv" -type d | xargs -n 1 chmod g+s
    fi
fi

chown -R "${USERNAME}:rvm" "/usr/local/rvm/"
chmod -R g+r+w "/usr/local/rvm/"
find "/usr/local/rvm/" -type d | xargs -n 1 chmod g+s

# Clean up
rvm cleanup all
${ROOT_GEM} cleanup

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"



================================================
FILE: src/ruby/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/rust/README.md
================================================

# Rust (rust)

Installs Rust, common Rust utilities, and their required dependencies

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/rust:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Select or enter a version of Rust to install. | string | latest |
| profile | Select a rustup install profile. | string | minimal |
| targets | Optional comma separated list of additional Rust targets to install. | string | - |
| components | Optional, comma separated list of Rust components to be installed | string | rust-analyzer,rust-src,rustfmt,clippy |

## Customizations

### VS Code Extensions

- `vadimcn.vscode-lldb`
- `rust-lang.rust-analyzer`
- `tamasfe.even-better-toml`



## OS Support

This Feature should work on recent versions of Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, RockyLinux 
and Mariner distributions with the `apt`, `yum`, `dnf`, `microdnf` and `tdnf` package manager installed.


**Note:** Alpine is not supported because the rustup-init binary requires glibc to run, but Alpine Linux does not include `glibc` 
by default. Instead, it uses musl libc, which is not binary-compatible with glibc.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/rust/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/rust/devcontainer-feature.json
================================================
{
    "id": "rust",
    "version": "1.5.0",
    "name": "Rust",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/rust",
    "description": "Installs Rust, common Rust utilities, and their required dependencies",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "none",
                "1.87",
                "1.86",
                "1.85",
                "1.84",
                "1.83",
                "1.82",
                "1.81",
                "1.80",
                "1.79",
                "1.78",
                "1.77",
                "1.76",
                "1.75",
                "1.74",
                "1.73",
                "1.72",
                "1.71",
                "1.70",
                "1.69",
                "1.68",
                "1.67",
                "1.66",
                "1.65",
                "1.64"
            ],
            "default": "latest",
            "description": "Select or enter a version of Rust to install."
        },
        "profile": {
            "type": "string",
            "proposals": [
                "minimal",
                "default",
                "complete"
            ],
            "default": "minimal",
            "description": "Select a rustup install profile."
        },
        "targets": {
            "type": "string",
            "default": "",
            "description": "Optional comma separated list of additional Rust targets to install.",
            "proposals": [
                "aarch64-unknown-linux-gnu",
                "armv7-unknown-linux-gnueabihf",
                "x86_64-unknown-redox,x86_64-unknown-uefi"
            ]
        },
        "components": {
            "type": "string",
            "default": "rust-analyzer,rust-src,rustfmt,clippy",
            "description": "Optional, comma separated list of Rust components to be installed",
            "proposals": [
                "rust-analyzer,rust-src,rustfmt,clippy",
                "rust-analyzer,rust-src",
                "rustfmt,clippy,rust-docs",
                "llvm-tools-preview,rust-src,rustfmt"
            ]
        }        
    },
    "customizations": {
        "vscode": {
            "extensions": [
                "vadimcn.vscode-lldb",
                "rust-lang.rust-analyzer",
                "tamasfe.even-better-toml"
            ],
            "settings": {
                "files.watcherExclude": {
                    "**/target/**": true
                },
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes Rust, common Rust utilities, and needed dependencies pre-installed and available on the `PATH`, along with the Rust language extension for Rust development."
                    }
                ]
            }
        }
    },
    "containerEnv": {
        "CARGO_HOME": "/usr/local/cargo",
        "RUSTUP_HOME": "/usr/local/rustup",
        "PATH": "/usr/local/cargo/bin:${PATH}"
    },
    "capAdd": [
        "SYS_PTRACE"
    ],
    "securityOpt": [
        "seccomp=unconfined"
    ],
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/rust/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/rust.md
# Maintainer: The VS Code and Codespaces Teams

RUST_VERSION="${VERSION:-"latest"}"
RUSTUP_PROFILE="${PROFILE:-"minimal"}"
RUSTUP_TARGETS="${TARGETS:-""}"
IFS=',' read -ra components <<< "${COMPONENTS:-rust-analyzer,rust-src,rustfmt,clippy}"

export CARGO_HOME="${CARGO_HOME:-"/usr/local/cargo"}"
export RUSTUP_HOME="${RUSTUP_HOME:-"/usr/local/rustup"}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
UPDATE_RC="${UPDATE_RC:-"true"}"
UPDATE_RUST="${UPDATE_RUST:-"false"}"

set -e

# Detect the Linux distribution and package manager
PKG_MANAGER=""

# Bring in ID, ID_LIKE, VERSION_ID, VERSION_CODENAME
. /etc/os-release
# Get an adjusted ID independent of distro variants
if [ "${ID}" = "debian" ] || [ "${ID_LIKE}" = "debian" ]; then
    ADJUSTED_ID="debian"
elif [ "${ID}" = "alpine" ]; then
    ADJUSTED_ID="alpine"
elif [[ "${ID}" = "rhel" || "${ID}" = "fedora" || "${ID}" = "mariner" || "${ID_LIKE}" = *"rhel"* || "${ID_LIKE}" = *"fedora"* || "${ID_LIKE}" = *"mariner"* ]]; then
    ADJUSTED_ID="rhel"
    VERSION_CODENAME="${ID}${VERSION_ID}"
else
    echo "Linux distro ${ID} not supported."
    exit 1
fi

if [ "${ADJUSTED_ID}" = "rhel" ] && [ "${VERSION_CODENAME-}" = "centos7" ]; then
    # As of 1 July 2024, mirrorlist.centos.org no longer exists.
    # Update the repo files to reference vault.centos.org.
    sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.repo
    sed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.repo
    sed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo
fi


# Detect package manager
if command -v apt-get >/dev/null 2>&1; then
    PKG_MANAGER="apt"
elif command -v dnf >/dev/null 2>&1; then
    PKG_MANAGER="dnf"
elif command -v yum >/dev/null 2>&1; then
    PKG_MANAGER="yum"
elif command -v microdnf >/dev/null 2>&1; then
    PKG_MANAGER="microdnf"
elif command -v tdnf >/dev/null 2>&1; then
    PKG_MANAGER="tdnf"
else
    echo "No supported package manager found. Supported: apt, dnf, yum, microdnf, tdnf"
    exit 1
fi

echo "Detected package manager: $PKG_MANAGER"

# Clean up based on package manager
clean_package_cache() {
    case "$PKG_MANAGER" in
        apt)
            if [ "$(ls -1 /var/lib/apt/lists/ 2>/dev/null | wc -l)" -gt 0 ]; then
                rm -rf /var/lib/apt/lists/*
            fi
            ;;
        dnf|yum|microdnf)
            if command -v dnf >/dev/null 2>&1; then
                dnf clean all
            elif command -v yum >/dev/null 2>&1; then
                yum clean all
            elif command -v microdnf >/dev/null 2>&1; then
                microdnf clean all
            fi
            ;;
        tdnf)
            tdnf clean all
            ;;
    esac
}

# Initial cleanup
clean_package_cache

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Ensure that login shells get the correct path if the user updated the PATH using ENV.
rm -f /etc/profile.d/00-restore-env.sh
echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
chmod +x /etc/profile.d/00-restore-env.sh

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u "${CURRENT_USER}" > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u "${USERNAME}" > /dev/null 2>&1; then
    USERNAME=root
fi

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags "${repository}" | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

check_nightly_version_formatting() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi

    local version_date=$(echo ${requested_version} | sed -e "s/^nightly-//")


    if ! date -d "${version_date}" &>/dev/null; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nNightly version should be in the format nightly-YYYY-MM-DD" >&2
        exit 1
    fi

    if [ "$(date -d "${version_date}" +%s)" -ge "$(date +%s)" ]; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nNightly version should not exceed current date" >&2
        exit 1
    fi
}

updaterc() {
    if [ "${UPDATE_RC}" = "true" ]; then
        echo "Updating shell configuration files..."
        local bashrc_file="/etc/bash.bashrc"
        
        # Different distributions use different bashrc locations
        if [ ! -f "$bashrc_file" ]; then
            if [ -f "/etc/bashrc" ]; then
                bashrc_file="/etc/bashrc"
            elif [ -f "/etc/bash/bashrc" ]; then
                bashrc_file="/etc/bash/bashrc"
            fi
        fi
        
        if [ -f "$bashrc_file" ] && [[ "$(cat "$bashrc_file")" != *"$1"* ]]; then
            echo -e "$1" >> "$bashrc_file"
        fi
        
        if [ -f "/etc/zsh/zshrc" ] && [[ "$(cat /etc/zsh/zshrc)" != *"$1"* ]]; then
            echo -e "$1" >> /etc/zsh/zshrc
        fi
    fi
}

# Package update functions
pkg_mgr_update() {
    case "$PKG_MANAGER" in
        apt)
            if [ "$(find /var/lib/apt/lists/* 2>/dev/null | wc -l)" = "0" ]; then
                echo "Running apt-get update..."
                apt-get update -y
            fi
            ;;
        dnf)
            dnf check-update || true
            ;;
        yum)
            yum check-update || true
            ;;
        microdnf)
            # microdnf doesn't have check-update
            true
            ;;
        tdnf)
            tdnf makecache || true
            ;;
    esac
}

# Check if package is installed
is_package_installed() {
    local package=$1
    case "$PKG_MANAGER" in
        apt)
            dpkg -s "$package" >/dev/null 2>&1
            ;;
        dnf|yum|microdnf|tdnf)
            rpm -q "$package" >/dev/null 2>&1
            ;;
    esac
}

# Unified package checking and installation function
check_packages() {
    local packages=("$@")
    local missing_packages=()

    # Check if curl-minimal is installed and swap it with curl
    if is_package_installed "curl-minimal"; then
        echo "curl-minimal is installed. Swapping it with curl..."
        case "$PKG_MANAGER" in
            dnf|yum|microdnf)
                ${PKG_MANAGER} swap curl-minimal curl -y
                ;;
            tdnf)
                tdnf remove -y curl-minimal
                tdnf install -y curl
                ;;
            *)
                echo "Package manager does not support swapping curl-minimal with curl. Please handle this manually."
                ;;
        esac
    fi

    # Map package names based on distribution
    for i in "${!packages[@]}"; do
        case "$PKG_MANAGER" in
            dnf|yum|microdnf|tdnf)
                case "${packages[$i]}" in
                    "libc6-dev") packages[$i]="glibc-devel" ;;
                    "python3-minimal") packages[$i]="python3" ;;
                    "libpython3.*") packages[$i]="python3-devel" ;;
                    "gnupg2") packages[$i]="gnupg" ;;
                esac
                ;;
        esac
    done

    # Check which packages are missing
    for package in "${packages[@]}"; do
        if [ -n "$package" ] && ! is_package_installed "$package"; then
            missing_packages+=("$package")
        fi
    done

    # Install missing packages
    if [ ${#missing_packages[@]} -gt 0 ]; then
        pkg_mgr_update
        case "$PKG_MANAGER" in
            apt)
                apt-get -y install --no-install-recommends "${missing_packages[@]}"
                ;;
            dnf)
                dnf install -y "${missing_packages[@]}"
                ;;
            yum)
                yum install -y "${missing_packages[@]}"
                ;;
            microdnf)
                microdnf install -y "${missing_packages[@]}"
                ;;
            tdnf)
                tdnf install -y "${missing_packages[@]}"
                ;;
        esac
    fi
}

export DEBIAN_FRONTEND=noninteractive

# Install curl, lldb, python3-minimal,libpython and rust dependencies if missing
echo "Installing required dependencies..."
check_packages curl ca-certificates gcc libc6-dev gnupg2 git

# Install optional dependencies (continue if they fail)
case "$PKG_MANAGER" in
    apt)
        check_packages lldb python3-minimal libpython3.? || true
        ;;
    dnf|yum|microdnf)
        check_packages lldb python3 python3-devel || true
        ;;
    tdnf)
        check_packages python3 python3-devel || true
        # LLDB might not be available in Photon/Mariner
        ;;
esac

# Get architecture
if command -v dpkg >/dev/null 2>&1; then
    architecture="$(dpkg --print-architecture)"
else
    architecture="$(uname -m)"
    # Convert common architectures to Debian equivalents
    case ${architecture} in
        x86_64)
            architecture="amd64"
            ;;
        aarch64)
            architecture="arm64"
            ;;
    esac
fi

download_architecture="${architecture}"
case ${download_architecture} in
 amd64|x86_64)
    download_architecture="x86_64"
    ;;
 arm64|aarch64)
    download_architecture="aarch64"
    ;;
 *) echo "(!) Architecture ${architecture} not supported."
    exit 1
    ;;
esac

# Install Rust
umask 0002
if ! grep -e "^rustlang:" /etc/group > /dev/null 2>&1; then
    groupadd -r rustlang
fi
usermod -a -G rustlang "${USERNAME}"
mkdir -p "${CARGO_HOME}" "${RUSTUP_HOME}"
chown "${USERNAME}:rustlang" "${RUSTUP_HOME}" "${CARGO_HOME}"
chmod g+r+w+s "${RUSTUP_HOME}" "${CARGO_HOME}"

if [ "${RUST_VERSION}" = "none" ] || type rustup > /dev/null 2>&1; then
    echo "Rust already installed. Skipping..."
else
    if [ "${RUST_VERSION}" != "latest" ] && [ "${RUST_VERSION}" != "lts" ] && [ "${RUST_VERSION}" != "stable" ]; then
        # Find version using soft match
        if ! type git > /dev/null 2>&1; then
            check_packages git
        fi

        is_nightly=0
        echo "${RUST_VERSION}" | grep -q "nightly" || is_nightly=$?
        if [ $is_nightly = 0 ]; then
            check_nightly_version_formatting RUST_VERSION
        else
            find_version_from_git_tags RUST_VERSION "https://github.com/rust-lang/rust" "tags/"
        fi
        default_toolchain_arg="--default-toolchain ${RUST_VERSION}"
    fi
    echo "Installing Rust..."
    # Download and verify rustup sha
    mkdir -p /tmp/rustup/target/${download_architecture}-unknown-linux-gnu/release/
    curl -sSL --proto '=https' --tlsv1.2 "https://static.rust-lang.org/rustup/dist/${download_architecture}-unknown-linux-gnu/rustup-init" -o /tmp/rustup/target/${download_architecture}-unknown-linux-gnu/release/rustup-init
    curl -sSL --proto '=https' --tlsv1.2 "https://static.rust-lang.org/rustup/dist/${download_architecture}-unknown-linux-gnu/rustup-init.sha256" -o /tmp/rustup/rustup-init.sha256
    cd /tmp/rustup
    cp /tmp/rustup/target/${download_architecture}-unknown-linux-gnu/release/rustup-init  /tmp/rustup/rustup-init
    sha256sum -c rustup-init.sha256
    chmod +x target/${download_architecture}-unknown-linux-gnu/release/rustup-init
    target/${download_architecture}-unknown-linux-gnu/release/rustup-init -y --no-modify-path --profile "${RUSTUP_PROFILE}" ${default_toolchain_arg}
    cd ~
    rm -rf /tmp/rustup
fi

export PATH=${CARGO_HOME}/bin:${PATH}
if [ "${UPDATE_RUST}" = "true" ]; then
    echo "Updating Rust..."
    rustup update 2>&1
fi
# Install Rust components
echo "Installing Rust components..."
for component in "${components[@]}"; do
    # Trim leading and trailing whitespace
    component="${component#"${component%%[![:space:]]*}"}" && component="${component%"${component##*[![:space:]]}"}"
    if [ -n "${component}" ]; then
        echo "Installing Rust component: ${component}"
        if ! rustup component add "${component}" 2>&1; then
            echo "Warning: Failed to install component '${component}'. It may not be available for this toolchain." >&2
            exit 1
        fi
    fi
done

if [ -n "${RUSTUP_TARGETS}" ]; then
    IFS=',' read -ra targets <<< "${RUSTUP_TARGETS}"
    for target in "${targets[@]}"; do
        echo "Installing additional Rust target $target"
        rustup target add "$target" 2>&1
    done
fi

# Add CARGO_HOME, RUSTUP_HOME and bin directory into bashrc/zshrc files (unless disabled)
updaterc "$(cat << EOF
export RUSTUP_HOME="${RUSTUP_HOME}"
export CARGO_HOME="${CARGO_HOME}"
if [[ "\${PATH}" != *"\${CARGO_HOME}/bin"* ]]; then export PATH="\${CARGO_HOME}/bin:\${PATH}"; fi
EOF
)"

# Make files writable for rustlang group
chmod -R g+r+w "${RUSTUP_HOME}" "${CARGO_HOME}"

# Clean up
clean_package_cache

echo "Done!"



================================================
FILE: src/rust/NOTES.md
================================================


## OS Support

This Feature should work on recent versions of Debian/Ubuntu, RedHat Enterprise Linux, Fedora, Alma, RockyLinux 
and Mariner distributions with the `apt`, `yum`, `dnf`, `microdnf` and `tdnf` package manager installed.


**Note:** Alpine is not supported because the rustup-init binary requires glibc to run, but Alpine Linux does not include `glibc` 
by default. Instead, it uses musl libc, which is not binary-compatible with glibc.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/sshd/README.md
================================================

# SSH server (sshd)

Adds a SSH server into a container so that you can use an external terminal, sftp, or SSHFS to interact with it.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/sshd:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| gatewayPorts | Enable other hosts in the same network to connect to the forwarded ports | string | no
| version | Currently unused. | string | latest |

## Usage

While the some services automates SSH setup (e.g., when using the GitHub CLI for GitHub Codespaces), this may not be the case for other tools and services. Follow these directions to connect to the dev container from these other tools:

1. Connect to your dev container using a desktop tool or CLI that supports the dev container spec (e.g., VS Code client).

2. The first time you've started the container, you will want to set a password for your user. If running as a user other than root, and you have `sudo` installed:

    ```bash
    sudo passwd $(whoami)
    ```

    Or if you are running as root:

    ```bash
    passwd
    ```

3. Forward the SSH port (`2222` by default) to your local machine using either the `forwardPorts` property in `devcontainer.json` or the user interface in your tool (e.g., you can press <kbd>F1</kbd> or <kbd>Ctrl/Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> and select **Ports: Focus on Ports View** in VS Code to bring it into focus).

4. Use a **local terminal** (or other tool) to connect to it using the command and password from step 2. e.g.

    ```bash
    ssh -p 2222 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null vscode@localhost
    ```

    ...where `vscode` above is the user you are running as in the container and `2222` after `-p` is the **local address port** from step 2.

    The â€œ-oâ€ arguments are optional, but will prevent you from getting warnings or errors about known hosts when you do this from multiple containers/codespaces.

5. Next time you connect to your container, just repeat steps 3 and 4 and use the same password you set in step 2.

### Using SSHFS

[SSHFS](https://en.wikipedia.org/wiki/SSHFS) allows you to mount a remote filesystem to your local machine with nothing but a SSH connection. Here's how to use it with a dev container.

1. Follow the steps in the previous section to ensure you can connect to the dev container using the normal `ssh` client.

2. Install a SSHFS client.

    - **Windows:** Install [WinFsp](https://github.com/billziss-gh/winfsp/releases) and [SSHFS-Win](https://github.com/billziss-gh/sshfs-win/releases).
    - **macOS**: Use [Homebrew](https://brew.sh/) to install: `brew install macfuse gromgit/fuse/sshfs-mac`
    - **Linux:** Use your native package manager to install your distribution's copy of the sshfs package. e.g. `sudo apt-get update && sudo apt-get install sshfs`

3. Mount the remote filesystem.

    - **macOS / Linux:** Use the `sshfs` command to mount the remote filesystem. The arguments are similar to the normal `ssh` command but with a few additions. For example: 

        ```
        mkdir -p ~/sshfs/devcontainer
        sshfs "vscode@localhost:/workspaces" "$HOME/sshfs/devcontainer" -p 2222 -o follow_symlinks -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null -C
        ```
        ...where `vscode` above is the user you are running as in the container (e.g. `codespace`, `vscode`, `node`, or `root`) and `2222` after the `-p` is the same local port you used in the `ssh` command in step 1.

    - **Windows:** Press Window+R and enter the following in the "Open" field in the Run dialog: 
    
        ```
        \\sshfs.r\vscode@localhost!2222\workspaces
        ```
        ...where `vscode` above is the user you are running as in the container and `2222` after the `!` is the same local port you used in the `ssh` command in the previous section.

4. Your dev container's filesystem should now be available in the `~/sshfs/devcontainer` folder on macOS or Linux or in a new explorer window on Windows.


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/sshd/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/sshd/devcontainer-feature.json
================================================
{
    "id": "sshd",
    "version": "1.1.0",
    "name": "SSH server",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/sshd",
    "description": "Adds a SSH server into a container so that you can use an external terminal, sftp, or SSHFS to interact with it.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest"
            ],
            "default": "latest",
            "description": "Currently unused."
        },
        "gatewayPorts": {
            "type": "string",
            "enum": [
                "no",
                "yes",
                "clientspecified"
            ],
            "default": "no",
            "description": "Enable other hosts in the same network to connect to the forwarded ports"
        }
    },
    "entrypoint": "/usr/local/share/ssh-init.sh",
    "customizations": {
        "vscode": {
            "settings": {
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes an SSH server so that you can use an external terminal, sftp, or SSHFS to interact with it. The first time you've started the container, you will want to set a password for your user. With each connection to the container, you'll want to forward the SSH port to your local machine and use a local terminal or other tool to connect using the password you set."
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/sshd/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/sshd.md
# Maintainer: The VS Code and Codespaces Teams
#
# Note: You can change your user's password with "sudo passwd $(whoami)" (or just "passwd" if running as root).

SSHD_PORT="${SSHD_PORT:-"2222"}"
USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
START_SSHD="${START_SSHD:-"false"}"
NEW_PASSWORD="${NEW_PASSWORD:-"skip"}"
GATEWAY_PORTS="${GATEWAYPORTS:-"no"}" 

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive

# Install openssh-server openssh-client
check_packages openssh-server openssh-client lsof

# Generate password if new password set to the word "random"
if [ "${NEW_PASSWORD}" = "random" ]; then
    NEW_PASSWORD="$(openssl rand -hex 16)"
    EMIT_PASSWORD="true"
elif [ "${NEW_PASSWORD}" != "skip" ]; then
    # If new password not set to skip, set it for the specified user
    echo "${USERNAME}:${NEW_PASSWORD}" | chpasswd
fi

if [ $(getent group ssh) ]; then
  echo "'ssh' group already exists."
else
  echo "adding 'ssh' group, as it does not already exist."
  groupadd ssh
fi

# Add user to ssh group
if [ "${USERNAME}" != "root" ]; then
    usermod -aG ssh ${USERNAME}
fi

# Setup sshd
mkdir -p /var/run/sshd
sed -i 's/session\s*required\s*pam_loginuid\.so/session optional pam_loginuid.so/g' /etc/pam.d/sshd
sed -i 's/#*PermitRootLogin prohibit-password/PermitRootLogin yes/g' /etc/ssh/sshd_config
sed -i -E "s/#*\s*Port\s+.+/Port ${SSHD_PORT}/g" /etc/ssh/sshd_config
sed -i "s/#GatewayPorts no/GatewayPorts ${GATEWAY_PORTS}/g" /etc/ssh/sshd_config
# Need to UsePAM so /etc/environment is processed
sed -i -E "s/#?\s*UsePAM\s+.+/UsePAM yes/g" /etc/ssh/sshd_config

# Write out a scripts that can be referenced as an ENTRYPOINT to auto-start sshd and fix login environments
tee /usr/local/share/ssh-init.sh > /dev/null \
<< 'EOF'
#!/usr/bin/env bash
# This script is intended to be run as root with a container that runs as root (even if you connect with a different user)
# However, it supports running as a user other than root if passwordless sudo is configured for that same user.

set -e 

sudoIf()
{
    if [ "$(id -u)" -ne 0 ]; then
        sudo "$@"
    else
        "$@"
    fi
}

EOF
tee -a /usr/local/share/ssh-init.sh > /dev/null \
<< 'EOF'

# ** Start SSH server **
sudoIf /etc/init.d/ssh start 2>&1 | sudoIf tee /tmp/sshd.log > /dev/null

set +e
exec "$@"
EOF
chmod +x /usr/local/share/ssh-init.sh

# If we should start sshd now, do so
if [ "${START_SSHD}" = "true" ]; then
    /usr/local/share/ssh-init.sh
fi

# Output success details
echo -e "Done!\n\n- Port: ${SSHD_PORT}\n- User: ${USERNAME}"
if [ "${EMIT_PASSWORD}" = "true" ]; then
    echo "- Password: ${NEW_PASSWORD}"
fi

# Clean up
rm -rf /var/lib/apt/lists/*

echo -e "\nForward port ${SSHD_PORT} to your local machine and run:\n\n  ssh -p ${SSHD_PORT} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null ${USERNAME}@localhost\n"



================================================
FILE: src/sshd/NOTES.md
================================================
## Usage

While the some services automates SSH setup (e.g., when using the GitHub CLI for GitHub Codespaces), this may not be the case for other tools and services. Follow these directions to connect to the dev container from these other tools:

1. Connect to your dev container using a desktop tool or CLI that supports the dev container spec (e.g., VS Code client).

2. The first time you've started the container, you will want to set a password for your user. If running as a user other than root, and you have `sudo` installed:

    ```bash
    sudo passwd $(whoami)
    ```

    Or if you are running as root:

    ```bash
    passwd
    ```

3. Forward the SSH port (`2222` by default) to your local machine using either the `forwardPorts` property in `devcontainer.json` or the user interface in your tool (e.g., you can press <kbd>F1</kbd> or <kbd>Ctrl/Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> and select **Ports: Focus on Ports View** in VS Code to bring it into focus).

4. Use a **local terminal** (or other tool) to connect to it using the command and password from step 2. e.g.

    ```bash
    ssh -p 2222 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null vscode@localhost
    ```

    ...where `vscode` above is the user you are running as in the container and `2222` after `-p` is the **local address port** from step 2.

    The â€œ-oâ€ arguments are optional, but will prevent you from getting warnings or errors about known hosts when you do this from multiple containers/codespaces.

5. Next time you connect to your container, just repeat steps 3 and 4 and use the same password you set in step 2.

### Using SSHFS

[SSHFS](https://en.wikipedia.org/wiki/SSHFS) allows you to mount a remote filesystem to your local machine with nothing but a SSH connection. Here's how to use it with a dev container.

1. Follow the steps in the previous section to ensure you can connect to the dev container using the normal `ssh` client.

2. Install a SSHFS client.

    - **Windows:** Install [WinFsp](https://github.com/billziss-gh/winfsp/releases) and [SSHFS-Win](https://github.com/billziss-gh/sshfs-win/releases).
    - **macOS**: Use [Homebrew](https://brew.sh/) to install: `brew install macfuse gromgit/fuse/sshfs-mac`
    - **Linux:** Use your native package manager to install your distribution's copy of the sshfs package. e.g. `sudo apt-get update && sudo apt-get install sshfs`

3. Mount the remote filesystem.

    - **macOS / Linux:** Use the `sshfs` command to mount the remote filesystem. The arguments are similar to the normal `ssh` command but with a few additions. For example: 

        ```
        mkdir -p ~/sshfs/devcontainer
        sshfs "vscode@localhost:/workspaces" "$HOME/sshfs/devcontainer" -p 2222 -o follow_symlinks -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null -C
        ```
        ...where `vscode` above is the user you are running as in the container (e.g. `codespace`, `vscode`, `node`, or `root`) and `2222` after the `-p` is the same local port you used in the `ssh` command in step 1.

    - **Windows:** Press Window+R and enter the following in the "Open" field in the Run dialog: 
    
        ```
        \\sshfs.r\vscode@localhost!2222\workspaces
        ```
        ...where `vscode` above is the user you are running as in the container and `2222` after the `!` is the same local port you used in the `ssh` command in the previous section.

4. Your dev container's filesystem should now be available in the `~/sshfs/devcontainer` folder on macOS or Linux or in a new explorer window on Windows.


## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: src/terraform/README.md
================================================

# Terraform, tflint, and TFGrunt (terraform)

Installs the Terraform CLI and optionally TFLint and Terragrunt. Auto-detects latest version and installs needed dependencies.

## Example Usage

```json
"features": {
    "ghcr.io/devcontainers/features/terraform:1": {}
}
```

## Options

| Options Id | Description | Type | Default Value |
|-----|-----|-----|-----|
| version | Terraform version | string | latest |
| tflint | Tflint version (https://github.com/terraform-linters/tflint/releases) | string | latest |
| terragrunt | Terragrunt version | string | latest |
| installSentinel | Install sentinel, a language and framework for policy built to be embedded in existing software to enable fine-grained, logic-based policy decisions | boolean | false |
| installTFsec | Install tfsec, a tool to spot potential misconfigurations for your terraform code | boolean | false |
| installTerraformDocs | Install terraform-docs, a utility to generate documentation from Terraform modules | boolean | false |
| httpProxy | Connect to a keyserver using a proxy by configuring this option | string | - |
| customDownloadServer | Custom server URL for downloading Terraform and Sentinel packages, including protocol (e.g., https://releases.hashicorp.com). If not provided, the default HashiCorp download server (https://releases.hashicorp.com) will be used. | string | - |

## Customizations

### VS Code Extensions

- `HashiCorp.terraform`



## Licensing

On August 10, 2023, HashiCorp announced a change of license for its products, including Terraform. After ~9 years of Terraform being open source under the MPL v2 license, it was to move under a non-open source BSL v1.1 license, starting from the next (1.6) version. See https://github.com/hashicorp/terraform/blob/main/LICENSE

## Custom Download Server

The `customDownloadServer` option allows you to specify an alternative server for downloading Terraform and Sentinel packages. This is useful for organizations that maintain internal mirrors or have proxies for HashiCorp downloads.

When using this option:
- Provide the complete URL including protocol (e.g., `https://my-mirror.example.com`)
- The server should mirror the HashiCorp releases structure

Example:
```json
"features": {
    "ghcr.io/devcontainers/features/terraform:1": {
        "customDownloadServer": "https://my-mirror.example.com"
    }
}
```

### âš ï¸ Security Considerations

When using a custom download server, be aware of the following security implications:

- **Server Verification**: Always verify that the custom server is trustworthy and maintained by your organization or a trusted entity. Using an untrusted or compromised server could lead to downloading malicious software.
  
- **Supply Chain Risks**: Malicious actors may attempt to distribute compromised versions of Terraform that contain backdoors, cryptominers, or other harmful code.
  
- **Integrity Checks**: The feature performs SHA256 checks when available, but these are only as trustworthy as the source of the checksums. If both the binaries and checksums come from a compromised server, the integrity check may pass despite the software being malicious.
  
- **Organizational Policy**: Ensure your custom download server adheres to your organization's security policies and implements proper access controls.

Always use the official HashiCorp download server (https://releases.hashicorp.com) unless you have a specific need for an alternative source.

## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.


---

_Note: This file was auto-generated from the [devcontainer-feature.json](https://github.com/devcontainers/features/blob/main/src/terraform/devcontainer-feature.json).  Add additional notes to a `NOTES.md`._



================================================
FILE: src/terraform/devcontainer-feature.json
================================================
{
    "id": "terraform",
    "version": "1.4.2",
    "name": "Terraform, tflint, and TFGrunt",
    "documentationURL": "https://github.com/devcontainers/features/tree/main/src/terraform",
    "description": "Installs the Terraform CLI and optionally TFLint and Terragrunt. Auto-detects latest version and installs needed dependencies.",
    "options": {
        "version": {
            "type": "string",
            "proposals": [
                "latest",
                "none",
                "1.1",
                "1.0",
                "0.15"
            ],
            "default": "latest",
            "description": "Terraform version"
        },
        "tflint": {
            "type": "string",
            "proposals": [
                "latest",
                "0.47.0",
                "0.46.1"
            ],
            "default": "latest",
            "description": "Tflint version (https://github.com/terraform-linters/tflint/releases)"
        },
        "terragrunt": {
            "type": "string",
            "proposals": [
                "latest"
            ],
            "default": "latest",
            "description": "Terragrunt version"
        },
        "installSentinel": {
            "type": "boolean",
            "default": false,
            "description": "Install sentinel, a language and framework for policy built to be embedded in existing software to enable fine-grained, logic-based policy decisions"
        },
        "installTFsec": {
            "type": "boolean",
            "default": false,
            "description": "Install tfsec, a tool to spot potential misconfigurations for your terraform code"
        },
        "installTerraformDocs": {
            "type": "boolean",
            "default": false,
            "description": "Install terraform-docs, a utility to generate documentation from Terraform modules"
        },
        "httpProxy": {
            "type": "string",
            "default": "",
            "description": "Connect to a keyserver using a proxy by configuring this option"
        },
        "customDownloadServer": {
            "type": "string",
            "default": "",
            "description": "Custom server URL for downloading Terraform and Sentinel packages, including protocol (e.g., https://releases.hashicorp.com). If not provided, the default HashiCorp download server (https://releases.hashicorp.com) will be used."
        }
    },
    "customizations": {
        "vscode": {
            "extensions": [
                "HashiCorp.terraform"
            ],
            "settings": {
                "terraform.languageServer.enable": true,
                "terraform.languageServer.args": [
                    "serve"
                ],
                "github.copilot.chat.codeGeneration.instructions": [
                    {
                        "text": "This dev container includes the Terraform CLI and optionally TFLint and Terragrunt pre-installed and available on the `PATH`, along with the Terraform extension for Terraform development."
                    }
                ]
            }
        }
    },
    "installsAfter": [
        "ghcr.io/devcontainers/features/common-utils"
    ]
}



================================================
FILE: src/terraform/install.sh
================================================
#!/usr/bin/env bash
#-------------------------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.
#-------------------------------------------------------------------------------------------------------------
#
# Docs: https://github.com/microsoft/vscode-dev-containers/blob/main/script-library/docs/terraform.md
# Maintainer: The VS Code and Codespaces Teams

set -e

# Clean up
rm -rf /var/lib/apt/lists/*

TERRAFORM_VERSION="${VERSION:-"latest"}"
TFLINT_VERSION="${TFLINT:-"latest"}"
TERRAGRUNT_VERSION="${TERRAGRUNT:-"latest"}"
INSTALL_SENTINEL=${INSTALLSENTINEL:-false}
INSTALL_TFSEC=${INSTALLTFSEC:-false}
INSTALL_TERRAFORM_DOCS=${INSTALLTERRAFORMDOCS:-false}
CUSTOM_DOWNLOAD_SERVER="${CUSTOMDOWNLOADSERVER:-""}"
# This is because ubuntu noble and debian trixie don't support the old format of GPG keys and validation 
NEW_GPG_CODENAMES="trixie noble"

TERRAFORM_SHA256="${TERRAFORM_SHA256:-"automatic"}"
TFLINT_SHA256="${TFLINT_SHA256:-"automatic"}"
TERRAGRUNT_SHA256="${TERRAGRUNT_SHA256:-"automatic"}"
SENTINEL_SHA256="${SENTINEL_SHA256:-"automatic"}"
TFSEC_SHA256="${TFSEC_SHA256:-"automatic"}"
TERRAFORM_DOCS_SHA256="${TERRAFORM_DOCS_SHA256:-"automatic"}"

HASHICORP_RELEASES_URL="https://releases.hashicorp.com"
if [ -n "${CUSTOM_DOWNLOAD_SERVER}" ]; then
    HASHICORP_RELEASES_URL="${CUSTOM_DOWNLOAD_SERVER}"
fi

TERRAFORM_GPG_KEY="72D7468F"
TFLINT_GPG_KEY_URI="https://raw.githubusercontent.com/terraform-linters/tflint/v0.46.1/8CE69160EB3F2FE9.key"
KEYSERVER_PROXY="${HTTPPROXY:-"${HTTP_PROXY:-""}"}"

architecture="$(uname -m)"
case ${architecture} in
    x86_64) architecture="amd64";;
    aarch64 | armv8*) architecture="arm64";;
    aarch32 | armv7* | armvhf*) architecture="arm";;
    i?86) architecture="386";;
    *) echo "(!) Architecture ${architecture} unsupported"; exit 1 ;;
esac

if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi

# Detect Ubuntu Noble or Debian Trixie and use new repo setup, else use legacy GPG logic
IS_GPG_NEW=0
. /etc/os-release
if [[ "${NEW_GPG_CODENAMES}" == *"${VERSION_CODENAME}"* ]]; then
    IS_GPG_NEW=1
fi

# Get the list of GPG key servers that are reachable
get_gpg_key_servers() {
    declare -A keyservers_curl_map=(
        ["hkps://keyserver.ubuntu.com"]="https://keyserver.ubuntu.com"
        ["hkps://keys.openpgp.org"]="https://keys.openpgp.org"
        ["hkps://keyserver.pgp.com"]="https://keyserver.pgp.com"
    )

    local curl_args=""
    local keyserver_reachable=false  # Flag to indicate if any keyserver is reachable

    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        curl_args="--proxy ${KEYSERVER_PROXY}"
    fi

    for keyserver in "${!keyservers_curl_map[@]}"; do
        local keyserver_curl_url="${keyservers_curl_map[${keyserver}]}"
        if curl -s ${curl_args} --max-time 5 ${keyserver_curl_url} > /dev/null; then
            echo "keyserver ${keyserver}"
            keyserver_reachable=true
        else
            echo "(*) Keyserver ${keyserver} is not reachable." >&2
        fi
    done

    if ! $keyserver_reachable; then
        echo "(!) No keyserver is reachable." >&2
        exit 1
    fi
}

# Import the specified key in a variable name passed in as 
receive_gpg_keys() {
    local keys=${!1}
    local keyring_args=""
    if [ ! -z "$2" ]; then
        keyring_args="--no-default-keyring --keyring $2"
    fi
    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        keyring_args="${keyring_args} --keyserver-options http-proxy=${KEYSERVER_PROXY}"
    fi

    # Install curl
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi

    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    
    # Special handling for HashiCorp GPG key on Ubuntu Noble
    if [ "$IS_GPG_NEW" -eq 1 ] && [ "$keys" = "$TERRAFORM_GPG_KEY" ]; then
        echo "(*) Ubuntu Noble detected, using Keybase for HashiCorp GPG key import...."
        curl -fsSL https://keybase.io/hashicorp/pgp_keys.asc | gpg --import
        if ! gpg --list-keys "${TERRAFORM_GPG_KEY}" > /dev/null 2>&1; then
            gpg --list-keys
            echo "(*) Warning: HashiCorp GPG key not found in keyring after import."
            echo "    Continuing installation without GPG verification on Ubuntu Noble."
            echo "    This is expected behavior for Ubuntu Noble due to keyserver issues."
            return 1  # Return failure to indicate GPG verification should be skipped
        fi
        return 0
    fi

    echo -e "disable-ipv6\n$(get_gpg_key_servers)" > ${GNUPGHOME}/dirmngr.conf
    # GPG key download sometimes fails for some reason and retrying fixes it.
    local retry_count=0
    local gpg_ok="false"
    set +e
    until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "5" ]; 
    do
        echo "(*) Downloading GPG key..."
        ( echo "${keys}" | xargs -n 1 gpg -q ${keyring_args} --recv-keys) 2>&1 && gpg_ok="true"
        if [ "${gpg_ok}" != "true" ]; then
            echo "(*) Failed getting key, retrying in 10s..."
            (( retry_count++ ))
            sleep 10s
        fi
    done

    # If all attempts fail, try getting the keyserver IP address and explicitly passing it to gpg
    if [ "${gpg_ok}" = "false" ]; then
        retry_count=0;
        echo "(*) Resolving GPG keyserver IP address..."
        local keyserver_ip_address=$( dig +short keyserver.ubuntu.com | head -n1 )
        echo "(*) GPG keyserver IP address $keyserver_ip_address"
        
        until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "3" ]; 
        do
            echo "(*) Downloading GPG key..."
            ( echo "${keys}" | xargs -n 1 gpg -q ${keyring_args} --recv-keys --keyserver ${keyserver_ip_address}) 2>&1 && gpg_ok="true"
            if [ "${gpg_ok}" != "true" ]; then
                echo "(*) Failed getting key, retrying in 10s..."
                (( retry_count++ ))
                sleep 10s
            fi
        done
    fi
    set -e
    if [ "${gpg_ok}" = "false" ]; then
        echo "(!) Failed to get gpg key."
        exit 1
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

find_sentinel_version_from_url() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local prefix='sentinel_'
        local regex="${prefix}\d.\d{2}.\d(?:-\w*)?"
        local version_list="$(wget -q $2 -O - | grep -oP ${regex} | tr -d ${prefix} | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" >/dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");

    # install jq
    check_packages jq
    
    message=$(echo "$output" | jq -r '.message')
    
    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="${prev_version}"
    else
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}

install_previous_version() {
    given_version=$1
    requested_version=${!given_version}
    local URL=$2
    INSTALLER_FN=$3
    local REPO_URL=$(get_github_api_repo_url "$URL")
    local PKG_NAME=$(get_pkg_name "${given_version}")
    echo -e "\n(!) Failed to fetch the latest artifacts for ${PKG_NAME} v${requested_version}..."
    get_previous_version "$URL" "$REPO_URL" requested_version
    echo -e "\nAttempting to install ${requested_version}"
    declare -g ${given_version}="${requested_version#v}"
    $INSTALLER_FN "${!given_version}"
    echo "${given_version}=${!given_version}"
}

install_cosign() {
    COSIGN_VERSION=$1
    local URL=$2
    cosign_filename="/tmp/cosign_${COSIGN_VERSION}_${architecture}.deb"
    cosign_url="https://github.com/sigstore/cosign/releases/latest/download/cosign_${COSIGN_VERSION}_${architecture}.deb"
    curl -L "${cosign_url}" -o $cosign_filename
    if grep -q "Not Found" "$cosign_filename"; then
        echo -e "\n(!) Failed to fetch the latest artifacts for cosign v${COSIGN_VERSION}..."
        REPO_URL=$(get_github_api_repo_url "$URL")
        get_previous_version "$URL" "$REPO_URL" COSIGN_VERSION
        echo -e "\nAttempting to install ${COSIGN_VERSION}"
        cosign_filename="/tmp/cosign_${COSIGN_VERSION}_${architecture}.deb"
        cosign_url="https://github.com/sigstore/cosign/releases/latest/download/cosign_${COSIGN_VERSION}_${architecture}.deb"
        curl -L "${cosign_url}" -o $cosign_filename
    fi
    dpkg -i $cosign_filename
    rm $cosign_filename
    echo "Installation of cosign succeeded with ${COSIGN_VERSION}."
}

# Install 'cosign' for validating signatures
# https://docs.sigstore.dev/cosign/overview/
ensure_cosign() {
    check_packages curl ca-certificates gnupg2

    if ! type cosign > /dev/null 2>&1; then
        echo "Installing cosign..."
        COSIGN_VERSION="latest"
        cosign_url='https://github.com/sigstore/cosign'
        find_version_from_git_tags COSIGN_VERSION "${cosign_url}"
        install_cosign "${COSIGN_VERSION}" "${cosign_url}"
    fi
    if ! type cosign > /dev/null 2>&1; then
        echo "(!) Failed to install cosign."
        exit 1
    fi
    cosign version
}

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive

# Install dependencies if missing
check_packages curl ca-certificates gnupg2 dirmngr coreutils unzip dnsutils
if ! type git > /dev/null 2>&1; then
    check_packages git
fi

terraform_url='https://github.com/hashicorp/terraform'
tflint_url='https://github.com/terraform-linters/tflint'
terragrunt_url='https://github.com/gruntwork-io/terragrunt'
# Verify requested version is available, convert latest
find_version_from_git_tags TERRAFORM_VERSION "$terraform_url"
find_version_from_git_tags TFLINT_VERSION "$tflint_url"
find_version_from_git_tags TERRAGRUNT_VERSION "$terragrunt_url"

install_terraform() {
    local TERRAFORM_VERSION=$1
    terraform_filename="terraform_${TERRAFORM_VERSION}_linux_${architecture}.zip"
    curl -sSL -o ${terraform_filename} "${HASHICORP_RELEASES_URL}/terraform/${TERRAFORM_VERSION}/${terraform_filename}"
}

verify_signature() {
    local gpg_key=$1
    local sha256sums_url=$2
    local sig_url=$3
    local sha256sums_file=$4
    local sig_file=$5
    local verify_result=0

    receive_gpg_keys "$gpg_key"
    verify_result=$?
    if [ $verify_result -ne 0 ] && [ "$IS_GPG_NEW" -eq 1 ]; then
        echo "Skipping the gpg key validation for ubuntu noble as unable to import the key."
        return 1
    fi
    curl -sSL -o "$sha256sums_file" "$sha256sums_url"
    curl -sSL -o "$sig_file" "$sig_url"

    # Try GPG verification, but don't fail on Noble
    gpg --verify "$sig_file" "$sha256sums_file"
    verify_result=$?
    if [ $verify_result -ne 0 ]; then
        echo "(!) GPG verification failed."
        exit 1
    fi
}

mkdir -p /tmp/tf-downloads
cd /tmp/tf-downloads
# Install Terraform, tflint, Terragrunt
echo "Downloading terraform..."
terraform_filename="terraform_${TERRAFORM_VERSION}_linux_${architecture}.zip"
install_terraform "$TERRAFORM_VERSION"
if grep -q "The specified key does not exist." "${terraform_filename}"; then
    install_previous_version TERRAFORM_VERSION $terraform_url "install_terraform"
    terraform_filename="terraform_${TERRAFORM_VERSION}_linux_${architecture}.zip"
fi
if [ "${TERRAFORM_SHA256}" != "dev-mode" ]; then
    if [ "${TERRAFORM_SHA256}" = "automatic" ]; then
        # For Ubuntu Noble, try GPG verification but continue if it fails
        if [ "$IS_GPG_NEW" -eq 1 ]; then
            echo "(*) Ubuntu Noble detected - attempting GPG verification with fallback..."
            set +e
            sha256sums_url="${HASHICORP_RELEASES_URL}/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_SHA256SUMS"
            sig_url="${HASHICORP_RELEASES_URL}/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_SHA256SUMS.${TERRAFORM_GPG_KEY}.sig"
            verify_signature TERRAFORM_GPG_KEY "$sha256sums_url" "$sig_url" "terraform_SHA256SUMS" "terraform_SHA256SUMS.sig"
            verify_result=$?
            set -e
            if [ $verify_result -ne 0 ]; then
                echo "(*) GPG verification failed on Ubuntu Noble, but continuing installation."
                echo "    Downloading checksums for basic integrity check..."
                curl -sSL -o terraform_SHA256SUMS "${HASHICORP_RELEASES_URL}/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_SHA256SUMS"
            fi
        else
            sha256sums_url="${HASHICORP_RELEASES_URL}/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_SHA256SUMS"
            sig_url="${HASHICORP_RELEASES_URL}/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_SHA256SUMS.${TERRAFORM_GPG_KEY}.sig"
            verify_signature TERRAFORM_GPG_KEY "$sha256sums_url" "$sig_url" "terraform_SHA256SUMS" "terraform_SHA256SUMS.sig"
        fi
    else
        echo "${TERRAFORM_SHA256} *${terraform_filename}" > terraform_SHA256SUMS
    fi
    sha256sum --ignore-missing -c terraform_SHA256SUMS
fi
unzip ${terraform_filename}
mv -f terraform /usr/local/bin/

install_tflint() {
    TFLINT_VERSION=$1
    curl -sSL -o /tmp/tf-downloads/${TFLINT_FILENAME} https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/${TFLINT_FILENAME}
}

if [ "${TFLINT_VERSION}" != "none" ]; then
    echo "Downloading tflint..."
    TFLINT_FILENAME="tflint_linux_${architecture}.zip"
    install_tflint "$TFLINT_VERSION"
    if grep -q "Not Found" "/tmp/tf-downloads/${TFLINT_FILENAME}"; then 
        install_previous_version TFLINT_VERSION "$tflint_url" "install_tflint"
    fi
    if [ "${TFLINT_SHA256}" != "dev-mode" ]; then

        if [ "${TFLINT_SHA256}" != "automatic" ]; then
            echo "${TFLINT_SHA256} *${TFLINT_FILENAME}" > tflint_checksums.txt
            sha256sum --ignore-missing -c tflint_checksums.txt
        else
            curl -sSL -o tflint_checksums.txt https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/checksums.txt

            set +e
            curl -sSL -o checksums.txt.keyless.sig https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/checksums.txt.keyless.sig
            set -e

            # Check that checksums.txt.keyless.sig exists and is not empty
            if [ -s checksums.txt.keyless.sig ]; then
                # Validate checksums with cosign
                curl -sSL -o checksums.txt.pem https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/checksums.txt.pem
                ensure_cosign
                cosign verify-blob \
                    --certificate=/tmp/tf-downloads/checksums.txt.pem \
                    --signature=/tmp/tf-downloads/checksums.txt.keyless.sig \
                    --certificate-identity-regexp="^https://github.com/terraform-linters/tflint"  \
                    --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
                    /tmp/tf-downloads/tflint_checksums.txt
                # Ensure that checksums.txt has $TFLINT_FILENAME
                grep ${TFLINT_FILENAME} /tmp/tf-downloads/tflint_checksums.txt
                # Validate downloaded file
                sha256sum --ignore-missing -c tflint_checksums.txt
            else
                # Fallback to older, GPG-based verification (pre-0.47.0 of tflint)
                curl -sSL -o tflint_checksums.txt.sig https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/checksums.txt.sig
                curl -sSL -o tflint_key "${TFLINT_GPG_KEY_URI}"
                gpg -q --import tflint_key
                gpg --verify tflint_checksums.txt.sig tflint_checksums.txt
            fi
        fi
    fi

    unzip /tmp/tf-downloads/${TFLINT_FILENAME}
    mv -f tflint /usr/local/bin/
fi

install_terragrunt() {
    TERRAGRUNT_VERSION=$1
    curl -sSL -o /tmp/tf-downloads/${terragrunt_filename} https://github.com/gruntwork-io/terragrunt/releases/download/v${TERRAGRUNT_VERSION}/${terragrunt_filename}
}

if [ "${TERRAGRUNT_VERSION}" != "none" ]; then
    echo "Downloading Terragrunt..."
    terragrunt_filename="terragrunt_linux_${architecture}"
    install_terragrunt "$TERRAGRUNT_VERSION"
    output=$(cat "/tmp/tf-downloads/${terragrunt_filename}")
    if [[ $output == "Not Found" ]]; then
        install_previous_version TERRAGRUNT_VERSION $terragrunt_url "install_terragrunt"
    fi
    if [ "${TERRAGRUNT_SHA256}" != "dev-mode" ]; then
        if [ "${TERRAGRUNT_SHA256}" = "automatic" ]; then
            curl -sSL -o terragrunt_SHA256SUMS https://github.com/gruntwork-io/terragrunt/releases/download/v${TERRAGRUNT_VERSION}/SHA256SUMS
        else
            echo "${TERRAGRUNT_SHA256} *${terragrunt_filename}" > terragrunt_SHA256SUMS
        fi
        sha256sum --ignore-missing -c terragrunt_SHA256SUMS
    fi
    chmod a+x /tmp/tf-downloads/${terragrunt_filename}
    mv -f /tmp/tf-downloads/${terragrunt_filename} /usr/local/bin/terragrunt
fi

if [ "${INSTALL_SENTINEL}" = "true" ]; then
    SENTINEL_VERSION="latest"
    sentinel_releases_url="${HASHICORP_RELEASES_URL}/sentinel"
    find_sentinel_version_from_url SENTINEL_VERSION ${sentinel_releases_url}
    sentinel_filename="sentinel_${SENTINEL_VERSION}_linux_${architecture}.zip"
    echo "(*) Downloading Sentinel... ${sentinel_filename}"
    curl -sSL -o /tmp/tf-downloads/${sentinel_filename} ${sentinel_releases_url}/${SENTINEL_VERSION}/${sentinel_filename}
    if [ "${SENTINEL_SHA256}" != "dev-mode" ]; then
        if [ "${SENTINEL_SHA256}" = "automatic" ]; then
            # For Ubuntu Noble, try GPG verification but continue if it fails
            if [ "$IS_GPG_NEW" -eq 1 ]; then
                echo "(*) Ubuntu Noble detected - attempting Sentinel GPG verification with fallback..."
                set +e
                sha256sums_url="${sentinel_releases_url}/${SENTINEL_VERSION}/sentinel_${SENTINEL_VERSION}_SHA256SUMS"
                sig_url="${sentinel_releases_url}/${SENTINEL_VERSION}/sentinel_${SENTINEL_VERSION}_SHA256SUMS.${TERRAFORM_GPG_KEY}.sig"
                verify_signature TERRAFORM_GPG_KEY "$sha256sums_url" "$sig_url" "sentinel_checksums.txt" "sentinel_checksums.txt.sig"
                verify_result=$?
                set -e
                if [ $verify_result -ne 0 ]; then
                    echo "(*) GPG verification failed on Ubuntu Noble, but continuing installation."
                    echo "    Downloading checksums for basic integrity check..."
                    curl -sSL -o sentinel_checksums.txt "${sentinel_releases_url}/${SENTINEL_VERSION}/sentinel_${SENTINEL_VERSION}_SHA256SUMS"
                fi
            else
                sha256sums_url="${sentinel_releases_url}/${SENTINEL_VERSION}/sentinel_${SENTINEL_VERSION}_SHA256SUMS"
                sig_url="${sentinel_releases_url}/${SENTINEL_VERSION}/sentinel_${SENTINEL_VERSION}_SHA256SUMS.${TERRAFORM_GPG_KEY}.sig"
                verify_signature TERRAFORM_GPG_KEY "$sha256sums_url" "$sig_url" "sentinel_checksums.txt" "sentinel_checksums.txt.sig"
            fi
            # Verify the SHASUM matches the archive
            shasum -a 256 --ignore-missing -c sentinel_checksums.txt            
        else
            echo "${SENTINEL_SHA256} *${SENTINEL_FILENAME}" >sentinel_checksums.txt
        fi
        sha256sum --ignore-missing -c sentinel_checksums.txt
    fi
    unzip /tmp/tf-downloads/${sentinel_filename}
    chmod a+x /tmp/tf-downloads/sentinel
    mv -f /tmp/tf-downloads/sentinel /usr/local/bin/sentinel
fi

install_tfsec() {
    local TFSEC_VERSION=$1
    tfsec_filename="tfsec_${TFSEC_VERSION}_linux_${architecture}.tar.gz"
    curl -sSL -o /tmp/tf-downloads/${tfsec_filename} https://github.com/aquasecurity/tfsec/releases/download/v${TFSEC_VERSION}/${tfsec_filename}
}

if [ "${INSTALL_TFSEC}" = "true" ]; then
    TFSEC_VERSION="latest"
    tfsec_url='https://github.com/aquasecurity/tfsec'
    find_version_from_git_tags TFSEC_VERSION $tfsec_url
    tfsec_filename="tfsec_${TFSEC_VERSION}_linux_${architecture}.tar.gz"
    echo "(*) Downloading TFSec... ${tfsec_filename}"
    install_tfsec "$TFSEC_VERSION"
    if grep -q "Not Found" "/tmp/tf-downloads/${tfsec_filename}"; then 
        install_previous_version TFSEC_VERSION $tfsec_url "install_tfsec"
        tfsec_filename="tfsec_${TFSEC_VERSION}_linux_${architecture}.tar.gz"
    fi
    if [ "${TFSEC_SHA256}" != "dev-mode" ]; then
        if [ "${TFSEC_SHA256}" = "automatic" ]; then
            curl -sSL -o tfsec_SHA256SUMS https://github.com/aquasecurity/tfsec/releases/download/v${TFSEC_VERSION}/tfsec_${TFSEC_VERSION}_checksums.txt
        else
            echo "${TFSEC_SHA256} *${tfsec_filename}" > tfsec_SHA256SUMS
        fi
        sha256sum --ignore-missing -c tfsec_SHA256SUMS
    fi
    mkdir -p /tmp/tf-downloads/tfsec
    tar -xzf /tmp/tf-downloads/${tfsec_filename} -C /tmp/tf-downloads/tfsec
    chmod a+x /tmp/tf-downloads/tfsec/tfsec
    mv -f /tmp/tf-downloads/tfsec/tfsec /usr/local/bin/tfsec
fi

install_terraform_docs() {
    local TERRAFORM_DOCS_VERSION=$1
    tfdocs_filename="terraform-docs-v${TERRAFORM_DOCS_VERSION}-linux-${architecture}.tar.gz"
    curl -sSL -o /tmp/tf-downloads/${tfdocs_filename} https://github.com/terraform-docs/terraform-docs/releases/download/v${TERRAFORM_DOCS_VERSION}/${tfdocs_filename}
}

if [ "${INSTALL_TERRAFORM_DOCS}" = "true" ]; then
    TERRAFORM_DOCS_VERSION="latest"
    terraform_docs_url='https://github.com/terraform-docs/terraform-docs'
    find_version_from_git_tags TERRAFORM_DOCS_VERSION $terraform_docs_url
    tfdocs_filename="terraform-docs-v${TERRAFORM_DOCS_VERSION}-linux-${architecture}.tar.gz"
    echo "(*) Downloading Terraform docs... ${tfdocs_filename}"
    install_terraform_docs "$TERRAFORM_DOCS_VERSION"
    if grep -q "Not Found" "/tmp/tf-downloads/${tfdocs_filename}"; then
        install_previous_version TERRAFORM_DOCS_VERSION $terraform_docs_url "install_terraform_docs"
        tfdocs_filename="terraform-docs-v${TERRAFORM_DOCS_VERSION}-linux-${architecture}.tar.gz"
    fi
    if [ "${TERRAFORM_DOCS_SHA256}" != "dev-mode" ]; then
        if [ "${TERRAFORM_DOCS_SHA256}" = "automatic" ]; then
            curl -sSL -o tfdocs_SHA256SUMS https://github.com/terraform-docs/terraform-docs/releases/download/v${TERRAFORM_DOCS_VERSION}/terraform-docs-v${TERRAFORM_DOCS_VERSION}.sha256sum
        else
            echo "${TERRAFORM_DOCS_SHA256} *${tfsec_filename}" > tfdocs_SHA256SUMS
        fi
        sha256sum --ignore-missing -c tfdocs_SHA256SUMS
    fi
    mkdir -p /tmp/tf-downloads/tfdocs
    tar -xzf /tmp/tf-downloads/${tfdocs_filename} -C /tmp/tf-downloads/tfdocs
    chmod a+x /tmp/tf-downloads/tfdocs/terraform-docs
    mv -f /tmp/tf-downloads/tfdocs/terraform-docs /usr/local/bin/terraform-docs
fi

rm -rf /tmp/tf-downloads ${GNUPGHOME}

# Clean up
rm -rf /var/lib/apt/lists/*

echo "Done!"



================================================
FILE: src/terraform/NOTES.md
================================================


## Licensing

On August 10, 2023, HashiCorp announced a change of license for its products, including Terraform. After ~9 years of Terraform being open source under the MPL v2 license, it was to move under a non-open source BSL v1.1 license, starting from the next (1.6) version. See https://github.com/hashicorp/terraform/blob/main/LICENSE

## Custom Download Server

The `customDownloadServer` option allows you to specify an alternative server for downloading Terraform and Sentinel packages. This is useful for organizations that maintain internal mirrors or have proxies for HashiCorp downloads.

When using this option:
- Provide the complete URL including protocol (e.g., `https://my-mirror.example.com`)
- The server should mirror the HashiCorp releases structure

Example:
```json
"features": {
    "ghcr.io/devcontainers/features/terraform:1": {
        "customDownloadServer": "https://my-mirror.example.com"
    }
}
```

### âš ï¸ Security Considerations

When using a custom download server, be aware of the following security implications:

- **Server Verification**: Always verify that the custom server is trustworthy and maintained by your organization or a trusted entity. Using an untrusted or compromised server could lead to downloading malicious software.
  
- **Supply Chain Risks**: Malicious actors may attempt to distribute compromised versions of Terraform that contain backdoors, cryptominers, or other harmful code.
  
- **Integrity Checks**: The feature performs SHA256 checks when available, but these are only as trustworthy as the source of the checksums. If both the binaries and checksums come from a compromised server, the integrity check may pass despite the software being malicious.
  
- **Organizational Policy**: Ensure your custom download server adheres to your organization's security policies and implements proper access controls.

Always use the official HashiCorp download server (https://releases.hashicorp.com) unless you have a specific need for an alternative source.

## OS Support

This Feature should work on recent versions of Debian/Ubuntu-based distributions with the `apt` package manager installed.

`bash` is required to execute the `install.sh` script.



================================================
FILE: test/_global/all_the_clis.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "check for aws" aws --version
check "check for gh" gh --version
check "check for azure" az  --version

# Report result
reportResults


================================================
FILE: test/_global/node_java_rust.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "check for node" node --version
check "check for java" java --version
check "check for rust" rustc  --version

# Report result
reportResults


================================================
FILE: test/_global/scenarios.json
================================================
{
    "all_the_clis": {
        "image": "ubuntu:noble",
        "features": {
            "aws-cli": {},
            "azure-cli": {},
            "github-cli": {}
        }
    },
    "node_java_rust": {
        "image": "ubuntu:noble",
        "features": {
            "node": {},
            "java": {},
            "rust": {}
        }
    }
}


================================================
FILE: test/anaconda/install_anaconda_almalinux8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "conda" conda --version
check "python" python --version
check "pylint" pylint --version
check "flake8" flake8 --version
check "autopep8" autopep8 --version
check "yapf" yapf --version
check "pydocstyle" pydocstyle --version
check "pycodestyle" pycodestyle --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

check "certifi" pip show certifi | grep Version
check "cryptography" pip show cryptography | grep Version
check "setuptools" pip show setuptools | grep Version
check "tornado" pip show tornado | grep Version

check "conda-update-conda" bash -c "conda update -y conda"
check "conda-install-tensorflow" bash -c "conda create --name test-env -c conda-forge --yes tensorflow"
check "conda-install-pytorch" bash -c "conda create --name test-env -c conda-forge --yes pytorch"

# Report result
reportResults





================================================
FILE: test/anaconda/install_anaconda_almalinux9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "conda" conda --version
check "python" python --version
check "pylint" pylint --version
check "flake8" flake8 --version
check "autopep8" autopep8 --version
check "yapf" yapf --version
check "pydocstyle" pydocstyle --version
check "pycodestyle" pycodestyle --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

check "certifi" pip show certifi | grep Version
check "cryptography" pip show cryptography | grep Version
check "setuptools" pip show setuptools | grep Version
check "tornado" pip show tornado | grep Version

check "conda-update-conda" bash -c "conda update -y conda"
check "conda-install-tensorflow" bash -c "conda create --name test-env -c conda-forge --yes tensorflow"
check "conda-install-pytorch" bash -c "conda create --name test-env -c conda-forge --yes pytorch"

# Report result
reportResults





================================================
FILE: test/anaconda/install_anaconda_bookworm.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "conda" conda --version
check "python" python --version
check "pylint" pylint --version
check "flake8" flake8 --version
check "autopep8" autopep8 --version
check "yapf" yapf --version
check "pydocstyle" pydocstyle --version
check "pycodestyle" pycodestyle --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

check "certifi" pip show certifi | grep Version
check "cryptography" pip show cryptography | grep Version
check "setuptools" pip show setuptools | grep Version
check "tornado" pip show tornado | grep Version

check "conda-update-conda" bash -c "conda update -y conda"
check "conda-install-tensorflow" bash -c "conda create --name test-env -c conda-forge --yes tensorflow"
check "conda-install-pytorch" bash -c "conda create --name test-env -c conda-forge --yes pytorch"

# Report result
reportResults




================================================
FILE: test/anaconda/install_anaconda_bullseye.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "conda" conda --version
check "python" python --version
check "pylint" pylint --version
check "flake8" flake8 --version
check "autopep8" autopep8 --version
check "yapf" yapf --version
check "pydocstyle" pydocstyle --version
check "pycodestyle" pycodestyle --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

check "certifi" pip show certifi | grep Version
check "cryptography" pip show cryptography | grep Version
check "setuptools" pip show setuptools | grep Version
check "tornado" pip show tornado | grep Version

check "conda-update-conda" bash -c "conda update -y conda"
check "conda-install-tensorflow" bash -c "conda create --name test-env -c conda-forge --yes tensorflow"
check "conda-install-pytorch" bash -c "conda create --name test-env -c conda-forge --yes pytorch"

# Report result
reportResults




================================================
FILE: test/anaconda/install_anaconda_fedora.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "conda" conda --version
check "python" python --version
check "pylint" pylint --version
check "flake8" flake8 --version
check "autopep8" autopep8 --version
check "yapf" yapf --version
check "pydocstyle" pydocstyle --version
check "pycodestyle" pycodestyle --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

check "certifi" pip show certifi | grep Version
check "cryptography" pip show cryptography | grep Version
check "setuptools" pip show setuptools | grep Version
check "tornado" pip show tornado | grep Version

check "conda-update-conda" bash -c "conda update -y conda"
check "conda-install-tensorflow" bash -c "conda create --name test-env -c conda-forge --yes tensorflow"
check "conda-install-pytorch" bash -c "conda create --name test-env -c conda-forge --yes pytorch"

# Report result
reportResults





================================================
FILE: test/anaconda/install_anaconda_jammy.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "conda" conda --version
check "python" python --version
check "pylint" pylint --version
check "flake8" flake8 --version
check "autopep8" autopep8 --version
check "yapf" yapf --version
check "pydocstyle" pydocstyle --version
check "pycodestyle" pycodestyle --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

check "certifi" pip show certifi | grep Version
check "cryptography" pip show cryptography | grep Version
check "setuptools" pip show setuptools | grep Version
check "tornado" pip show tornado | grep Version

check "conda-update-conda" bash -c "conda update -y conda"
check "conda-install-tensorflow" bash -c "conda create --name test-env -c conda-forge --yes tensorflow"
check "conda-install-pytorch" bash -c "conda create --name test-env -c conda-forge --yes pytorch"

# Report result
reportResults




================================================
FILE: test/anaconda/install_anaconda_noble.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "conda" conda --version
check "python" python --version
check "pylint" pylint --version
check "flake8" flake8 --version
check "autopep8" autopep8 --version
check "yapf" yapf --version
check "pydocstyle" pydocstyle --version
check "pycodestyle" pycodestyle --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

check "certifi" pip show certifi | grep Version
check "cryptography" pip show cryptography | grep Version
check "setuptools" pip show setuptools | grep Version
check "tornado" pip show tornado | grep Version

check "conda-update-conda" bash -c "conda update -y conda"
check "conda-install-tensorflow" bash -c "conda create --name test-env -c conda-forge --yes tensorflow"
check "conda-install-pytorch" bash -c "conda create --name test-env -c conda-forge --yes pytorch"

# Report result
reportResults




================================================
FILE: test/anaconda/install_anaconda_noble_without_user.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "conda" conda --version
check "python" python --version
check "pylint" pylint --version
check "flake8" flake8 --version
check "autopep8" autopep8 --version
check "yapf" yapf --version
check "pydocstyle" pydocstyle --version
check "pycodestyle" pycodestyle --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

check "certifi" pip show certifi | grep Version
check "cryptography" pip show cryptography | grep Version
check "setuptools" pip show setuptools | grep Version
check "tornado" pip show tornado | grep Version

check "conda-update-conda" bash -c "conda update -y conda"
check "conda-install-tensorflow" bash -c "conda create --name test-env -c conda-forge --yes tensorflow"
check "conda-install-pytorch" bash -c "conda create --name test-env -c conda-forge --yes pytorch"

# Report result
reportResults




================================================
FILE: test/anaconda/install_anaconda_rockylinux8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "conda" conda --version
check "python" python --version
check "pylint" pylint --version
check "flake8" flake8 --version
check "autopep8" autopep8 --version
check "yapf" yapf --version
check "pydocstyle" pydocstyle --version
check "pycodestyle" pycodestyle --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

check "certifi" pip show certifi | grep Version
check "cryptography" pip show cryptography | grep Version
check "setuptools" pip show setuptools | grep Version
check "tornado" pip show tornado | grep Version

check "conda-update-conda" bash -c "conda update -y conda"
check "conda-install-tensorflow" bash -c "conda create --name test-env -c conda-forge --yes tensorflow"
check "conda-install-pytorch" bash -c "conda create --name test-env -c conda-forge --yes pytorch"

# Report result
reportResults





================================================
FILE: test/anaconda/install_anaconda_rockylinux9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "conda" conda --version
check "python" python --version
check "pylint" pylint --version
check "flake8" flake8 --version
check "autopep8" autopep8 --version
check "yapf" yapf --version
check "pydocstyle" pydocstyle --version
check "pycodestyle" pycodestyle --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

check "certifi" pip show certifi | grep Version
check "cryptography" pip show cryptography | grep Version
check "setuptools" pip show setuptools | grep Version
check "tornado" pip show tornado | grep Version

check "conda-update-conda" bash -c "conda update -y conda"
check "conda-install-tensorflow" bash -c "conda create --name test-env -c conda-forge --yes tensorflow"
check "conda-install-pytorch" bash -c "conda create --name test-env -c conda-forge --yes pytorch"

# Report result
reportResults






================================================
FILE: test/anaconda/scenarios.json
================================================
{
   "install_anaconda_noble": {
   "image": "mcr.microsoft.com/devcontainers/base:noble",
   "user": "vscode",
   "features": {
     "anaconda": {
       "version": "latest"
     }
   }
  },
  "install_anaconda_jammy": {
    "image": "mcr.microsoft.com/devcontainers/base:jammy",
    "user": "vscode",
    "features": {
      "anaconda": {
        "version": "latest"
      }
    }
   },
   "install_anaconda_bookworm": {
    "image": "mcr.microsoft.com/devcontainers/base:bookworm",
    "user": "vscode",
    "features": {
      "anaconda": {
        "version": "latest"
      }
    }
   },
   "install_anaconda_bullseye": {
    "image": "mcr.microsoft.com/devcontainers/base:bullseye",
    "user": "vscode",
    "features": {
      "anaconda": {
        "version": "latest"
      }
    }
  },
  "install_anaconda_noble_without_user": {
    "image": "mcr.microsoft.com/devcontainers/base:noble",
    "features": {
      "anaconda": {
        "version": "latest"
      }
    }
  },
  "install_anaconda_almalinux8": {
    "image": "almalinux:8",
    "features": {
      "anaconda": {
        "version": "latest"
      }
    }
  },
  "install_anaconda_almalinux9": {
    "image": "almalinux:9",
    "features": {
      "anaconda": {
        "version": "latest"
      }
    }
  },
  "install_anaconda_rockylinux8": {
    "image": "rockylinux:8",
    "features": {
      "anaconda": {
        "version": "latest"
      }
    }
  },
  "install_anaconda_rockylinux9": {
    "image": "rockylinux:9",
    "features": {
      "anaconda": {
        "version": "latest"
      }
    }
  },
  "install_anaconda_fedora": {
    "image": "fedora",
    "features": {
      "anaconda": {
        "version": "latest"
      }
    }
  }
}



================================================
FILE: test/anaconda/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" conda --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

# Report result
reportResults


================================================
FILE: test/aws-cli/checkBashCompletion.sh
================================================
#!/bin/bash

command=$1
expected=$2

echo -e "Checking completion for command '$command'..."

# Send command as a character stream, followed by two tab characters, into an interactive bash shell.
# Also note the 'y' which responds to the possible Bash question "Display all xxx possibilities? (y or n)".
# Bash produces the autocompletion output on stderr, so redirect that to stdout.
# The sed bit captures the lines between Header and Footer (used as output delimiters).
# The first grep removes the "Display all" message (that is atomatically answered to "y" by the script).
# The last grep filters the output to lines containing the expected result.
COMPLETE_OUTPUT=$(echo if false\; then "Header"\; $command$'\t'$'\t'y\; "Footer" fi | bash -i 2>&1 | sed -n '/Header/{:a;n;/Footer/q;p;ba}' | grep -v ^'Display all ')
echo -e "\nCompletion output:\n"
echo -e "$COMPLETE_OUTPUT"
echo -e "\n"

FILTERED_COMPLETE_OUTPUT=$(echo "$COMPLETE_OUTPUT" | grep "$expected")

if [ -z "$FILTERED_COMPLETE_OUTPUT" ]; then
  echo -e "Completion output does not contains '$expected'."
  exit 1
else
  echo -e "Completion output contains '$expected'."
  exit 0
fi



================================================
FILE: test/aws-cli/less_installed.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

check "less is installed, pagination works !" less --version
check "less binary installation path" which less
check "Testing paginated output with less" ls -R / | less

# Report result
reportResults


================================================
FILE: test/aws-cli/scenarios.json
================================================
{
    "less_installed": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "features": {
            "aws-cli": {}
        }
    }
}


================================================
FILE: test/aws-cli/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" aws --version

# By default bash complete is disabled for the root user
# Enable it by replacing current ~/.bashrc with the /etc/skel/.bashrc file
mv ~/.bashrc ~/.bashrc.bak
cp /etc/skel/.bashrc ~/

check "aws-bash-completion-contains-version-option" ./checkBashCompletion.sh "aws --" "version"

# Restore original ~/.bashrc
mv ~/.bashrc.bak ~/.bashrc

# Report result
reportResults


================================================
FILE: test/azure-cli/install_bicep.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

check "version" az  --version

# Bicep-specific tests
check "bicep" bicep --version
check "az bicep" az bicep version

# Report result
reportResults


================================================
FILE: test/azure-cli/install_bicep_trixie.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

check "version" az  --version

# Bicep-specific tests
check "bicep" bicep --version
check "az bicep" az bicep version

# Report result
reportResults




================================================
FILE: test/azure-cli/install_extensions.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

check "version" az  --version

# Extension-specific tests
check "aks-preview" az extension show --name aks-preview
check "amg" az extension show --name amg
check "containerapp" az extension show --name containerapp

# Report result
reportResults


================================================
FILE: test/azure-cli/install_extensions_bookworm.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

./install_extensions.sh


================================================
FILE: test/azure-cli/install_extensions_trixie.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

./install_extensions.sh




================================================
FILE: test/azure-cli/install_using_python_with_python_3_11_bullseye.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode
check "version" az  --version

echo -e "\n\nğŸ”„ Testing 'O.S'"
if cat /etc/os-release | grep -q 'PRETTY_NAME="Debian GNU/Linux 11 (bullseye)"'; then
    echo -e "\n\nâœ… Passed 'O.S is Linux 11 (bullseye)'!"
else
    echo -e "\n\nâŒ Failed 'O.S is other than Linux 11 (bullseye)'!"
fi


# Report result
reportResults


================================================
FILE: test/azure-cli/install_with_python.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode
check "version" az  --version


# Report result
reportResults


================================================
FILE: test/azure-cli/install_with_python_3_12_bookworm.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib


echo -e "\nğŸ”„ Testing 'O.S'"
if cat /etc/os-release | grep -q 'PRETTY_NAME="Debian GNU/Linux 12 (bookworm)"'; then
    echo -e "\nâœ… Passed 'O.S is Linux 12 (bookworm)'!\n"
else
    echo -e "\nâŒ Failed 'O.S is other than Linux 12 (bookworm)'!\n"
fi

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode
check "version" az  --version

# Report result
reportResults


================================================
FILE: test/azure-cli/install_with_python_3_13_trixie.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib


echo -e "\nğŸ”„ Testing 'O.S'"
if cat /etc/os-release | grep -q 'PRETTY_NAME="Debian GNU/Linux 13 (trixie)"'; then
    echo -e "\nâœ… Passed 'O.S is Linux 13 (trixie)'!\n"
else
    echo -e "\nâŒ Failed 'O.S is other than Linux 13 (trixie)'!\n"
fi

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode
check "version" az  --version

# Report result
reportResults




================================================
FILE: test/azure-cli/scenarios.json
================================================
{
  "install_extensions_trixie": {
    "image": "mcr.microsoft.com/devcontainers/base:trixie",
    "user": "vscode",
    "features": {
      "azure-cli": {
        "version": "latest",
        "extensions": "aks-preview,amg,containerapp"
      }
    }
  },  
  "install_extensions": {
    "image": "mcr.microsoft.com/devcontainers/base:jammy",
    "user": "vscode",
    "features": {
      "azure-cli": {
        "version": "latest",
        "extensions": "aks-preview,amg,containerapp"
      }
    }
  },
  "install_extensions_bookworm": {
    "image": "mcr.microsoft.com/devcontainers/base:bookworm",
    "user": "vscode",
    "features": {
      "azure-cli": {
        "version": "latest",
        "extensions": "aks-preview,amg,containerapp"
      }
    }
  },
  "install_bicep": {
    "image": "mcr.microsoft.com/devcontainers/base:jammy",
    "user": "vscode",
    "features": {
      "azure-cli": {
        "version": "latest",
        "installBicep": true
      }
    }
  },
    "install_bicep_trixie": {
    "image": "mcr.microsoft.com/devcontainers/base:trixie",
    "user": "vscode",
    "features": {
      "azure-cli": {
        "version": "latest",
        "installBicep": true
      }
    }
  },
  "install_with_python": {
    "image": "mcr.microsoft.com/devcontainers/base:jammy",
    "user": "vscode",
    "features": {
      "azure-cli": {
        "version": "latest",
        "installUsingPython": true
      }
    }
  },
  "install_with_python_3_13_trixie": {
    "image": "mcr.microsoft.com/devcontainers/python:2-3.13-trixie",
    "user": "vscode",
    "features": {
      "azure-cli": {
        "version": "latest",
        "installUsingPython": true
      }
    }
  },  
  "install_with_python_3_12_bookworm": {
    "image": "mcr.microsoft.com/devcontainers/python:1-3.12-bookworm",
    "user": "vscode",
    "features": {
      "azure-cli": {
        "version": "latest"
      }
    }
  },
  "install_using_python_with_python_3_11_bullseye": {
    "image": "mcr.microsoft.com/devcontainers/python:1-3.11-bullseye",
    "user": "vscode",
    "features": {
      "azure-cli": {
        "version": "latest",
        "installUsingPython": "true"
      }
    }
  }
}


================================================
FILE: test/azure-cli/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" az  --version

# Report result
reportResults


================================================
FILE: test/common-utils/alma-8-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${PLATFORM_ID}" = "platform:el8"
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/alma-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${PLATFORM_ID}" = "platform:el8"
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/alma-9-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${PLATFORM_ID}" = "platform:el9"
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/alma-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${PLATFORM_ID}" = "platform:el9"
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/alma-minimal-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${PLATFORM_ID}" = "platform:el9"
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/alma-minimal-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${PLATFORM_ID}" = "platform:el9"
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/alpine-3-14.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${ID}" = "alpine"
check "bashrc" ls /etc/bash/bashrc

# Report result
reportResults


================================================
FILE: test/common-utils/alpine-3-15.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${ID}" = "alpine"
check "bashrc" ls /etc/bash/bashrc

# Report result
reportResults


================================================
FILE: test/common-utils/alpine-3-18.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${ID}" = "alpine"
check "bashrc" ls /etc/bash/bashrc
check "libssl1.1 is installed" grep "libssl1.1" <(apk list --no-cache libssl1.1)

# Report result
reportResults


================================================
FILE: test/common-utils/alpine-base-zsh-default.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "alpine default shell zsh" \
  bash -c "getent passwd $(whoami) | awk -F : '{ print $7 }' | grep '/bin/zsh'"

# Report result
reportResults



================================================
FILE: test/common-utils/alpine.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${ID}" = "alpine"

# Report result
reportResults


================================================
FILE: test/common-utils/already-run.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "non-root user" test "$(whoami)" = "vscode"
check "jq" jq  --version
check "curl" curl  --version
check "git" git  --version
check "zsh" zsh --version
check "ps" ps --version
check "Oh My Zsh! theme" test -e $HOME/.oh-my-zsh/custom/themes

# Report result
reportResults


================================================
FILE: test/common-utils/alternate-values.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "non-root user" id alternate
check "running as root" test "$(whoami)" = "root"
check "jq" jq  --version
check "curl" curl  --version
check "git" git  --version
check "ps" ps --version
check "no zsh" bash -c '! zsh --version'
check "No Oh My Zsh!" test ! -e /home/alternate/.oh-my-zsh/custom/themes/devcontainers.zsh-theme

# Report result
reportResults


================================================
FILE: test/common-utils/Azure-linux-CU.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Load Linux distribution info
. /etc/os-release

# Check if the current user is root
check "root user" test "$(whoami)" = "root"

# Check if the Linux distro is Azure Linux
check "azurelinux distro" test "$ID" = "azurelinux"

# Definition specific tests
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults



================================================
FILE: test/common-utils/bionic.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${VERSION_CODENAME}" = "bionic"

# Report result
reportResults


================================================
FILE: test/common-utils/bookworm.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

FAILED=()
echoStderr()
{
    echo "$@" 1>&2
}

checkOSPackages() {
    LABEL=$1
    shift
    echo -e "\nğŸ§ª Testing $LABEL"
    if dpkg-query --show -f='${Package}: ${Version}\n' "$@"; then 
        echo "âœ…  Passed!"
        return 0
    else
        echoStderr "âŒ $LABEL check failed."
        FAILED+=("$LABEL")
        return 1
    fi
}

checkCommon()
{
    PACKAGE_LIST="manpages-posix \
        manpages-posix-dev"

    checkOSPackages "Installation of manpages-posix and manpages-posix-dev (non-free)" ${PACKAGE_LIST}
}

# Check for manpages-posix, manpages-posix-dev non-free packages
checkCommon

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${VERSION_CODENAME}" = "bookworm"

# Report result
reportResults


================================================
FILE: test/common-utils/bullseye.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${VERSION_CODENAME}" = "bullseye"

# Report result
reportResults


================================================
FILE: test/common-utils/centos-7.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${VERSION_ID}" = "7"
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/config-subdirectory.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "owned-config-sub-directory" bash -c "ls -ld ~/.config/subdirectory | awk '{print $3}' | grep 'devcontainer'"
check "owned-config-directory" bash -c "ls -ld ~/.config | awk '{print $3}' | grep 'devcontainer'"

# Report result
reportResults



================================================
FILE: test/common-utils/configure_zsh_as_default_shell.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "default-shell-is-zsh" bash -c "getent passwd $(whoami) | awk -F: '{ print $7 }' | grep '/bin/zsh'"
# check it overrides the ~/.zshrc with default dev containers template
check "default-zshrc-is-dev-container-template" bash -c "cat ~/.zshrc | grep ZSH_THEME | grep devcontainers"
check "zsh-path-contains-local-bin" zsh -l -c "echo $PATH | grep '/home/devcontainer/.local/bin'"

check "Ensure .zprofile is owned by remoteUser" bash -c "stat -c '%U' /home/devcontainer/.zprofile | grep devcontainer"

# Report result
reportResults



================================================
FILE: test/common-utils/configure_zsh_no_template_first_step.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "default-zsh-with-no-zshrc" bash -c "[ ! -e ~/.zshrc ]"

# Report result
reportResults



================================================
FILE: test/common-utils/configure_zsh_no_template_second_step.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib
# Definition specific tests
function file_not_overridden() {
    cat $1 | grep 'alias fnomockalias=' | grep testingmock
}
check "default-zsh-with-no-zshrc" file_not_overridden /home/devcontainer/.zshrc

# Report result
reportResults



================================================
FILE: test/common-utils/devcontainer-custom-home.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "user is customUser" grep customUser <(whoami)
check "home is /customHome" grep "/customHome" <(getent passwd customUser | cut -d: -f6) 

# Report result
reportResults



================================================
FILE: test/common-utils/devcontainer-custom-user-default-home.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "user is customUser" grep customUser <(whoami)
check "home is /home/customUser" grep "/home/customUser" <(getent passwd customUser | cut -d: -f6) 

# Report result
reportResults



================================================
FILE: test/common-utils/devcontainer-info.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check_info() {
    local info=$1
    check "devcontainer-info ${info}" sh -c "devcontainer-info | grep test-${info}"
}

# Definition specific tests
check "user" bash -c "whoami | grep vscode"
check_info "version"
check_info "id"
check_info "variant"
check_info "repository"
check_info "release"
check_info "revision"
check_info "time"
check_info "url"

# Report result
reportResults



================================================
FILE: test/common-utils/devcontainer-ruby-zshrc.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "configure-zshrc-without-overwrite" bash -c "grep 'rbenv init -' ~/.zshrc"

# Report result
reportResults



================================================
FILE: test/common-utils/fedora.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${ID}" = "fedora"
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/focal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${VERSION_CODENAME}" = "focal"

# Report result
reportResults


================================================
FILE: test/common-utils/jammy.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${VERSION_CODENAME}" = "jammy"

# Report result
reportResults


================================================
FILE: test/common-utils/mariner.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${ID}" = "mariner"
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/no-terminal-title-by-default.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release

# Make sure bashrc is applied
source /root/.bashrc

check "check_term_is_not_set" test !"$TERM"
check "check_prompt_command_not_set" test !"$PROMPT_COMMAND"

# Report result
reportResults


================================================
FILE: test/common-utils/noble.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${VERSION_CODENAME}" = "noble"

# Report result
reportResults




================================================
FILE: test/common-utils/rocky-8-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${PLATFORM_ID}" = "platform:el8"
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/rocky-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${PLATFORM_ID}" = "platform:el8"
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/rocky-9-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${PLATFORM_ID}" = "platform:el9"
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/rocky-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
check "non-root user" test "$(whoami)" = "devcontainer"
check "distro" test "${PLATFORM_ID}" = "platform:el9"
check "curl" curl --version
check "jq" jq  --version

# Report result
reportResults


================================================
FILE: test/common-utils/scenarios.json
================================================
{
    "jammy": {
        "image": "ubuntu:jammy",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "noble": {
        "image": "ubuntu:noble",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },    
    "bullseye": {
        "image": "debian:bullseye",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "bookworm": {
        "image": "debian:bookworm",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {
                "nonFreePackages": "true"
            }
        }
    },
    "centos-7": {
        "image": "centos:7",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "alma-8": {
        "image": "almalinux:8",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "alma-9": {
        "image": "almalinux:9",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "alma-8-minimal": {
        "image": "almalinux:8-minimal",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "alma-9-minimal": {
        "image": "almalinux:9-minimal",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "rocky-8": {
        "image": "rockylinux:8",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "rocky-9": {
        "image": "rockylinux:9",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "rocky-8-minimal": {
        "image": "rockylinux:8-minimal",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "rocky-9-minimal": {
        "image": "rockylinux:9-minimal",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "fedora": {
        "image": "fedora",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "mariner": {
        "image": "mcr.microsoft.com/cbl-mariner/base/core:2.0",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "alpine": {
        "image": "alpine",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "alternate-values": {
        "image": "debian:bullseye",
        "features": {
            "common-utils": {
                "username": "alternate",
                "userUid": "1001",
                "userGid": "1002",
                "upgradePackages": false,
                "installZsh": false,
                "nonFreePackages": true
            }
        }
    },
    "username-default": {
        "image": "debian:bullseye",
        "features": {
            "common-utils": {}
        }
    },
    "username-detected": {
        "image": "node",
        "features": {
            "common-utils": {}
        }
    },
    "already-run": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "common-utils": {}
        }
    },
    "configure_zsh_as_default_shell": {
        "image": "ubuntu",
        "features": {
            "common-utils": {
                "installZsh": true,
                "configureZshAsDefaultShell": true
            }
        },
        "remoteUser": "devcontainer"
    },
    "configure_zsh_no_template_second_step": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "postCreateCommand": "echo alias fnomockalias=testingmock >> /home/devcontainer/.zshrc",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {
                "installZsh": true,
                "installOhMyZshConfig": false
            }
        }
    },
    "configure_zsh_no_template_first_step": {
        "image": "debian:bullseye",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {
                "installZsh": true,
                "installOhMyZshConfig": false
            }
        }
    },
    "config-subdirectory": {
        "image": "alpine",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        },
        "mounts": [
            "source=${localEnv:HOME},target=/home/devcontainer/.config/subdirectory,type=bind,readonly"
        ]
    },
    "alpine-3-14": {
        "image": "alpine:3.14",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "alpine-3-15": {
        "image": "alpine:3.15",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "alpine-3-18": {
        "image": "alpine:3.18",
        "remoteUser": "devcontainer",
        "features": {
            "common-utils": {}
        }
    },
    "devcontainer-info": {
        "build": {
            "dockerfile": "Dockerfile"
        },
        "remoteUser": "vscode",
        "features": {
            "common-utils": {
                "username": "vscode",
                "userUid": "1000",
                "userGid": "1000",
                "upgradePackages": true,
                "installZsh": true
            }
        }
    },
    "devcontainer-ruby-zshrc": {
        "build": {
            "dockerfile": "Dockerfile"
        },
        "remoteUser": "vscode",
        "features": {
            "common-utils": {
                "installZsh": true,
                "username": "vscode",
                "userUid": "1000",
                "userGid": "1000",
                "upgradePackages": true,
                "installOhMyZsh": true,
                "installOhMyZshConfig": true,
                "configureZshAsDefaultShell": true
            }
        }
    },
    "alpine-base-zsh-default": {
        "image": "mcr.microsoft.com/devcontainers/base:alpine",
        "remoteUser": "vscode",
        "features": {
            "common-utils": {
                "configureZshAsDefaultShell": true
            }
        }
    },
    "devcontainer-custom-home": {
        "build": {
            "dockerfile": "Dockerfile"
        },
        "remoteUser": "customUser",
        "features": {
            "common-utils": {}
        }
    },
    "devcontainer-custom-user-default-home": {
        "image": "mcr.microsoft.com/devcontainers/base:alpine",
        "remoteUser": "customUser",
        "features": {
            "common-utils": {}
        }
    },
    "terminal-title-on-xterm": {
        "image": "node",
        "features": {
            "common-utils": {}
        },
        "containerEnv": {
            "TERM": "xterm"
        }
    },
    "no-terminal-title-by-default": {
        "image": "node",
        "features": {
            "common-utils": {}
        }
    },
    "Azure-linux-CU": {
        "image": "mcr.microsoft.com/dotnet/sdk:8.0-azurelinux3.0",
        "features": {
            "common-utils": {}
        }
    }
}


================================================
FILE: test/common-utils/terminal-title-on-xterm.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release

# Make sure bashrc is applied
source /root/.bashrc

check "check_term_is_set" test "$TERM" = "xterm"
check "check_term_is_set" test "$PROMPT_COMMAND" = "precmd"

# Report result
reportResults


================================================
FILE: test/common-utils/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "jq" jq  --version
check "curl" curl  --version
check "git" git  --version
check "zsh" zsh --version
check "ps" ps --version
check "Oh My Zsh! theme" test -e $HOME/.oh-my-zsh/custom/themes/devcontainers.zsh-theme
check "zsh theme symlink" test -e $HOME/.oh-my-zsh/custom/themes/codespaces.zsh-theme

# Report result
reportResults


================================================
FILE: test/common-utils/username-default.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
# .oh-my-zsh folder would only exist if user defaulting worked
check "non-root user" ls /home/vscode/.oh-my-zsh


# Report result
reportResults


================================================
FILE: test/common-utils/username-detected.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
. /etc/os-release
# .oh-my-zsh folder would only exist if user detection worked
check "non-root user" ls /home/node/.oh-my-zsh

# Report result
reportResults


================================================
FILE: test/common-utils/devcontainer-custom-home/Dockerfile
================================================
FROM ubuntu:noble

RUN groupadd customUser -g 30000 && \
    useradd customUser -u 30000 -g 30000 --create-home --home-dir /customHome



================================================
FILE: test/common-utils/devcontainer-info/Dockerfile
================================================
FROM ubuntu:noble

COPY meta.env /usr/local/etc/dev-containers/meta.env

RUN if id "ubuntu" &>/dev/null; then \
            echo "Deleting user 'ubuntu' for noble" && userdel -f -r ubuntu || echo "Failed to delete ubuntu user for noble"; \  
        else \
            echo "User 'ubuntu' does not exist for noble"; \ 
    fi



================================================
FILE: test/common-utils/devcontainer-info/meta.env
================================================
VERSION='test-version'
DEFINITION_ID='test-id'
VARIANT='test-variant'
GIT_REPOSITORY='test-repository'
GIT_REPOSITORY_RELEASE='test-release'
GIT_REPOSITORY_REVISION='test-revision'
BUILD_TIMESTAMP='test-time'
CONTENTS_URL='test-url'



================================================
FILE: test/common-utils/devcontainer-ruby-zshrc/Dockerfile
================================================
FROM mcr.microsoft.com/devcontainers/ruby:3.2

USER vscode
ENV USER=vscode
RUN echo 'eval "$(rbenv init -)"' >> /home/$USER/.zshrc




================================================
FILE: test/conda/install_conda.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "conda" conda --version | grep 4.12.0
check "conda-forge" conda config --show channels | grep conda-forge
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

# Report result
reportResults



================================================
FILE: test/conda/scenarios.json
================================================
{
    "install_conda": {
        "image": "ubuntu:noble",
        "features": {
            "conda": {
                "version": "4.12.0",
                "addCondaForge": "true"
            }
        }
    }
}



================================================
FILE: test/conda/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" conda --version
check "if conda-notice.txt exists" cat /usr/local/etc/vscode-dev-containers/conda-notice.txt

# Check env
check "CONDA_SCRIPT is set correctly" echo $CONDA_SCRIPT | grep "/opt/conda/etc/profile.d/conda.sh"

check-version-ge() {
    LABEL=$1
    CURRENT_VERSION=$2
    REQUIRED_VERSION=$3
    shift
    echo -e "\nğŸ§ª Testing $LABEL: '$CURRENT_VERSION' is >= '$REQUIRED_VERSION'"
    local GREATER_VERSION=$((echo ${CURRENT_VERSION}; echo ${REQUIRED_VERSION}) | sort -V | tail -1)
    if [ "${CURRENT_VERSION}" == "${GREATER_VERSION}" ]; then
        echo "âœ…  Passed!"
        return 0
    else
        echoStderr "âŒ $LABEL check failed."
        FAILED+=("$LABEL")
        return 1
    fi
}

certifiVersion=$(python -c "import certifi; print(certifi.__version__)")
check-version-ge "certifi" "${certifiVersion}" "2022.12.07"

cryptographyVersion=$(python -c "import cryptography; print(cryptography.__version__)")
check-version-ge "cryptography" "${cryptographyVersion}" "39.0.1"

setuptoolsVersion=$(python -c "import setuptools; print(setuptools.__version__)")
check-version-ge "setuptools" "${setuptoolsVersion}" "65.5.1"

# Report result
reportResults



================================================
FILE: test/desktop-lite/scenarios.json
================================================
{
    "test_xtigervnc_novnc_started": {
        "image": "ubuntu:noble",
        "features": {
            "desktop-lite": {}
        }
    },
    "test_xtigervnc_novnc_started_noVNC_old_launch_script": {
        "image": "ubuntu:noble",
        "features": {
            "desktop-lite": {
                "noVncVersion": "1.2.0"
            }
        }
    },    
    "test_vnc_resolution_as_container_env_var": {
        "image": "ubuntu:noble",
        "features": {
            "desktop-lite": {}
        }
        ,
        "containerEnv": {
            "VNC_RESOLUTION": "1920x1080x32"
        },
        "forwardPorts": [
            5901,
            6080
        ]
    },
    "test_vnc_resolution_as_remote_env_var": {
        "image": "ubuntu:noble",
        "features": {
            "desktop-lite": {}
        },
        "remoteEnv": {
            "VNC_RESOLUTION": "1920x1080x32"
        },
        "forwardPorts": [
            5901,
            6080
        ]
    },
    "test_xtigervnc_novnc_started_trixie": {
        "image": "debian:trixie",
        "features": {
            "desktop-lite": {}
        }
    }
}


================================================
FILE: test/desktop-lite/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

echoStderr()
{
    echo "$@" 1>&2
}

checkOSPackage() {
    LABEL=$1
    PACKAGE_NAME=$2
    echo -e "\nğŸ§ª Testing $LABEL"
    # Check if the package exists and retrieve its exact version
    if [ "$(dpkg-query -W -f='${Status}' "$PACKAGE_NAME" 2>/dev/null | grep -c "ok installed")" -eq 1 ]; then
        echo "âœ…  Package '$PACKAGE_NAME' is installed."
        exit 0
    else
        echo "âŒ Package '$PACKAGE_NAME' is not installed."
        exit 1
    fi
}

check "desktop-init-exists" bash -c "ls /usr/local/share/desktop-init.sh"
check "log-exists" bash -c "ls /tmp/container-init.log"
check "fluxbox-exists" bash -c "ls -la ~/.fluxbox"

. /etc/os-release
if [ "${VERSION_CODENAME}" = "noble" ] || [ "${VERSION_CODENAME}" = "trixie" ]; then
    checkOSPackage "if libasound2-dev exists !" "libasound2-dev"
else 
    checkOSPackage "if libasound2 exists !" "libasound2"
fi

# Report result
reportResults


================================================
FILE: test/desktop-lite/test_vnc_resolution_as_container_env_var.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

GREEN='\033[0;32m'; NC='\033[0m'; RED='\033[0;31m'; YELLOW='\033[0;33m';

# Check if xtigervnc & noVnc processes are running after successful installation and initialization
check_process_running() {
    port=$1
    # Get process id of process running on specific port
    PID=$(lsof -i :$port | awk 'NR==2 {print $2}')
    if [ -n "$PID" ]; then
        CMD=$(ps -p $PID -o cmd --no-headers)
        echo -e "${GREEN}Command running on port $port: ${YELLOW}$CMD${NC}"
    else
        echo -e "${RED}No process found listening on port $port.${NC}"
        exit 1
    fi
}

check_w_config_resolution() {
    configResolution=$1
    actualResolution=$2

    if echo "$1" | grep -q "$2"; then 
        echo -e "\nğŸ‘ğŸ‘ ${GREEN}Configured resolution i.e. ${YELLOW}$configResolution${GREEN} has been set as vnc resolution i.e. ${YELLOW}$actualResolution${GREEN} in container.${NC}"
    else 
        echo -e "\nâŒâŒ ${GREEN}Configured resolution i.e. ${YELLOW}$configResolution${GREEN} couldn't be set as vnc resolution i.e. ${YELLOW}$actualResolution${GREEN} in container.${NC}"
    fi
}

check "Whether xtigervnc is Running" check_process_running 5901
resolution=$(ps -x -ww | grep Xtigervnc | awk "{for(i=1;i<=NF;i++) if (\$i ~ /-geometry/) {print \$(i+1); exit}}")
check "xtigervnc resolution" bash -c '$resolution'
check_w_config_resolution $VNC_RESOLUTION $resolution 
sleep 2
check "Whether no_vnc is Running" check_process_running 6080

check "desktop-init-exists" bash -c "ls /usr/local/share/desktop-init.sh"
check "log-exists" bash -c "ls /tmp/container-init.log"
check "log file contents" bash -c "cat /tmp/container-init.log"

# Report result
reportResults


================================================
FILE: test/desktop-lite/test_vnc_resolution_as_remote_env_var.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check if xtigervnc & noVnc processes are running after successful installation and initialization
check_process_running() {
    port=$1
    # Get process id of process running on specific port
    PID=$(lsof -i :$port | awk 'NR==2 {print $2}')
    GREEN='\033[0;32m'; NC='\033[0m'; RED='\033[0;31m'; YELLOW='\033[0;33m';
    if [ -n "$PID" ]; then
        CMD=$(ps -p $PID -o cmd --no-headers)
        echo -e "${GREEN}Command running on port $port: ${YELLOW}$CMD${NC}"
    else
        echo -e "${RED}No process found listening on port $port.${NC}"
        exit 1
    fi
}

check "Whether xtigervnc is Running" check_process_running 5901
check "xtigervnc resolution" bash -c 'ps -x -ww | grep Xtigervnc | awk "{for(i=1;i<=NF;i++) if (\$i ~ /-geometry/) {print \$(i+1); exit}}"' 
sleep 2
check "Whether no_vnc is Running" check_process_running 6080

check "desktop-init-exists" bash -c "ls /usr/local/share/desktop-init.sh"
check "log-exists" bash -c "ls /tmp/container-init.log"
check "log file contents" bash -c "cat /tmp/container-init.log"

# Report result
reportResults


================================================
FILE: test/desktop-lite/test_xtigervnc_novnc_started.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check if xtigervnc & noVnc processes are running after successful installation and initialization
check_process_running() {
    port=$1
    # Get process id of process running on specific port
    PID=$(lsof -i :$port | awk 'NR==2 {print $2}')
    if [ -n "$PID" ]; then
        CMD=$(ps -p $PID -o cmd --no-headers)
        GREEN='\033[0;32m'; NC='\033[0m'; RED='\033[0;31m'; YELLOW='\033[0;33m';
        echo -e "${GREEN}Command running on port $port: ${YELLOW}$CMD${NC}"
    else
        echo -e "${RED}No process found listening on port $port.${NC}"
    fi
}

check "Whether xtigervnc is Running" check_process_running 5901
sleep 1
check "Whether no_vnc is Running" check_process_running 6080

check "desktop-init-exists" bash -c "ls /usr/local/share/desktop-init.sh"
check "log-exists" bash -c "ls /tmp/container-init.log"
check "log file contents" bash -c "cat /tmp/container-init.log"

# Report result
reportResults


================================================
FILE: test/desktop-lite/test_xtigervnc_novnc_started_noVNC_old_launch_script.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check if xtigervnc & noVnc processes are running after successful installation and initialization
check_process_running() {
    port=$1
    # Get process id of process running on specific port
    PID=$(lsof -i :$port | awk 'NR==2 {print $2}')
    if [ -n "$PID" ]; then
        CMD=$(ps -p $PID -o cmd --no-headers)
        GREEN='\033[0;32m'; NC='\033[0m'; RED='\033[0;31m'; YELLOW='\033[0;33m';
        echo -e "${GREEN}Command running on port $port: ${YELLOW}$CMD${NC}"
    else
        echo -e "${RED}No process found listening on port $port.${NC}"
    fi
}

check "Whether xtigervnc is Running" check_process_running 5901
sleep 1
check "Whether no_vnc is Running" check_process_running 6080

check "desktop-init-exists" bash -c "ls /usr/local/share/desktop-init.sh"
check "log-exists" bash -c "ls /tmp/container-init.log"
check "log file contents" bash -c "cat /tmp/container-init.log"

# Report result
reportResults





================================================
FILE: test/desktop-lite/test_xtigervnc_novnc_started_trixie.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check if xtigervnc & noVnc processes are running after successful installation and initialization
check_process_running() {
    port=$1
    # Get process id of process running on specific port
    PID=$(lsof -i :$port | awk 'NR==2 {print $2}')
    if [ -n "$PID" ]; then
        CMD=$(ps -p $PID -o cmd --no-headers)
        GREEN='\033[0;32m'; NC='\033[0m'; RED='\033[0;31m'; YELLOW='\033[0;33m';
        echo -e "${GREEN}Command running on port $port: ${YELLOW}$CMD${NC}"
    else
        echo -e "${RED}No process found listening on port $port.${NC}"
    fi
}

check "Whether xtigervnc is Running" check_process_running 5901
sleep 1
check "Whether no_vnc is Running" check_process_running 6080

check "desktop-init-exists" bash -c "ls /usr/local/share/desktop-init.sh"
check "log-exists" bash -c "ls /tmp/container-init.log"
check "log file contents" bash -c "cat /tmp/container-init.log"

# Report result
reportResults


================================================
FILE: test/docker-in-docker/azureDnsAutoDetectionDisabled.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "dns flag should not be present" test ! "$(ps -ax | grep -v grep | grep -E 'dockerd.+\-\-dns')"

# Report result
reportResults


================================================
FILE: test/docker-in-docker/azureDnsAutoDetectionEnabled.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "dns flag should be present" ps -ax | grep -v grep | grep -E "dockerd.+\-\-dns"

# Report result
reportResults


================================================
FILE: test/docker-in-docker/docker_build.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker-buildx" docker buildx version
check "docker-build" docker build ./

check "installs compose-switch" bash -c "[[ -f /usr/local/bin/compose-switch ]]"
check "docker compose" bash -c "docker compose version | grep -E '2.[0-9]+.[0-9]+'"
check "docker-compose" bash -c "docker-compose --version | grep -E '2.[0-9]+.[0-9]+'"

check "docker-buildx" bash -c "docker buildx version"
check "docker-buildx-path" bash -c "ls -la /usr/libexec/docker/cli-plugins/docker-buildx"

# Report result
reportResults



================================================
FILE: test/docker-in-docker/docker_build_2.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker-buildx" docker buildx version
check "docker-build" docker build ./
check "docker-buildx" bash -c "docker buildx version"
check "docker-buildx-path" bash -c "ls -la /usr/libexec/docker/cli-plugins/docker-buildx"

# Report result
reportResults



================================================
FILE: test/docker-in-docker/docker_build_fallback_buildx.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests before test for fallback
HL="\033[1;33m"
N="\033[0;37m"
echo -e "\nğŸ‘‰${HL} docker/buildx version as installed by docker-in-docker feature${N}"
check "docker-buildx" docker buildx version
check "docker-build" docker build ./
check "docker-buildx" bash -c "docker buildx version"
check "docker-buildx-path" bash -c "ls -la /usr/libexec/docker/cli-plugins/docker-buildx"

# Code to test the made up scenario when latest version of docker/buildx fails on wget command for fetching the artifacts
architecture="$(dpkg --print-architecture)"
case "${architecture}" in
    amd64) target_compose_arch=x86_64 ;;
    arm64) target_compose_arch=aarch64 ;;
    *)
        echo "(!) Docker in docker does not support machine architecture '$architecture'. Please use an x86-64 or ARM64 machine."
        exit 1
esac

docker_home="/usr/libexec/docker"
cli_plugins_dir="${docker_home}/cli-plugins"

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
                declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        err "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name}
    
    echo -e "\nAttempting to find latest version using Github Api."

    output=$(curl -s "$repo_url");
    message=$(echo "$output" | jq -r '.message')

    if [[ $mode != "install_from_github_api_valid" ]]; then 
        message="API rate limit exceeded"
    fi
    
    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAttempting to find latest version using Github Api Failed. Exceeded API Rate Limit."
        echo -e "\nAttempting to find latest version using Github Tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="${prev_version}"
    else 
        echo -e "\nAttempting to find latest version using Github Api Succeeded."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}

install_using_get_previous_version() {
    local url=$1
    local mode=$2
    local repo_url=$(get_github_api_repo_url "$url")
    echo -e "\n(!) Failed to fetch the latest artifacts for docker buildx v${buildx_version}..."
    get_previous_version "${url}" "${repo_url}" buildx_version "${mode}"
    buildx_file_name="buildx-v${buildx_version}.linux-${architecture}"
    echo -e "\nAttempting to install v${buildx_version}"
    wget https://github.com/docker/buildx/releases/download/v${buildx_version}/${buildx_file_name}
}
    
install_docker_buildx() {
    mode=$1
    echo -e "\n${HL} Creating a scenario for fallback${N}\n"

    buildx_version="0.13.xyz"
    echo "(*) Installing buildx ${buildx_version}..."
    buildx_file_name="buildx-v${buildx_version}.linux-${architecture}"
    cd /tmp

    docker_buildx_url="https://github.com/docker/buildx"
    wget https://github.com/docker/buildx/releases/download/v${buildx_version}/${buildx_file_name} || install_using_get_previous_version "${docker_buildx_url}" "${mode}"
    
    docker_home="/usr/libexec/docker"
    cli_plugins_dir="${docker_home}/cli-plugins"

    mkdir -p ${cli_plugins_dir}
    mv ${buildx_file_name} ${cli_plugins_dir}/docker-buildx
    chmod +x ${cli_plugins_dir}/docker-buildx

    chown -R "${USERNAME}:docker" "${docker_home}"
    chmod -R g+r+w "${docker_home}"
    find "${docker_home}" -type d -print0 | xargs -n 1 -0 chmod g+s
}

echo -e "\nğŸ‘‰${HL} docker-buildx version as installed by docker-in-docker test ( installing by github api ) ${N}"
install_docker_buildx "install_from_github_api_valid"

# Definition specific tests after test for fallback
check "docker-buildx" docker buildx version
check "docker-buildx" bash -c "docker buildx version"

echo -e "\nğŸ‘‰${HL} docker-buildx version as installed by docker-in-docker test ( installing by find_prev_version_from_git_tags ) ${N}"
install_docker_buildx

# Definition specific tests after test for fallback
check "docker-buildx" docker buildx version
check "docker-buildx" bash -c "docker buildx version"

# Report result
reportResults



================================================
FILE: test/docker-in-docker/docker_build_fallback_compose.sh
================================================
#!/bin/bash

# Optional: Import test library
source dev-container-features-test-lib

# Setup STDERR.
err() {
    echo "(!) $*" >&2
}

HL="\033[1;33m"
N="\033[0;37m"
echo -e "\nğŸ‘‰${HL} docker-compose version as installed by docker-in-docker feature${N}"
check "docker-compose" bash -c "docker-compose version"

architecture="$(dpkg --print-architecture)"
case "${architecture}" in
    amd64) target_compose_arch=x86_64 ;;
    arm64) target_compose_arch=aarch64 ;;
    *)
        echo "(!) Docker in docker does not support machine architecture '$architecture'. Please use an x86-64 or ARM64 machine."
        exit 1
esac

docker_compose_path="/usr/local/bin/docker-compose"
cli_plugins_dir="${docker_home}/cli-plugins"

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
                declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        err "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");

    if echo "$output" | jq -e 'type == "object"' > /dev/null; then
      message=$(echo "$output" | jq -r '.message')
      
      if [[ $message == "API rate limit exceeded"* ]]; then
            echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
            echo -e "\nAttempting to find latest version using GitHub tags."
            find_prev_version_from_git_tags prev_version "$url" "tags/v"
            declare -g ${variable_name}="${prev_version}"
       fi
    elif echo "$output" | jq -e 'type == "array"' > /dev/null; then 
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.[1].tag_name')
        declare -g ${variable_name}="${version#v}"
    fi
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases"
}

install_using_get_previous_version() {
    local url=$1
    local mode=$2
    local repo_url=$(get_github_api_repo_url "$url")
    echo -e "\n(!) Failed to fetch the latest artifacts for docker-compose v${compose_version}..."
    get_previous_version "$url" "$repo_url" compose_version "$mode"
    echo -e "\nAttempting to install v${compose_version}"
    curl -fsSL "https://github.com/docker/compose/releases/download/v${compose_version}/docker-compose-linux-${target_compose_arch}" -o ${docker_compose_path}
}

install_docker_compose() {
    mode=$1
    compose_version="2.25.xyz"
    docker_compose_url="https://github.com/docker/compose"
    echo "(*) Installing docker-compose ${compose_version}..."
    curl -fsSL "https://github.com/docker/compose/releases/download/v${compose_version}/docker-compose-linux-${target_compose_arch}" -o ${docker_compose_path} || install_using_get_previous_version "$docker_compose_url" "$mode"
}

chmod +x ${docker_compose_path}

# Download the SHA256 checksum
DOCKER_COMPOSE_SHA256="$(curl -sSL "https://github.com/docker/compose/releases/download/v${compose_version}/docker-compose-linux-${target_compose_arch}.sha256" | awk '{print $1}')"
echo "${DOCKER_COMPOSE_SHA256}  ${docker_compose_path}" > docker-compose.sha256sum
sha256sum -c docker-compose.sha256sum --ignore-missing

mkdir -p ${cli_plugins_dir}
cp ${docker_compose_path} ${cli_plugins_dir}

echo -e "\nğŸ‘‰${HL} docker-compose version as installed by docker-in-docker test ( installing by github api ) ${N}"
install_docker_compose "install_from_github_api_valid"

check "docker-compose" bash -c "docker-compose version"

echo -e "\nğŸ‘‰${HL} docker-compose version as installed by docker-in-docker test ( installing by find_prev_version_from_git_tags ) ${N}"
install_docker_compose

check "docker-compose" bash -c "docker-compose version"



================================================
FILE: test/docker-in-docker/docker_build_no_compose.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker-buildx" docker buildx version
check "docker-build" docker build ./

check "not installing compose skips docker-compose v1 install" bash -c "! type docker-compose"
check "not installing compose skips compose-switch" bash -c "[[ ! -f /usr/local/bin/compose-switch ]]"

# Report result
reportResults



================================================
FILE: test/docker-in-docker/docker_build_older.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker-buildx" docker buildx version
check "docker-build" docker build ./
check "docker-buildx" bash -c "docker buildx version"
check "docker-buildx-path" bash -c "ls -la /usr/libexec/docker/cli-plugins/docker-buildx"

# Report result
reportResults



================================================
FILE: test/docker-in-docker/docker_buildx.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker-buildx" bash -c "docker buildx version"
check "docker-buildx-path" bash -c "ls -la /usr/libexec/docker/cli-plugins/docker-buildx"

check "docker-buildx" docker buildx version
check "docker-build" docker build ./

check "installs docker-compose v1 install" bash -c "type docker-compose"
check "installs compose-switch" bash -c "[[ -f /usr/local/bin/compose-switch ]]"

# Report result
reportResults



================================================
FILE: test/docker-in-docker/docker_compose_v1.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests

check "docker-compose" bash -c "docker-compose version | grep -E '1.[0-9]+.[0-9]+'"

# Report result
reportResults



================================================
FILE: test/docker-in-docker/docker_compose_v2.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests

check "docker compose" bash -c "docker compose version | grep -E '2.[0-9]+.[0-9]+'"
check "docker-compose" bash -c "docker-compose --version | grep -E '2.[0-9]+.[0-9]+'"
check "installs compose-switch as docker-compose" bash -c "[[ -f /usr/local/bin/docker-compose ]]"
check "installs compose-switch" bash -c "[[ -f /usr/local/bin/compose-switch ]]"

# Report result
reportResults



================================================
FILE: test/docker-in-docker/docker_python_bookworm.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker-buildx" bash -c "docker buildx version"
check "docker-buildx-path" bash -c "ls -la /usr/libexec/docker/cli-plugins/docker-buildx"

check "docker-buildx" docker buildx version
check "docker-build" docker build ./

check "installs docker-compose v2 install" bash -c "type docker-compose"
check "docker compose" bash -c "docker compose version | grep -E '2.[0-9]+.[0-9]+'"
check "docker-compose" bash -c "docker-compose --version | grep -E '2.[0-9]+.[0-9]+'"

check "installs compose-switch as docker-compose" bash -c "[[ -f /usr/local/bin/docker-compose ]]"

# Report result
reportResults



================================================
FILE: test/docker-in-docker/docker_specific_moby_buildx.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib
# Definition specific tests
check "moby-buildx" bash -c "dpkg-query -W moby-buildx  | grep -E '0.14.0'"

check "docker-buildx" bash -c "docker buildx version"
check "docker-buildx-path" bash -c "ls -la /usr/libexec/docker/cli-plugins/docker-buildx"

check "docker-buildx" docker buildx version
check "docker-build" docker build ./

check "installs docker-compose v1 install" bash -c "type docker-compose"
check "installs compose-switch" bash -c "[[ -f /usr/local/bin/compose-switch ]]"

# Report result
reportResults



================================================
FILE: test/docker-in-docker/docker_with_on_create_command.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Feature specific tests
check "version" docker  --version
check "docker-ps" bash -c "docker ps"

check "docker-init-exists" bash -c "ls /usr/local/share/docker-init.sh"
check "log-exists" bash -c "ls /tmp/dockerd.log"
check "log-for-completion" bash -c "cat /tmp/dockerd.log | grep 'Daemon has completed initialization'"
check "log-contents" bash -c "cat /tmp/dockerd.log | grep 'API listen on /var/run/docker.sock'"

# Report result
reportResults


================================================
FILE: test/docker-in-docker/dockerDefaultAddressPool.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "default address pool setting set" ps -ax | grep -v grep | grep -E "dockerd.+base=192.168.0.0/16,size=24"

# Report result
reportResults


================================================
FILE: test/docker-in-docker/Dockerfile
================================================
FROM ubuntu:focal



================================================
FILE: test/docker-in-docker/dockerIp6tablesDisabledTest.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

ip6tablesCheck() {
    if command -v ip6tables > /dev/null 2>&1; then
        if ip6tables -L > /dev/null 2>&1; then
            echo "âœ”ï¸ ip6tables is enabled."
        else
            echo "âŒ ip6tables is disabled."
        fi
    else
        echo "â•ip6tables command not found. â•"
    fi
}

check "ip6tables" ip6tablesCheck
check "ip6tables check" bash -c "docker network inspect bridge"
check "docker-build" docker build ./

reportResults


================================================
FILE: test/docker-in-docker/install_on_debian_trixie.sh
================================================
#!/bin/bash

set -e

# Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker installed" bash -c "type docker"

# Report results
reportResults



================================================
FILE: test/docker-in-docker/pin_docker-ce_version_moby_false.sh
================================================
#!/bin/bash

# Optional: Import test library
source dev-container-features-test-lib

check "docker-ce" bash -c "docker --version"
check "docker-ce-cli" bash -c "docker version"

#report result
reportResults


================================================
FILE: test/docker-in-docker/scenarios.json
================================================
{
    "docker_build_fallback_compose": {
        "image": "ubuntu:noble",
        "features": {
            "docker-in-docker": {
                "version": "latest",
                "dockerDashComposeVersion": "latest"
            }
        }
    },
    "dockerIp6tablesDisabledTest": {
        "image": "ubuntu:noble",
        "features": {
            "docker-in-docker": {
                "version": "27.0.3",
                "disableIp6tables": true
            }
        }
    },
    "dockerDefaultAddressPool": {
        "image": "mcr.microsoft.com/vscode/devcontainers/javascript-node:0-18",
        "remoteUser": "node",
        "features": {
            "docker-in-docker": {
                "dockerDefaultAddressPool": "base=192.168.0.0/16,size=24"
            }
        }
    },
    "azureDnsAutoDetectionEnabled": {
        "image": "mcr.microsoft.com/vscode/devcontainers/javascript-node:0-18",
        "remoteUser": "node",
        "features": {
            "docker-in-docker": {
                "azureDnsAutoDetection": true
            }
        }
    },
    "azureDnsAutoDetectionDisabled": {
        "image": "mcr.microsoft.com/vscode/devcontainers/javascript-node:0-18",
        "remoteUser": "node",
        "features": {
            "docker-in-docker": {
                "azureDnsAutoDetection": false
            }
        }
    },
    "docker_build": {
        "image": "mcr.microsoft.com/devcontainers/javascript-node:0-18",
        "features": {
            "docker-in-docker": {
                "version": "latest",
                "moby": "false",
                "dockerDashComposeVersion": "v2"
            }
        },
        "remoteUser": "node"
    },
    "docker_build_2": {
        "image": "ubuntu:noble",
        "features": {
            "docker-in-docker": {
                "version": "latest",
                "installDockerBuildx": true,
                "moby": "false",
                "dockerDashComposeVersion": "v2"
            }
        }
    },
    "docker_build_older": {
        "image": "mcr.microsoft.com/devcontainers/javascript-node:0-18",
        "features": {
            "docker-in-docker": {
                "version": "20",
                "moby": "false",
                "dockerDashComposeVersion": "v2"
            }
        },
        "remoteUser": "node"
    },
    "docker_build_no_compose": {
        "image": "mcr.microsoft.com/devcontainers/javascript-node:0-18",
        "features": {
            "docker-in-docker": {
                "dockerDashComposeVersion": "none"
            }
        },
        "remoteUser": "node"
    },
    "docker_buildx": {
        "image": "mcr.microsoft.com/devcontainers/base:bookworm",
        "features": {
            "docker-in-docker": {
                "moby": false,
                "installDockerBuildx": true
            }
        }
    },
    "docker_python_bookworm": {
        "image": "mcr.microsoft.com/devcontainers/base:bookworm",
        "features": {
            "docker-in-docker": {
                "moby": true,
                "installDockerBuildx": true,
                "dockerDashComposeVersion": "v2"
            }
        }
    },
    "docker_compose_v1": {
        "image": "mcr.microsoft.com/devcontainers/base:noble",
        "features": {
            "docker-in-docker": {
                "moby": true,
                "installDockerBuildx": true,
                "dockerDashComposeVersion": "v1"
            }
        }
    },
    "docker_compose_v2": {
        "image": "mcr.microsoft.com/devcontainers/base:noble",
        "features": {
            "docker-in-docker": {
                "moby": true,
                "installDockerBuildx": true,
                "dockerDashComposeVersion": "v2"
            }
        }
    },
    "docker_build_fallback_buildx": {
        "image": "ubuntu:noble",
        "features": {
            "docker-in-docker": {
                "version": "latest",
                "installDockerBuildx": true
            }
        }
    },
    "install_on_debian_trixie": {
        "image": "debian:trixie",
        "features": {
            "docker-in-docker": {
                "moby": false
            }
        }
    },
    "docker_specific_moby_buildx": {
        "image": "ubuntu:noble",
        "features": {
            "docker-in-docker": {
                "mobyBuildxVersion": "0.14.0"
            }
        }
    },
    "pin_docker-ce_version_moby_false": {
        "image": "mcr.microsoft.com/devcontainers/base:debian",
        "features": {
            "docker-in-docker": {
                "version": "28.4.0",
                "moby": "false",
                "mobyBuildxVersion": "latest",
                "dockerDashComposeVersion": "none",
                "azureDnsAutoDetection": "true",
                "dockerDefaultAddressPool": "",
                "installDockerBuildx": "true",
                "installDockerComposeSwitch": "true",
                "disableIp6tables": "false"
            }
        }
    },
    // DO NOT REMOVE: This scenario is used by the docker-in-docker-stress-test workflow
    "docker_with_on_create_command": {
        "image": "mcr.microsoft.com/devcontainers/base:debian",
        "features": {
            "docker-in-docker": {
                "version": "latest",
                "moby": "false"
            }
        },
        "remoteUser": "vscode",
        "onCreateCommand": "docker ps && sleep 5s && docker ps"
    }
}



================================================
FILE: test/docker-in-docker/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Feature specific tests
check "version" docker  --version
check "docker-init-exists" bash -c "ls /usr/local/share/docker-init.sh"
check "docker-ps" bash -c "docker ps"
check "log-exists" bash -c "ls /tmp/dockerd.log"
check "log-for-completion" bash -c "cat /tmp/dockerd.log | grep 'Daemon has completed initialization'"
check "log-contents" bash -c "cat /tmp/dockerd.log | grep 'API listen on /var/run/docker.sock'"
check "moby-buildx" bash -c "dpkg-query -W moby-buildx"

# Report result
reportResults


================================================
SYMLINK: test/docker-in-docker/install_moby_on_debian_trixie.sh -> install_on_debian_trixie.sh
================================================



================================================
FILE: test/docker-outside-of-docker/docker_build.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker-buildx" docker buildx version
check "docker-build" docker build ./

check "installs docker-compose v1 install" bash -c "type docker-compose"

# Report result
reportResults



================================================
FILE: test/docker-outside-of-docker/docker_build_compose_fallback.sh
================================================
#!/bin/bash

# Optional: Import test library
source dev-container-features-test-lib

echo -e "\nğŸ‘‰ Checking version of compose-switch installed as docker-compose as installed by feature";
check "installs compose-switch as docker-compose" bash -c "[[ -f /usr/local/bin/docker-compose ]]"

trap 'echo "Last executed command failed at line ${LINENO}"' ERR

# Fetch host/container arch.
architecture="$(dpkg --print-architecture)"

sudo mkdir -p /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name}
    output=$(curl -s "$repo_url");
    check_packages jq
    if echo "$output" | jq -e 'type == "object"' > /dev/null; then
        message=$(echo "$output" | jq -r '.message')
        if [[ $message == "API rate limit exceeded"* ]] || [[ $mode == 'mode1' ]]; then
            echo -e "\nAn attempt to find previous to latest version using GitHub Api Failed... \nReason: ${message}"
            echo -e "\nAttempting to find previous to latest version using GitHub tags."
            find_prev_version_from_git_tags prev_version "$url" "tags/v"
            declare -g ${variable_name}="${prev_version}"
        fi
    elif echo "$output" | jq -e 'type == "array"' > /dev/null; then
        echo -e "\nAttempting to find previous version using GitHub Api."
        version=$(echo "$output" | jq -r '.[1].tag_name')
        declare -g ${variable_name}="${version#v}"
    fi
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases"
}

install_compose_switch_fallback() {
    compose_switch_url=$1
    mode=$2
    repo_url=$(get_github_api_repo_url "${compose_switch_url}")
    echo -e "\n(!) Failed to fetch the latest artifacts for compose-switch v${compose_switch_version}..."
    get_previous_version "${compose_switch_url}" "${repo_url}" compose_switch_version $mode
    echo -e "\nAttempting to install v${compose_switch_version}"
    sudo curl -fsSL "https://github.com/docker/compose-switch/releases/download/v${compose_switch_version}/docker-compose-linux-${architecture}" -o /usr/local/bin/docker-compose
}

install_compose-switch_as_docker-compose() {
    mode=$1
    echo "(*) Installing compose-switch as docker-compose..."
    compose_switch_version="1.0.6"
    compose_switch_url="https://github.com/docker/compose-switch"
    sudo curl -fsSL "https://github.com/docker/compose-switch/releases/download/v${compose_switch_version}/docker-compose-linux-${architecture}" -o /usr/local/bin/docker-compose || install_compose_switch_fallback "${compose_switch_url}" $mode
    sudo chmod +x /usr/local/bin/docker-compose
}

echo -e "\nğŸ‘‰ Trying to install compose-switch as docker-compose using mode 1 ( find_prev_version_from_git_tags method )";
install_compose-switch_as_docker-compose "mode1"
check "installs compose-switch as docker-compose mode 1" bash -c "[[ -f /usr/local/bin/docker-compose ]]"
check "docker-compose version" bash -c "docker-compose version"

echo -e "\nğŸ‘‰ Trying to install compose-switch as docker-compose using mode 2 ( GitHub Api )";
install_compose-switch_as_docker-compose "mode2"
check "installs compose-switch as docker-compose mode 2" bash -c "[[ -f /usr/local/bin/docker-compose ]]"
check "docker-compose version" bash -c "docker-compose version"


================================================
FILE: test/docker-outside-of-docker/docker_build_no_buildx.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "no buildx" bash -c "docker buildx version 2>&1 | grep 'not a docker command'"
check "docker-build" docker build ./

# Report result
reportResults



================================================
FILE: test/docker-outside-of-docker/docker_build_no_compose.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker-buildx" docker buildx version
check "docker-build" docker build ./

check "not installing compose skips docker-compose v1 install" bash -c "! type docker-compose"

# Report result
reportResults



================================================
FILE: test/docker-outside-of-docker/docker_dash_compose_v1.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker compose" bash -c "docker compose version | grep -E '2.[0-9]+.[0-9]+'"
check "docker-compose" bash -c "docker-compose --version | grep -E '1.[0-9]+.[0-9]+'"

# Report result
reportResults



================================================
FILE: test/docker-outside-of-docker/docker_dash_compose_v2.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker compose" bash -c "docker compose version | grep -E '2.[0-9]+.[0-9]+'"
check "docker-compose" bash -c "docker-compose --version | grep -E '2.[0-9]+.[0-9]+'"

check "installs compose-switch as docker-compose" bash -c "[[ -f /usr/local/bin/docker-compose ]]"

# Report result
reportResults



================================================
FILE: test/docker-outside-of-docker/docker_init.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "docker buildx" bash -c "docker buildx version"
check "docker compose" bash -c "docker compose version"
check "docker-compose" bash -c "docker-compose --version"

check "docker-init-exists" bash -c "ls /usr/local/share/docker-init.sh"
check "log-exists" bash -c "ls /tmp/vscr-docker-from-docker.log"
check "log-contents-for-success" bash -c "cat /tmp/vscr-docker-from-docker.log | grep 'Success'"

check "log-contents" bash -c "cat /tmp/vscr-docker-from-docker.log | grep 'Ensuring vscode has access to /var/run/docker-host.sock via /var/run/docker.sock'"
check "docker-ps" bash -c "docker ps >/dev/null"

# Report result
reportResults


================================================
FILE: test/docker-outside-of-docker/docker_install_compose_switch.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check if compose-switch is installed
check_compose_switch_installation() {
    COMPOSE_SWITCH_BINARY="/usr/local/bin/compose-switch"
    # Check if the binary exists
    if [ ! -x "$COMPOSE_SWITCH_BINARY" ]; then
        echo "compose-switch binary not found at $COMPOSE_SWITCH_BINARY"
        exit 1
    else 
        compose_switch_version=$("$COMPOSE_SWITCH_BINARY" --version | awk '{print $4}')
        if [ -z "$compose_switch_version" ]; then
            echo "Unable to determine compose-switch version"
        else
            echo "compose-switch version: $compose_switch_version"
            echo -e "\nâœ… compose-switch is installed"
        fi
    fi
}

check "Check whether compose-switch is installed" check_compose_switch_installation

reportResults
 


================================================
FILE: test/docker-outside-of-docker/docker_not_install_compose_switch.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check if compose-switch is installed
check_compose_switch_installation() {
    COMPOSE_SWITCH_BINARY="/usr/local/bin/compose-switch"
    # Check if the binary exists
    if [ ! -x "$COMPOSE_SWITCH_BINARY" ]; then
        echo "compose-switch binary not found at $COMPOSE_SWITCH_BINARY"
        echo -e "\nâ compose-switch is not installed"
    else 
        compose_switch_version=$("$COMPOSE_SWITCH_BINARY" --version | awk '{print $4}')
        if [ -z "$compose_switch_version" ]; then
            echo "Unable to determine compose-switch version"
        else
            echo "compose-switch version: $compose_switch_version"
        fi
        exit 1
    fi
}

check "Check whether compose-switch is installed" check_compose_switch_installation

reportResults
 


================================================
FILE: test/docker-outside-of-docker/docker_python_bookworm.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker-buildx" bash -c "docker buildx version"
check "docker-buildx-path" bash -c "ls -la /usr/libexec/docker/cli-plugins/docker-buildx"

check "docker-buildx" docker buildx version
check "docker-build" docker build ./

check "installs docker-compose v2 install" bash -c "type docker-compose"
check "docker compose" bash -c "docker compose version | grep -E '2.[0-9]+.[0-9]+'"
check "docker-compose" bash -c "docker-compose --version | grep -E '2.[0-9]+.[0-9]+'"

check "installs compose-switch as docker-compose" bash -c "[[ -f /usr/local/bin/docker-compose ]]"

# Report result
reportResults


================================================
FILE: test/docker-outside-of-docker/docker_specific_moby_buildx.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib
# Definition specific tests
check "moby-buildx" bash -c "dpkg-query -W moby-buildx  | grep -E '0.14.0'"

check "docker-buildx" bash -c "docker buildx version"
check "docker-buildx-path" bash -c "ls -la /usr/libexec/docker/cli-plugins/docker-buildx"

check "docker-buildx" docker buildx version
check "docker-build" docker build ./

check "installs docker-compose v1 install" bash -c "type docker-compose"

# Report result
reportResults



================================================
FILE: test/docker-outside-of-docker/Dockerfile
================================================
FROM ubuntu:jammy



================================================
FILE: test/docker-outside-of-docker/install_on_debian_trixie.sh
================================================
#!/bin/bash

set -e

# Import test library
source dev-container-features-test-lib

# Definition specific tests
check "docker installed" bash -c "type docker"

# Report results
reportResults



================================================
FILE: test/docker-outside-of-docker/scenarios.json
================================================
{
    "docker_build_compose_fallback": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "moby": false,
                "dockerDashComposeVersion": "latest"
            }
        },
        "containerUser": "vscode"
    },
    "docker_init_moby": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "moby": true
            }
        },
        "containerUser": "vscode"
    },
    "docker_init": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "moby": false
            }
        },
        "containerUser": "vscode"
    },
    "docker_init_ubuntu_22": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-22.04",
        "features": {
            "docker-outside-of-docker": {
                "moby": false
            }
        },
        "containerUser": "vscode"
    },
    "docker_init_debian": {
        "image": "mcr.microsoft.com/devcontainers/base:debian",
        "features": {
            "docker-outside-of-docker": {
                "moby": false
            }
        },
        "containerUser": "vscode"
    },
    "docker_build": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "moby": false,
                "dockerDashComposeVersion": "v2"
            }
        },
        "containerUser": "vscode"
    },
    "docker_build_moby": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "moby": true
            }
        },
        "containerUser": "vscode"
    },
    "docker_build_no_buildx": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "version": "26",
                "moby": false,
                "installDockerBuildx": false
            }
        },
        "containerUser": "vscode"
    },
    "docker_build_no_buildx_moby": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "version": "26",
                "moby": true,
                "installDockerBuildx": false
            }
        },
        "containerUser": "vscode"
    },
    "docker_dash_compose_v1": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "moby": false,
                "dockerDashComposeVersion": "v1"
            }
        },
        "containerUser": "vscode"
    },
    "docker_dash_compose_v1_moby": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "moby": true,
                "dockerDashComposeVersion": "v1"
            }
        },
        "containerUser": "vscode"
    },
    "docker_dash_compose_v2": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "moby": false,
                "dockerDashComposeVersion": "v2"
            }
        },
        "containerUser": "vscode"
    },
    "docker_dash_compose_v2_moby": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "moby": true,
                "dockerDashComposeVersion": "v2"
            }
        },
        "containerUser": "vscode"
    },
    "docker_build_no_compose": {
        "image": "mcr.microsoft.com/devcontainers/javascript-node:0-18",
        "features": {
            "docker-in-docker": {
                "dockerDashComposeVersion": "none"
            }
        },
        "remoteUser": "node"
    },
    "docker_specific_moby_buildx": {
        "image": "ubuntu:noble",
        "features": {
            "docker-outside-of-docker": {
                "mobyBuildxVersion": "0.14.0"
            }
        }
    },
    "docker_python_bookworm": {
        "image": "mcr.microsoft.com/devcontainers/base:bookworm",
        "features": {
            "docker-outside-of-docker": {
                "moby": true,
                "installDockerBuildx": true,
                "dockerDashComposeVersion": "v2"
            }
        }
    },
    "docker_not_install_compose_switch": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "dockerDashComposeVersion": "latest",
                "installDockerComposeSwitch": false
            }
        },
        "containerUser": "vscode"
    },
    "docker_install_compose_switch": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "features": {
            "docker-outside-of-docker": {
                "dockerDashComposeVersion": "latest",
                "installDockerComposeSwitch": true
            }
        },
        "containerUser": "vscode"
    },
    "install_on_debian_trixie": {
        "image": "debian:trixie",
        "features": {
            "docker-outside-of-docker": {
                "moby": false
            }
        }
    }
}



================================================
FILE: test/docker-outside-of-docker/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "docker buildx" bash -c "docker buildx version"
check "docker compose" bash -c "docker compose version"
check "docker-compose" bash -c "docker-compose --version"

check "docker-ps" bash -c "docker ps >/dev/null"
check "moby-buildx" bash -c "dpkg-query -W moby-buildx"

# Report result
reportResults


================================================
SYMLINK: test/docker-outside-of-docker/docker_build_moby.sh -> docker_build.sh
================================================



================================================
SYMLINK: test/docker-outside-of-docker/docker_build_no_buildx_moby.sh -> docker_build_no_buildx.sh
================================================



================================================
SYMLINK: test/docker-outside-of-docker/docker_dash_compose_v1_moby.sh -> docker_dash_compose_v1.sh
================================================



================================================
SYMLINK: test/docker-outside-of-docker/docker_dash_compose_v2_moby.sh -> docker_dash_compose_v2.sh
================================================



================================================
SYMLINK: test/docker-outside-of-docker/docker_init_debian.sh -> docker_init.sh
================================================



================================================
SYMLINK: test/docker-outside-of-docker/docker_init_moby.sh -> docker_init.sh
================================================



================================================
SYMLINK: test/docker-outside-of-docker/docker_init_ubuntu_22.sh -> docker_init.sh
================================================



================================================
SYMLINK: test/docker-outside-of-docker/install_moby_on_debian_trixie.sh -> install_on_debian_trixie.sh
================================================



================================================
FILE: test/dotnet/dotnet_env.sh
================================================
#!/bin/bash
export DOTNET_NOLOGO=true
export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=true
export DOTNET_GENERATE_ASPNET_CERTIFICATE=false


================================================
FILE: test/dotnet/dotnet_helpers.sh
================================================
#!/bin/bash

# Prints the latest dotnet version in the specified channel
# Usage: fetch_latest_version_in_channel <channel> [<runtime>]
# Example: fetch_latest_version_in_channel "LTS"
# Example: fetch_latest_version_in_channel "6.0" "dotnet"
# Example: fetch_latest_version_in_channel "6.0" "aspnetcore"
fetch_latest_version_in_channel() {
    local channel="$1"
    local runtime="$2"
    if [ "$runtime" = "dotnet" ]; then
        wget -qO- "https://builds.dotnet.microsoft.com/dotnet/Runtime/$channel/latest.version"
    elif [ "$runtime" = "aspnetcore" ]; then
        wget -qO- "https://builds.dotnet.microsoft.com/dotnet/aspnetcore/Runtime/$channel/latest.version"
    else
        wget -qO- "https://builds.dotnet.microsoft.com/dotnet/Sdk/$channel/latest.version"
    fi
}

# Prints the latest dotnet version
# Usage: fetch_latest_version [<runtime>]
# Example: fetch_latest_version
# Example: fetch_latest_version "dotnet"
# Example: fetch_latest_version "aspnetcore"
fetch_latest_version() {
    local runtime="$1"
    local sts_version
    local lts_version
    sts_version=$(fetch_latest_version_in_channel "STS" "$runtime")
    lts_version=$(fetch_latest_version_in_channel "LTS" "$runtime")
    if [[ "$sts_version" > "$lts_version" ]]; then
        echo "$sts_version"
    else
        echo "$lts_version"
    fi
}

# Asserts that the specified .NET SDK version is installed
# Returns a non-zero exit code if the check fails
# Usage: is_dotnet_sdk_version_installed <version>
# Example: is_dotnet_sdk_version_installed "6.0"
# Example: is_dotnet_sdk_version_installed "6.0.412"
is_dotnet_sdk_version_installed() {
    local expected="$1"
    dotnet --list-sdks | grep --fixed-strings --silent "$expected"
    return $?
}

# Asserts that the specified .NET Runtime version is installed
# Returns a non-zero exit code if the check fails
# Usage: is_dotnet_runtime_version_installed <version>
# Example: is_dotnet_runtime_version_installed "6.0"
# Example: is_dotnet_runtime_version_installed "6.0.412"
is_dotnet_runtime_version_installed() {
    local expected="$1"
    dotnet --list-runtimes | grep --fixed-strings --silent "Microsoft.NETCore.App $expected"
    return $?
}

# Asserts that the specified ASP.NET Core Runtime version is installed
# Returns a non-zero exit code if the check fails
# Usage: is_aspnetcore_runtime_version_installed <version>
# Example: is_aspnetcore_runtime_version_installed "6.0"
# Example: is_aspnetcore_runtime_version_installed "6.0.412"
is_aspnetcore_runtime_version_installed() {
    local expected="$1"
    dotnet --list-runtimes | grep --fixed-strings --silent "Microsoft.AspNetCore.App $expected"
    return $?
}

# Asserts that the specified workload is installed
# Returns a non-zero exit code if the check fails
# Usage: is_dotnet_workload_installed <workload_id>
# Example: is_dotnet_workload_installed "aspire"
is_dotnet_workload_installed() {
    local expected="$1"
    dotnet workload list | grep --fixed-strings --silent "$expected"
    return $?
}



================================================
FILE: test/dotnet/install_aspnetcore_runtime_only.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

expected=$(fetch_latest_version "aspnetcore")

check "Latest ASP.NET Core Runtime version installed" \
is_aspnetcore_runtime_version_installed "$expected"

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults


================================================
FILE: test/dotnet/install_dotnet_daily.sh
================================================
#!/bin/bash

set -e

source dev-container-features-test-lib
source dotnet_env.sh
source dotnet_helpers.sh

# Verify 10.0 SDK (any prerelease containing '10.0') is installed
check ".NET SDK 10.0 installed" \
is_dotnet_sdk_version_installed "10.0"

check ".NET Runtime 10.0 installed" \
is_dotnet_runtime_version_installed "10.0"

check "ASP.NET Core Runtime 10.0 installed" \
is_aspnetcore_runtime_version_installed "10.0"

check "Build and run .NET 10.0 project" \
dotnet run --project projects/net10.0

reportResults



================================================
FILE: test/dotnet/install_dotnet_exact_version.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

check ".NET SDK 8.0.100-preview.6.23330.14 installed" \
is_dotnet_sdk_version_installed "8.0.100-preview.6.23330.14"

check "Build and run example project" \
dotnet run --project projects/net8.0 

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults


================================================
FILE: test/dotnet/install_dotnet_global_tool.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

# From https://learn.microsoft.com/en-us/dotnet/core/tools/global-tools
check "Install a .NET global tool" \
dotnet tool install --global dotnetsay

check "Run the tool" \
dotnetsay "$(dotnet --info)"

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults


================================================
FILE: test/dotnet/install_dotnet_latest_when_version_is_empty.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

expected=$(fetch_latest_version)

check "Latest .NET SDK version installed" \
is_dotnet_sdk_version_installed "$expected"

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults


================================================
FILE: test/dotnet/install_dotnet_lts.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

expected=$(fetch_latest_version_in_channel "LTS")

check "Latest LTS version installed" \
is_dotnet_sdk_version_installed "$expected"

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults


================================================
FILE: test/dotnet/install_dotnet_multiple_versions.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

check ".NET SDK 9.0 installed" \
is_dotnet_sdk_version_installed "9.0"

check ".NET SDK 8.0 installed" \
is_dotnet_sdk_version_installed "8.0"

check ".NET SDK 7.0 installed" \
is_dotnet_sdk_version_installed "7.0"

check ".NET SDK 10.0 installed" \
is_dotnet_sdk_version_installed "10.0"

check "Build example class library" \
dotnet build projects/multitargeting

check "Build and run .NET 9.0 project" \
dotnet run --project projects/net9.0

check "Build and run .NET 8.0 project" \
dotnet run --project projects/net8.0

check "Build and run .NET 7.0 project" \
dotnet run --project projects/net7.0

check "Build and run .NET 10.0 project" \
dotnet run --project projects/net10.0

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults


================================================
FILE: test/dotnet/install_dotnet_preview.sh
================================================
#!/bin/bash

set -e

source dev-container-features-test-lib
source dotnet_env.sh
source dotnet_helpers.sh

# Verify 10.0 SDK (any prerelease containing '10.0') is installed
check ".NET SDK 10.0 installed" \
is_dotnet_sdk_version_installed "10.0"

check ".NET Runtime 10.0 installed" \
is_dotnet_runtime_version_installed "10.0"

check "ASP.NET Core Runtime 10.0 installed" \
is_aspnetcore_runtime_version_installed "10.0"

check "Build and run .NET 10.0 project" \
dotnet run --project projects/net10.0

reportResults



================================================
FILE: test/dotnet/install_dotnet_runtime_only.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

expected=$(fetch_latest_version "dotnet")

check "Latest .NET Runtime version installed" \
is_dotnet_runtime_version_installed "$expected"

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults


================================================
FILE: test/dotnet/install_dotnet_specific_release.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

expected=$(fetch_latest_version_in_channel "8.0")

check ".NET Core SDK 8.0 installed" \
is_dotnet_sdk_version_installed "$expected"

check "Build and run example project" \
dotnet run --project projects/net8.0 

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults


================================================
FILE: test/dotnet/install_dotnet_specific_release_and_feature_band.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

check ".NET SDK 8.0.3xx installed" \
is_dotnet_sdk_version_installed "8.0.3"

check "Build and run example project" \
dotnet run --project projects/net8.0 

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults


================================================
FILE: test/dotnet/install_dotnet_workloads.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

check "Aspire is installed" \
is_dotnet_workload_installed "aspire"

check "WASM tools are installed" \
is_dotnet_workload_installed "wasm-tools"

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults



================================================
FILE: test/dotnet/scenarios.json
================================================
{
    "install_dotnet_lts": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {
                "version": "lts"
            }
        }
    },
    "install_dotnet_specific_release": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {
                "version": "8.0"
            }
        }
    },
    "install_dotnet_specific_release_and_feature_band": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-24.04",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {
                "version": "8.0.3xx"
            }
        }
    },
    "install_dotnet_exact_version": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {
                "version": "8.0.100-preview.6.23330.14"
            }
        }
    },
    "install_dotnet_multiple_versions": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {
                "version": "10.0",
                "additionalVersions": [
                    "9.0",
                    "8.0",
                    "7.0"
                ]
            }
        }
    },
    "install_dotnet_preview": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {
                "version": "10.0-preview",
                "additionalVersions": "10.0.1xx-preview",
                "aspnetcoreRuntimeVersions": "10.0-preview",
                "dotnetRuntimeVersions": "10.0-preview"
            }
        }
    },
    "install_dotnet_daily": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {
                "version": "10.0-daily",
                "additionalVersions": "10.0.1xx-daily",
                "aspnetcoreRuntimeVersions": "10.0-daily",
                "dotnetRuntimeVersions": "10.0-daily"
            }
        }
    },
    "install_dotnet_global_tool": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {}
        }
    },
    "install_dotnet_latest_when_version_is_empty": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "dotnet": ""
        }
    },
    "install_dotnet_runtime_only": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {
                "version": "none",
                "dotnetRuntimeVersions": "latest"
            }
        }
    },
    "install_aspnetcore_runtime_only": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {
                "version": "none",
                "aspnetcoreRuntimeVersions": "latest"
            }
        }
    },
    "install_dotnet_workloads": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "dotnet": {
                "version": "latest",
                "workloads": "aspire, wasm-tools"
            }
        }
    }
}


================================================
FILE: test/dotnet/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library bundled with the devcontainer CLI
# See https://github.com/devcontainers/cli/blob/HEAD/docs/features/test.md#dev-container-features-test-lib
# Provides the 'check' and 'reportResults' commands.
source dev-container-features-test-lib

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib. Syntax is...
# check <LABEL> <cmd> [args...]
source dotnet_env.sh
source dotnet_helpers.sh

check "dotnet is installed in DOTNET_ROOT and execute permission is granted" \
test -x "$DOTNET_ROOT/dotnet" 

check "dotnet is symlinked correctly in /usr/bin" \
test -L /usr/bin/dotnet -a "$(readlink -f /usr/bin/dotnet)" = "$DOTNET_ROOT/dotnet"

expected=$(fetch_latest_version)

check "Latest .NET SDK version installed" \
is_dotnet_sdk_version_installed "$expected"

# Report results
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults


================================================
FILE: test/dotnet/projects/multitargeting/Class1.cs
================================================
ï»¿public class Class1
{

}



================================================
FILE: test/dotnet/projects/multitargeting/example_classlib.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0</TargetFrameworks>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>



================================================
FILE: test/dotnet/projects/net10.0/example_project.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

</Project>


================================================
FILE: test/dotnet/projects/net10.0/Program.cs
================================================
ï»¿using Newtonsoft.Json;

string json = """
{
  "Name": "Inception",
  "ReleaseDate": "2010-07-08T00:00:00",
  "Genres": [
    "Action",
    "Thriller"
  ]
}
""";

Movie? m = JsonConvert.DeserializeObject<Movie>(json);

if (m == default)
{
    Console.WriteLine("Decoding failed!");
}
else
{
    Console.WriteLine($"Movie name: {m.Name}");
    Console.WriteLine($"Release Date: {m.ReleaseDate}");
    Console.WriteLine($"Genres: {string.Join(", ", m.Genres)}");
}

class Movie(string? name, DateTime releaseDate, List<string>? genres)
{
    public string Name { get; set; } = name ?? "Default Name";
    public DateTime ReleaseDate { get; set; } = releaseDate;
    public List<string> Genres { get; set; } = genres ?? [];
}


================================================
FILE: test/dotnet/projects/net5.0/example_project.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net5.0</TargetFramework>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

</Project>


================================================
FILE: test/dotnet/projects/net5.0/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Newtonsoft.Json;

string json = @"{
  ""Name"": ""Inception"",
  ""ReleaseDate"": ""2010-07-08T00:00:00"",
  ""Genres"": [
    ""Action"",
    ""Thriller""
  ]
}";

Movie? m = JsonConvert.DeserializeObject<Movie>(json);

if (m == default)
{
    Console.WriteLine("Decoding failed!");
}
else
{
    Console.WriteLine($"Movie name: {m.Name}");
    Console.WriteLine($"Release Date: {m.ReleaseDate}");
    Console.WriteLine($"Genres: {string.Join(", ", m.Genres)}");
}

class Movie
{
    public string Name { get; set; } = "Default Name";
    public DateTime ReleaseDate { get; set; }
    public List<string> Genres { get; set; } = new List<string>();
}



================================================
FILE: test/dotnet/projects/net6.0/example_project.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

</Project>


================================================
FILE: test/dotnet/projects/net6.0/Program.cs
================================================
ï»¿using Newtonsoft.Json;

string json = @"{
  ""Name"": ""Inception"",
  ""ReleaseDate"": ""2010-07-08T00:00:00"",
  ""Genres"": [
    ""Action"",
    ""Thriller""
  ]
}";

Movie? m = JsonConvert.DeserializeObject<Movie>(json);

if (m == default)
{
    Console.WriteLine("Decoding failed!");
}
else
{
    Console.WriteLine($"Movie name: {m.Name}");
    Console.WriteLine($"Release Date: {m.ReleaseDate}");
    Console.WriteLine($"Genres: {string.Join(", ", m.Genres)}");
}

class Movie
{
    public string Name { get; set; } = "Default Name";
    public DateTime ReleaseDate { get; set; }
    public List<string> Genres { get; set; } = new List<string>();
}



================================================
FILE: test/dotnet/projects/net7.0/example_project.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

</Project>


================================================
FILE: test/dotnet/projects/net7.0/Program.cs
================================================
ï»¿using Newtonsoft.Json;

string json = @"{
  ""Name"": ""Inception"",
  ""ReleaseDate"": ""2010-07-08T00:00:00"",
  ""Genres"": [
    ""Action"",
    ""Thriller""
  ]
}";

Movie? m = JsonConvert.DeserializeObject<Movie>(json);

if (m == default)
{
    Console.WriteLine("Decoding failed!");
}
else
{
    Console.WriteLine($"Movie name: {m.Name}");
    Console.WriteLine($"Release Date: {m.ReleaseDate}");
    Console.WriteLine($"Genres: {string.Join(", ", m.Genres)}");
}

class Movie
{
    public string Name { get; set; } = "Default Name";
    public DateTime ReleaseDate { get; set; }
    public List<string> Genres { get; set; } = new List<string>();
}



================================================
FILE: test/dotnet/projects/net8.0/example_project.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

</Project>


================================================
FILE: test/dotnet/projects/net8.0/Program.cs
================================================
ï»¿using Newtonsoft.Json;

string json = """
{
  "Name": "Inception",
  "ReleaseDate": "2010-07-08T00:00:00",
  "Genres": [
    "Action",
    "Thriller"
  ]
}
""";

Movie? m = JsonConvert.DeserializeObject<Movie>(json);

if (m == default)
{
    Console.WriteLine("Decoding failed!");
}
else
{
    Console.WriteLine($"Movie name: {m.Name}");
    Console.WriteLine($"Release Date: {m.ReleaseDate}");
    Console.WriteLine($"Genres: {string.Join(", ", m.Genres)}");
}

class Movie
{
    public string Name { get; set; } = "Default Name";
    public DateTime ReleaseDate { get; set; }
    public List<string> Genres { get; set; } = new List<string>();
}



================================================
FILE: test/dotnet/projects/net9.0/example_project.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

</Project>


================================================
FILE: test/dotnet/projects/net9.0/Program.cs
================================================
ï»¿using Newtonsoft.Json;

string json = """
{
  "Name": "Inception",
  "ReleaseDate": "2010-07-08T00:00:00",
  "Genres": [
    "Action",
    "Thriller"
  ]
}
""";

Movie? m = JsonConvert.DeserializeObject<Movie>(json);

if (m == default)
{
    Console.WriteLine("Decoding failed!");
}
else
{
    Console.WriteLine($"Movie name: {m.Name}");
    Console.WriteLine($"Release Date: {m.ReleaseDate}");
    Console.WriteLine($"Genres: {string.Join(", ", m.Genres)}");
}

class Movie(string? name, DateTime releaseDate, List<string>? genres)
{
    public string Name { get; set; } = name ?? "Default Name";
    public DateTime ReleaseDate { get; set; } = releaseDate;
    public List<string> Genres { get; set; } = genres ?? [];
}


================================================
FILE: test/dotnet/projects/netcoreapp3.1/example_project.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>netcoreapp3.1</TargetFramework>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

</Project>


================================================
FILE: test/dotnet/projects/netcoreapp3.1/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Newtonsoft.Json;

class Program
{
    public static void Main()
    {
        string json = @"{
          ""Name"": ""Inception"",
          ""ReleaseDate"": ""2010-07-08T00:00:00"",
          ""Genres"": [
            ""Action"",
            ""Thriller""
          ]
        }";

        Movie? m = JsonConvert.DeserializeObject<Movie>(json);

        if (m == default)
        {
            Console.WriteLine("Decoding failed!");
        }
        else
        {
            Console.WriteLine($"Movie name: {m.Name}");
            Console.WriteLine($"Release Date: {m.ReleaseDate}");
            Console.WriteLine($"Genres: {string.Join(", ", m.Genres)}");
        }
    }
}


class Movie
{
    public string Name { get; set; } = "Default Name";
    public DateTime ReleaseDate { get; set; }
    public List<string> Genres { get; set; } = new List<string>();
}



================================================
FILE: test/git/install_git_from_ppa_bionic.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_ppa_jammy.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults




================================================
FILE: test/git/install_git_from_src.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version
check "gettext" dpkg-query -l gettext

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

check "git-location" bash -c "which git | grep /usr/local/bin/git"

check "set-git-config-user-name" bash -c "git config --system user.name devcontainers"
check "gitconfig-file-location" bash -c "ls /etc/gitconfig"
check "gitconfig-contains-name" bash -c "cat /etc/gitconfig | grep 'name = devcontainers'"

check "usr-local-etc-config-does-not-exist" test ! -f "/usr/local/etc/gitconfig"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_alma-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_alma-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_alpine.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_bionic.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version
check "gettext" dpkg-query -l gettext

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_bullseye.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version
check "gettext" dpkg-query -l gettext

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_buster.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version
check "gettext" dpkg-query -l gettext

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_centos-7.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_fedora.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_jammy.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version
check "gettext" dpkg-query -l gettext

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_mariner.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_noble.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version
check "gettext" dpkg-query -l gettext

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults




================================================
FILE: test/git/install_git_from_src_rocky-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_src_rocky-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_system_alma-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_system_alma-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_system_alpine.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter

# Report result
reportResults



================================================
FILE: test/git/install_git_from_system_centos-7.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_system_fedora.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_system_mariner.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

# Ensure git clone works, i.e. ca-certificates are installed.
check "git clone" bash -c "cd /tmp && git clone https://github.com/devcontainers/feature-starter.git"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_system_rocky-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/install_git_from_system_rocky-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

cd /tmp && git clone https://github.com/devcontainers/feature-starter.git
cd feature-starter
check "perl" bash -c "git -c grep.patternType=perl grep -q 'a.+b'"

# Report result
reportResults



================================================
FILE: test/git/scenarios.json
================================================
{
    "install_git_from_src": {
        "image": "ubuntu:noble",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_src_alpine": {
        "image": "mcr.microsoft.com/devcontainers/base:alpine",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_src_jammy": {
        "image": "ubuntu:jammy",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_ppa_jammy": {
        "image": "ubuntu:jammy",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "true"
            }
        }
    },
    "install_git_from_src_noble": {
        "image": "ubuntu:noble",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_src_bullseye": {
        "image": "debian:bullseye",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_src_centos-7": {
        "image": "centos:centos7",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_src_alma-8": {
        "image": "almalinux:8",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_src_alma-9": {
        "image": "almalinux:9",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_src_rocky-8": {
        "image": "rockylinux:8",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_src_rocky-9": {
        "image": "rockylinux:9",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_src_fedora": {
        "image": "fedora",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_src_mariner": {
        "image": "mcr.microsoft.com/cbl-mariner/base/core:2.0",
        "features": {
            "git": {
                "version": "latest",
                "ppa": "false"
            }
        }
    },
    "install_git_from_system_alpine": {
        "image": "mcr.microsoft.com/devcontainers/base:alpine",
        "features": {
            "git": {
                "version": "system",
                "ppa": "false"
            }
        }
    },
    "install_git_from_system_centos-7": {
        "image": "centos:centos7",
        "features": {
            "git": {
                "version": "system",
                "ppa": "true"
            }
        }
    },
    "install_git_from_system_alma-8": {
        "image": "almalinux:8",
        "features": {
            "git": {
                "version": "system",
                "ppa": "true"
            }
        }
    },
    "install_git_from_system_alma-9": {
        "image": "almalinux:9",
        "features": {
            "git": {
                "version": "system",
                "ppa": "true"
            }
        }
    },
    "install_git_from_system_rocky-8": {
        "image": "rockylinux:8",
        "features": {
            "git": {
                "version": "system",
                "ppa": "true"
            }
        }
    },
    "install_git_from_system_rocky-9": {
        "image": "rockylinux:9",
        "features": {
            "git": {
                "version": "system",
                "ppa": "true"
            }
        }
    },
    "install_git_from_system_fedora": {
        "image": "fedora",
        "features": {
            "git": {
                "version": "system",
                "ppa": "true"
            }
        }
    },
    "install_git_from_system_mariner": {
        "image": "mcr.microsoft.com/cbl-mariner/base/core:2.0",
        "features": {
            "git": {
                "version": "system",
                "ppa": "true"
            }
        }
    }
}



================================================
FILE: test/git/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git  --version

# Report result
reportResults



================================================
FILE: test/git-lfs/autoPullDisabled.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "target file exists" cat big-file-1.txt
check "lfs file has not been expanded" cat "big-file-1.txt" | grep "git-lfs\.github\.com"

reportResults


================================================
FILE: test/git-lfs/autoPullEnabled.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "target file exists" cat big-file-1.txt
check "lfs file has been expanded" cat "big-file-1.txt" | grep "this is test file 1"

reportResults


================================================
FILE: test/git-lfs/scenarios.json
================================================
{
    "autoPullEnabled": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "initializeCommand": "(GIT_LFS_SKIP_SMUDGE=1 git clone https://github.com/devcontainers/git-lfs-example /tmp/testRepo-1 || true) && (cp -r /tmp/testRepo-1/.git* . && cp -r /tmp/testRepo-1/* .)",
        "remoteUser": "vscode",
        "features": {
            "git-lfs": {
                "autoPull": true
            }
        }
    },
    "autoPullDisabled": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "initializeCommand": "(GIT_LFS_SKIP_SMUDGE=1 git clone https://github.com/devcontainers/git-lfs-example /tmp/testRepo-2 || true) && (cp -r /tmp/testRepo-2/.git* . && cp -r /tmp/testRepo-2/* .)",
        "remoteUser": "vscode",
        "features": {
            "git-lfs": {
                "autoPull": false
            }
        }
    },
    "use_github": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "git-lfs": {
                "version": "latest",
                "installDirectlyFromGitHubRelease": true
            }
        }
    }
}


================================================
FILE: test/git-lfs/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" git-lfs  --version

# Report result
reportResults


================================================
FILE: test/git-lfs/use_github.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "git-lfs" bash -c "git-lfs --version"

reportResults


================================================
FILE: test/github-cli/install_git_cli_from_release.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "version" gh --version

# Report result
reportResults



================================================
FILE: test/github-cli/scenarios.json
================================================
{
    "install_git_cli_from_release": {
        "image": "ubuntu:noble",
        "features": {
            "github-cli": {
                "version": "latest",
                "installDirectlyFromGitHubRelease": "false"
            }
        }
    }
}


================================================
FILE: test/github-cli/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" gh  --version

find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
    major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
    minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
    breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

    if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
        ((major=major-1))
        declare -g ${variable_name}="${major}"
        # Look for latest version from previous major release
        find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
    # Handle situations like Go's odd version pattern where "0" releases omit the last part
    elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
        ((minor=minor-1))
        declare -g ${variable_name}="${major}.${minor}"
        # Look for latest version from previous minor release
        find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
    else
        ((breakfix=breakfix-1))
        if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
            declare -g ${variable_name}="${major}.${minor}"
        else 
            declare -g ${variable_name}="${major}.${minor}.${breakfix}"
        fi
    fi
}

CLI_VERSION="2.20.0"
find_prev_version_from_git_tags CLI_VERSION https://github.com/cli/cli
check "pre-version-to-2.20.0" bash -c "echo ${CLI_VERSION} | grep '2.19.0'"

CLI_VERSION="2.18.1"
find_prev_version_from_git_tags CLI_VERSION https://github.com/cli/cli
check "pre-version-to-2.18.1" bash -c "echo ${CLI_VERSION} | grep '2.18.0'"

CLI_VERSION="2.15.0"
find_prev_version_from_git_tags CLI_VERSION https://github.com/cli/cli
check "pre-version-to-2.15.0" bash -c "echo ${CLI_VERSION} | grep '2.14.7'"

CLI_VERSION="2.0.0"
find_prev_version_from_git_tags CLI_VERSION https://github.com/cli/cli
check "pre-version-to-2.0.0" bash -c "echo ${CLI_VERSION} | grep '1.14.0'"

# Report result
reportResults


================================================
FILE: test/go/install_go_alma-8-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# go
check "version" go version

# revive
check "revive version" revive --version
check "revive is installed at correct path" bash -c "type revive | grep /go/bin/revive"

# gomodifytags
check "gomodifytags is installed at correct path" bash -c "type gomodifytags | grep /go/bin/gomodifytags"

# goplay
check "goplay is installed at correct path" bash -c "type goplay | grep /go/bin/goplay"

# gotests
check "gotests is installed at correct path" bash -c "type gotests | grep /go/bin/gotests"

# impl
check "impl is installed at correct path" bash -c "type impl | grep /go/bin/impl"

# Report result
reportResults


================================================
FILE: test/go/install_go_alma-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# go
check "version" go version

# revive
check "revive version" revive --version
check "revive is installed at correct path" bash -c "type revive | grep /go/bin/revive"

# gomodifytags
check "gomodifytags is installed at correct path" bash -c "type gomodifytags | grep /go/bin/gomodifytags"

# goplay
check "goplay is installed at correct path" bash -c "type goplay | grep /go/bin/goplay"

# gotests
check "gotests is installed at correct path" bash -c "type gotests | grep /go/bin/gotests"

# impl
check "impl is installed at correct path" bash -c "type impl | grep /go/bin/impl"

# Report result
reportResults


================================================
FILE: test/go/install_go_alma-9-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# go
check "version" go version

# revive
check "revive version" revive --version
check "revive is installed at correct path" bash -c "type revive | grep /go/bin/revive"

# gomodifytags
check "gomodifytags is installed at correct path" bash -c "type gomodifytags | grep /go/bin/gomodifytags"

# goplay
check "goplay is installed at correct path" bash -c "type goplay | grep /go/bin/goplay"

# gotests
check "gotests is installed at correct path" bash -c "type gotests | grep /go/bin/gotests"

# impl
check "impl is installed at correct path" bash -c "type impl | grep /go/bin/impl"

# Report result
reportResults


================================================
FILE: test/go/install_go_alma-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# go
check "version" go version

# revive
check "revive version" revive --version
check "revive is installed at correct path" bash -c "type revive | grep /go/bin/revive"

# gomodifytags
check "gomodifytags is installed at correct path" bash -c "type gomodifytags | grep /go/bin/gomodifytags"

# goplay
check "goplay is installed at correct path" bash -c "type goplay | grep /go/bin/goplay"

# gotests
check "gotests is installed at correct path" bash -c "type gotests | grep /go/bin/gotests"

# impl
check "impl is installed at correct path" bash -c "type impl | grep /go/bin/impl"

# Report result
reportResults


================================================
FILE: test/go/install_go_centos-7.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# go
check "version" go version

# revive
check "revive version" revive --version
check "revive is installed at correct path" bash -c "type revive | grep /go/bin/revive"

# gomodifytags
check "gomodifytags is installed at correct path" bash -c "type gomodifytags | grep /go/bin/gomodifytags"

# goplay
check "goplay is installed at correct path" bash -c "type goplay | grep /go/bin/goplay"

# gotests
check "gotests is installed at correct path" bash -c "type gotests | grep /go/bin/gotests"

# impl
check "impl is installed at correct path" bash -c "type impl | grep /go/bin/impl"

# Report result
reportResults


================================================
FILE: test/go/install_go_fedora.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# go
check "version" go version

# revive
check "revive version" revive --version
check "revive is installed at correct path" bash -c "type revive | grep /go/bin/revive"

# gomodifytags
check "gomodifytags is installed at correct path" bash -c "type gomodifytags | grep /go/bin/gomodifytags"

# goplay
check "goplay is installed at correct path" bash -c "type goplay | grep /go/bin/goplay"

# gotests
check "gotests is installed at correct path" bash -c "type gotests | grep /go/bin/gotests"

# impl
check "impl is installed at correct path" bash -c "type impl | grep /go/bin/impl"

# Report result
reportResults


================================================
FILE: test/go/install_go_mariner.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# go
check "version" go version

# revive
check "revive version" revive --version
check "revive is installed at correct path" bash -c "type revive | grep /go/bin/revive"

# gomodifytags
check "gomodifytags is installed at correct path" bash -c "type gomodifytags | grep /go/bin/gomodifytags"

# goplay
check "goplay is installed at correct path" bash -c "type goplay | grep /go/bin/goplay"

# gotests
check "gotests is installed at correct path" bash -c "type gotests | grep /go/bin/gotests"

# impl
check "impl is installed at correct path" bash -c "type impl | grep /go/bin/impl"

# Report result
reportResults


================================================
FILE: test/go/install_go_tool_in_postCreate.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "mkcert version" bash -c "mkcert --version | grep v1.4.2"
check "mkcert is installed at correct path" bash -c "which mkcert | grep /go/bin/mkcert"
check "golangci-lint version" bash -c "golangci-lint --version | grep 'golangci-lint has version 1.50.0'"

# Report result
reportResults



================================================
FILE: test/go/install_go_tool_in_postCreate_rhel.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "mkcert version" bash -c "mkcert --version | grep v1.4.2"
check "mkcert is installed at correct path" bash -c "type mkcert | grep /go/bin/mkcert"
check "golangci-lint version" bash -c "golangci-lint --version | grep 'golangci-lint has version 1.50.0'"

# Report result
reportResults



================================================
FILE: test/go/install_go_twice.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "go-version" bash -c "go version | grep 1.19"

# Report result
reportResults



================================================
FILE: test/go/scenarios.json
================================================
{
    "install_go_alma-8": {
        "image": "almalinux:8",
        "features": {
            "go": {
                "version": "latest",
                "golangciLintVersion": "1.50.0"
            }
        }
    },
    "install_go_alma-8-minimal": {
        "image": "almalinux:8-minimal",
        "features": {
            "go": {
                "version": "latest",
                "golangciLintVersion": "1.50.0"
            }
        }
    },
    "install_go_alma-9": {
        "image": "almalinux:9",
        "features": {
            "go": {
                "version": "latest",
                "golangciLintVersion": "1.50.0"
            }
        }
    },
    "install_go_alma-9-minimal": {
        "image": "almalinux:9-minimal",
        "features": {
            "go": {
                "version": "latest",
                "golangciLintVersion": "1.50.0"
            }
        }
    },
    "install_go_centos-7": {
        "image": "centos:centos7",
        "features": {
            "go": {
                "version": "latest",
                "golangciLintVersion": "1.50.0"
            }
        }
    },
    "install_go_fedora": {
        "image": "fedora",
        "features": {
            "go": {
                "version": "latest",
                "golangciLintVersion": "1.50.0"
            }
        }
    },
    "install_go_mariner": {
        "image": "mcr.microsoft.com/cbl-mariner/base/core:2.0",
        "features": {
            "go": {
                "version": "latest",
                "golangciLintVersion": "1.50.0"
            }
        }
    },
    "install_go_tool_in_postCreate": {
        "image": "ubuntu:focal",
        "features": {
            "go": {
                "version": "latest",
                "golangciLintVersion": "1.50.0"
            }
        },
        "postCreateCommand": "go install filippo.io/mkcert@v1.4.2"
    },
    "install_go_tool_in_postCreate_rhel": {
        "image": "almalinux:8",
        "features": {
            "go": {
                "version": "latest",
                "golangciLintVersion": "1.50.0"
            }
        },
        "postCreateCommand": "go install filippo.io/mkcert@v1.4.2"
    },
    "install_go_twice": {
        "image": "mcr.microsoft.com/devcontainers/go:1.18",
        "features": {
            "go": {
                "version": "1.19"
            }
        }
    }
}


================================================
FILE: test/go/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# go
check "version" go version

# revive
check "revive version" revive --version
check "revive is installed at correct path" bash -c "which revive | grep /go/bin/revive"

# gomodifytags
check "gomodifytags is installed at correct path" bash -c "which gomodifytags | grep /go/bin/gomodifytags"

# goplay
check "goplay is installed at correct path" bash -c "which goplay | grep /go/bin/goplay"

# gotests
check "gotests is installed at correct path" bash -c "which gotests | grep /go/bin/gotests"

# impl
check "impl is installed at correct path" bash -c "which impl | grep /go/bin/impl"

# Report result
reportResults


================================================
FILE: test/hugo/install_hugo_extended.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Ensure extended version is installed
check "extended_installed"  bash -c "hugo version | grep extended"

# Report result
reportResults



================================================
FILE: test/hugo/scenarios.json
================================================
{
    "install_hugo_extended": {
        "image": "mcr.microsoft.com/devcontainers/base",
        "features": {
            "hugo": {
                "version": "latest",
                "extended": true
            }
        }
    }
}


================================================
FILE: test/hugo/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" hugo  version

# Report result
reportResults


================================================
FILE: test/java/alma-8-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/alma-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/alma-9-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/alma-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/centos-7.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/fedora.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/install_additional_java.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "java version 11 installed as default" grep "11\." <(java --version)
check "java version 17 installed" grep "^17\." <(ls /usr/local/sdkman/candidates/java)
check "java version 8 installed" grep "^8\." <(ls /usr/local/sdkman/candidates/java)

# Report result
reportResults



================================================
FILE: test/java/install_additional_java_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "java version 11 installed as default" grep "11\." <(java --version)
check "java version 17 installed" grep "^17\." <(ls /usr/local/sdkman/candidates/java)
check "java version 8 installed" grep "^8\." <(ls /usr/local/sdkman/candidates/java)

# Report result
reportResults



================================================
FILE: test/java/install_ant_and_gradle_and_maven_and_groovy.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "user is root" grep root <(whoami)

check "java" java --version

check "ant" ant -version
cat << EOF > /tmp/build.xml
<project><target name="init"><mkdir dir="ant-src"/></target></project>
EOF
cd /tmp && ant init
check "ant-src exists" grep "ant-src" <(ls -la /tmp)

check "gradle" gradle --version
cd /tmp && gradle init --type basic --dsl groovy --overwrite --incubating --project-name test
check "GRADLE_USER_HOME exists" grep ".gradle" <(ls -la /root)

check "maven" mvn --version
cd /tmp && mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
check "m2 exists" grep ".m2" <(ls -la /root)

check "groovy" groovy --version
cat << EOF > /tmp/test.groovy
println("verify")
EOF
check "groovy works" test "$(groovy /tmp/test.groovy)" = "verify"

# Report result
reportResults



================================================
FILE: test/java/install_ant_and_gradle_and_maven_and_groovy_for_user.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "user is vscode" grep vscode <(whoami)

check "java" java --version

check "ant" ant -version

cat << EOF > /tmp/build.xml
<project><target name="init"><mkdir dir="ant-src"/></target></project>
EOF
cd /tmp && ant init
check "ant-src exists" grep "ant-src" <(ls -la /tmp)

check "gradle" gradle --version
cd /tmp && gradle init --type basic --dsl groovy --overwrite --incubating --project-name test
check "GRADLE_USER_HOME exists" grep ".gradle" <(ls -la /home/vscode)

check "maven" mvn --version
cd /tmp && mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
check "m2 exists" grep ".m2" <(ls -la /home/vscode)

check "groovy" groovy --version
cat << EOF > /tmp/test.groovy
println("verify")
EOF
check "groovy works" test "$(groovy /tmp/test.groovy)" = "verify"

# Report result
reportResults



================================================
FILE: test/java/install_ant_and_gradle_and_maven_and_groovy_for_user_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "user is vscode" grep vscode <(whoami)

check "java" java --version

check "ant" ant -version
cat << EOF > /tmp/build.xml
<project><target name="init"><mkdir dir="ant-src"/></target></project>
EOF
cd /tmp && ant init
check "ant-src exists" grep "ant-src" <(ls -la /tmp)

check "gradle" gradle --version
cd /tmp && gradle init --type basic --dsl groovy --overwrite --incubating --project-name test
check "GRADLE_USER_HOME exists" grep ".gradle" <(ls -la /home/vscode)

check "maven" mvn --version
cd /tmp && mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
check "m2 exists" grep ".m2" <(ls -la /home/vscode)

check "groovy" groovy --version
cat << EOF > /tmp/test.groovy
println("verify")
EOF
check "groovy works" test "$(groovy /tmp/test.groovy)" = "verify"

# Report result
reportResults



================================================
FILE: test/java/install_ant_and_gradle_and_maven_and_groovy_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "user is root" grep root <(whoami)

check "java" java --version

check "ant" ant -version
cat << EOF > /tmp/build.xml
<project><target name="init"><mkdir dir="ant-src"/></target></project>
EOF
cd /tmp && ant init
check "ant-src exists" grep "ant-src" <(ls -la /tmp)

check "gradle" gradle --version
cd /tmp && gradle init --type basic --dsl groovy --overwrite --incubating --project-name test
check "GRADLE_USER_HOME exists" grep ".gradle" <(ls -la /root)

check "maven" mvn --version
cd /tmp && mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
check "m2 exists" grep ".m2" <(ls -la /root)

check "groovy" groovy --version
cat << EOF > /tmp/test.groovy
println("verify")
EOF
check "groovy works" test "$(groovy /tmp/test.groovy)" = "verify"

# Report result
reportResults



================================================
FILE: test/java/install_ant_and_gradle_and_maven_and_groovy_with_specific_version.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "user is root" grep root <(whoami)

check "java" java --version

check "ant version" grep "Ant(TM) version 1.10.12" <(ant -version)
cat << EOF > /tmp/build.xml
<project><target name="init"><mkdir dir="ant-src"/></target></project>
EOF
cd /tmp && ant init
check "ant-src exists" grep "ant-src" <(ls -la /tmp)

check "gradle version" grep "Gradle 6.8.3" <(gradle --version)
cd /tmp && gradle init --type basic --dsl groovy --project-name test
check "GRADLE_USER_HOME exists" grep ".gradle" <(ls -la /root)

check "maven version" grep "Apache Maven 3.6.3" <(mvn --version)
cd /tmp && mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
check "m2 exists" grep ".m2" <(ls -la /root)

check "groovy version" grep "Groovy Version: 2.5.22" <(groovy --version)

# Report result
reportResults



================================================
FILE: test/java/install_ant_and_gradle_and_maven_and_groovy_with_specific_version_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "user is root" grep root <(whoami)

check "java" java --version

check "ant version" grep "Ant(TM) version 1.10.12" <(ant -version)
cat << EOF > /tmp/build.xml
<project><target name="init"><mkdir dir="ant-src"/></target></project>
EOF
cd /tmp && ant init
check "ant-src exists" grep "ant-src" <(ls -la /tmp)

check "gradle version" grep "Gradle 6.8.3" <(gradle --version)
cd /tmp && gradle init --type basic --dsl groovy --project-name test
check "GRADLE_USER_HOME exists" grep ".gradle" <(ls -la /root)

check "maven version" grep "Apache Maven 3.6.3" <(mvn --version)
cd /tmp && mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
check "m2 exists" grep ".m2" <(ls -la /root)

check "groovy version" grep "Groovy Version: 2.5.22" <(groovy --version)

# Report result
reportResults



================================================
FILE: test/java/install_from_non_default_distro.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "java version openjdk 21 installed" grep "openjdk 21." <(java --version)

# Report result
reportResults



================================================
FILE: test/java/install_from_non_default_distro_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "java version openjdk 21 installed" grep "openjdk 21." <(java --version)

# Report result
reportResults



================================================
FILE: test/java/install_latest_version.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

echo 'public class HelloWorld { public static void main(String[] args) { System.out.println("Hello, World!"); } }' > HelloWorld.java
javac HelloWorld.java

check "hello world" /bin/bash -c "java HelloWorld | grep "Hello, World!""
check "java version latest installed" grep "24" <(java --version)

# Report result
reportResults



================================================
FILE: test/java/install_lts_version.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "java version LTS installed as default" grep "LTS" <(java --version)

# Report result
reportResults



================================================
FILE: test/java/install_non_conventional_version.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "java version openjdk 21 installed" grep "openjdk 21." <(java --version)

# Report result
reportResults



================================================
FILE: test/java/install_non_conventional_version_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "java version openjdk 21 installed" grep "openjdk 21." <(java --version)

# Report result
reportResults



================================================
FILE: test/java/mariner.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/rocky-8-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/rocky-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/rocky-9-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/rocky-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults



================================================
FILE: test/java/scenarios.json
================================================
{
    "install_from_non_default_distro": {
        "image": "ubuntu:noble",
        "features": {
            "java": {
                "version": "21",
                "jdkDistro": "open"
            }
        }
    },
    "install_latest_version": {
        "image": "ubuntu:noble",
        "features": {
            "java": {
                "version": "latest"
            }
        }
    },
    "install_lts_version": {
        "image": "ubuntu:noble",
        "features": {
            "java": {
                "version": "lts"
            }
        }
    },
    "install_additional_java": {
        "image": "ubuntu:noble",
        "features": {
            "java": {
                "version": "11",
                "additionalVersions": "17,8"
            }
        }
    },
    "install_ant_and_gradle_and_maven_and_groovy_for_user": {
        "image": "ubuntu:noble",
        "remoteUser": "vscode",
        "features": {
            "common-utils": {
                "username": "vscode"
            },
            "java": {
                "version": "latest",
                "installAnt": true,
                "installGradle": true,
                "installMaven": true,
                "installGroovy": true
            }
        }
    },
    "install_ant_and_gradle_and_maven_and_groovy": {
        "image": "ubuntu:noble",
        "features": {
            "java": {
                "version": "latest",
                "installAnt": true,
                "installGradle": true,
                "installMaven": true,
                "installGroovy": true
            }
        }
    },
    "install_ant_and_gradle_and_maven_and_groovy_with_specific_version": {
        "image": "ubuntu:noble",
        "features": {
            "java": {
                "version": "latest",
                "installAnt": "true",
                "antVersion": "1.10.12",
                "installGradle": "true",
                "gradleVersion": "6.8.3",
                "installMaven": "true",
                "mavenVersion": "3.6.3",
                "installGroovy": "true",
                "groovyVersion": "2.5.22"
            }
        }
    },
    "install_non_conventional_version": {
        "image": "ubuntu:noble",
        "features": {
            "java": {
                "version": "21",
                "jdkDistro": "graalce"
            }
        }
    },
    "install_from_non_default_distro_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "java": {
                "version": "21",
                "jdkDistro": "open"
            }
        }
    },
    "install_additional_java_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "java": {
                "version": "11",
                "additionalVersions": "17,8"
            }
        }
    },
    "install_ant_and_gradle_and_maven_and_groovy_for_user_rhel_family": {
        "image": "almalinux:8",
        "remoteUser": "vscode",
        "features": {
            "common-utils": {
                "username": "vscode"
            },
            "java": {
                "version": "latest",
                "installAnt": true,
                "installGradle": true,
                "installMaven": true,
                "installGroovy": true
            }
        }
    },
    "install_ant_and_gradle_and_maven_and_groovy_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "java": {
                "version": "latest",
                "installAnt": true,
                "installGradle": true,
                "installMaven": true,
                "installGroovy": true
            }
        }
    },
    "install_ant_and_gradle_and_maven_and_groovy_with_specific_version_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "java": {
                "version": "latest",
                "installAnt": "true",
                "antVersion": "1.10.12",
                "installGradle": "true",
                "gradleVersion": "6.8.3",
                "installMaven": "true",
                "mavenVersion": "3.6.3",
                "installGroovy": "true",
                "groovyVersion": "2.5.22"
            }
        }
    },
    "install_non_conventional_version_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "java": {
                "version": "21",
                "jdkDistro": "graalce"
            }
        }
    },
    "centos-7": {
        "image": "centos:centos7",
        "features": {
            "java": {}
        }
    },
    "alma-8": {
        "image": "almalinux:8",
        "features": {
            "java": {}
        }
    },
    "alma-8-minimal": {
        "image": "almalinux:8-minimal",
        "features": {
            "java": {}
        }
    },
    "alma-9": {
        "image": "almalinux:9",
        "features": {
            "java": {}
        }
    },
    "alma-9-minimal": {
        "image": "almalinux:9-minimal",
        "features": {
            "java": {}
        }
    },
    "rocky-8": {
        "image": "rockylinux:8",
        "features": {
            "java": {}
        }
    },
    "rocky-8-minimal": {
        "image": "rockylinux:8-minimal",
        "features": {
            "java": {}
        }
    },
    "rocky-9": {
        "image": "rockylinux:9",
        "features": {
            "java": {}
        }
    },
    "rocky-9-minimal": {
        "image": "rockylinux:9-minimal",
        "features": {
            "java": {}
        }
    },
    "mariner": {
        "image": "mcr.microsoft.com/cbl-mariner/base/core:2.0",
        "features": {
            "java": {}
        }
    },
    "fedora": {
        "image": "fedora",
        "features": {
            "java": {}
        }
    }
}


================================================
FILE: test/java/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" java  --version

# Check env
check "JAVA_HOME is set correctly" echo $JAVA_HOME | grep "/usr/local/sdkman/candidates/java/current"

# Report result
reportResults


================================================
FILE: test/kubectl-helm-minikube/checkBashCompletion.sh
================================================
#!/bin/bash

command=$1
expected=$2

echo -e "Checking completion for command '$command'..."

# Send command as a character stream, followed by two tab characters, into an interactive bash shell.
# Also note the 'y' which responds to the possible Bash question "Display all xxx possibilities? (y or n)".
# Bash produces the autocompletion output on stderr, so redirect that to stdout.
# The sed bit captures the lines between Header and Footer (used as output delimiters).
# The first grep removes the "Display all" message (that is atomatically answered to "y" by the script).
# The last grep filters the output to lines containing the expected result.
COMPLETE_OUTPUT=$(echo if false\; then "Header"\; $command$'\t'$'\t'y\; "Footer" fi | bash -i 2>&1 | sed -n '/Header/{:a;n;/Footer/q;p;ba}' | grep -v ^'Display all ')
echo -e "\nCompletion output:\n"
echo -e "$COMPLETE_OUTPUT"
echo -e "\n"

FILTERED_COMPLETE_OUTPUT=$(echo "$COMPLETE_OUTPUT" | grep "$expected")

if [ -z "$FILTERED_COMPLETE_OUTPUT" ]; then
  echo -e "Completion output does not contains '$expected'."
  exit 1
else
  echo -e "Completion output contains '$expected'."
  exit 0
fi



================================================
FILE: test/kubectl-helm-minikube/install_kubectl_with_version.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library
source dev-container-features-test-lib

# Define expected versions
KUBECTL_EXPECTED_VERSION="v1.33.0"
HELM_VERSION="v3.17.3"
MINIKUBE_VERSION="v1.31.1"

set +e
    kubectl version --client --output json | jq -r '.clientVersion.gitVersion' | grep "${KUBECTL_VERSION}"
    exit_code=$?
    check "kubectl-version-${KUBECTL_VERSION}-installed" bash -c "echo ${exit_code} | grep 0"
    echo "kubectl version:"
    kubectl version --client 

    helm version --short | grep "${HELM_VERSION}"
    exit_code=$?
    check "helm-version-${HELM_VERSION}-installed" bash -c "echo ${exit_code} | grep 0"
    echo "helm version:"
    helm version --short

    minikube version --short | grep "${MINIKUBE_VERSION}"  
    exit_code=$?
    check "minikube-version-${MINIKUBE_VERSION}-installed" bash -c "echo ${exit_code} | grep 0"
    echo "minikube version:"
    minikube version --short
set -e

# Report result
reportResults


================================================
FILE: test/kubectl-helm-minikube/install_kubectl_without_version.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library
source dev-container-features-test-lib

# Define expected versions
KUBECTL_EXPECTED_VERSION="1.30"
HELM_VERSION="3.16"
MINIKUBE_VERSION="1.28"

set +e
    kubectl version --client --output json | jq -r '.clientVersion.gitVersion' | grep "${KUBECTL_VERSION}"
    exit_code=$?
    check "kubectl-version-${KUBECTL_VERSION}-installed" bash -c "echo ${exit_code} | grep 0"
    echo "kubectl version:"
    kubectl version --client 

    helm version --short | grep "${HELM_VERSION}"
    exit_code=$?
    check "helm-version-${HELM_VERSION}-installed" bash -c "echo ${exit_code} | grep 0"
    echo "helm version:"
    helm version --short

    minikube version --short | grep "${MINIKUBE_VERSION}"  
    exit_code=$?
    check "minikube-version-${MINIKUBE_VERSION}-installed" bash -c "echo ${exit_code} | grep 0"
    echo "minikube version:"
    minikube version --short
set -e

# Report result
reportResults


================================================
FILE: test/kubectl-helm-minikube/install_only_helm_fallback.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library
source dev-container-features-test-lib
HL="\033[1;33m"
N="\033[0;37m"
echo -e "\nğŸ‘‰${HL} helm version as installed by kubectl-helm-minikube feature${N}:"

set +e
    check "helm version" helm version
set -e

# Function to handle errors
handle_error() {
    local exit_code=$?
    local line_number=$1
    local command=$2
    echo "Error occurred at line $line_number with exit code $exit_code in command $command"
    exit $exit_code
}
trap 'handle_error $LINENO ${BASH_COMMAND%% *}' ERR
echo "This is line $LINENO"

## Check for fallback version installation instead of latest ( when artifact not found )
architecture="$(uname -m)"
case $architecture in
    x86_64) architecture="amd64";;
    aarch64 | armv8*) architecture="arm64";;
    aarch32 | armv7* | armvhf*) architecture="arm";;
    i?86) architecture="386";;
    *) echo "(!) Architecture $architecture unsupported"; exit 1 ;;
esac

helm_url="https://github.com/helm/helm"

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name#v}
    
    output=$(curl -s "$repo_url");

    message=$(echo "$output" | jq -r '.message')

    if [ $mode == "mode1" ]; then
        message="API rate limit exceeded"
    else 
        message=""
    fi

    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="v${prev_version}"
    else 
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}

get_helm() {
    HELM_VERSION=$1
    helm_filename="helm-${HELM_VERSION}-linux-${architecture}.tar.gz"
    tmp_helm_filename="/tmp/helm/${helm_filename}"
    sudo curl -sSL "https://get.helm.sh/${helm_filename}" -o "${tmp_helm_filename}"
    sudo curl -sSL "https://github.com/helm/helm/releases/download/${HELM_VERSION}/${helm_filename}.asc" -o "${tmp_helm_filename}.asc"
}

install_helm() {
    mode=$1
    HELM_VERSION="v3.14.xyz"
    echo -e "\nğŸ‘‰Trying to install HELM_VERSION = ${HELM_VERSION}"; 
    sudo mkdir -p /tmp/helm
    get_helm "${HELM_VERSION}"
    if grep -q "BlobNotFound" "/tmp/helm/${helm_filename}"; then
        echo -e "\n(!) Failed to fetch the latest artifacts for helm ${HELM_VERSION}..."
        repo_url=$(get_github_api_repo_url "${helm_url}")
        get_previous_version "${helm_url}" "${repo_url}" HELM_VERSION $mode
        echo -e "\nAttempting to install ${HELM_VERSION}"
        get_helm "${HELM_VERSION}"
    fi
}

echo -e "\nğŸ‘‰${HL} helm version as installed by test for fallback${N}: (mode1: installation using find_prev_version_using_git_tags() fn)"
install_helm "mode1"

set +e
    check "helm version" helm version
set -e

echo -e "\nğŸ‘‰${HL} helm version as installed by test for fallback${N}: (mode2: installation using GitHub api)"
install_helm "mode2"

set +e
    check "helm version" helm version
set -e

# Report result
reportResults



================================================
FILE: test/kubectl-helm-minikube/install_only_kubectl.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library
source dev-container-features-test-lib

set +e
    kubectl
    exit_code=$?
    check "kubectl-is-not-installed" bash -c "echo ${exit_code} | grep 127"

    helm version
    exit_code=$?
    check "helm-is-not-installed" bash -c "echo ${exit_code} | grep 127"

    minikube version
    exit_code=$?
    check "minikube is-not-installed" bash -c "echo ${exit_code} | grep 127"
set -e

# Report result
reportResults



================================================
FILE: test/kubectl-helm-minikube/scenarios.json
================================================
{
    "install_only_kubectl": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "features": {
            "kubectl-helm-minikube": {
                "version": "none",
                "helm": "none",
                "minikube": "none"
            }
        }
    },
    "install_only_helm_fallback": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "features": {
            "kubectl-helm-minikube": {
                "version": "none",
                "helm": "latest",
                "minikube": "none"
            }
        }
    },
    "install_kubectl_without_version": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "features": {
            "kubectl-helm-minikube": {
                "version": "1.30",
                "helm": "3.16",
                "minikube": "1.28"
            }
        }
    },
    "install_kubectl_with_version": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "features": {
            "kubectl-helm-minikube": {
                "version": "v1.33.0",
                "helm": "v3.17.3",
                "minikube": "v1.31.1"
            }
        }
    }
}


================================================
FILE: test/kubectl-helm-minikube/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "kube" kubectl
check "helm" helm version
check "minikune" minikube version

# By default bash complete is disabled for the root user
# Enable it by replacing current ~/.bashrc with the /etc/skel/.bashrc file
mv ~/.bashrc ~/.bashrc.bak
cp /etc/skel/.bashrc ~/

check "helm-bash-completion-contains-version-command" ./checkBashCompletion.sh "helm " "version"

# Restore original ~/.bashrc
mv ~/.bashrc.bak ~/.bashrc

# Report result
reportResults


================================================
FILE: test/nix/extra-config.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
if [ "${uid}" != "1000" ]; then
    echo "Current user UID was adjusted."
fi
set +e 
vscode_uid="$(id -u vscode)"
set -e
if [ "${vscode_uid}" != "" ]; then
    echo "User vscode UID is ${vscode_uid}."
    if [ "${vscode_uid}" != "1000" ]; then
        echo "User vscode UID was adjusted."
    fi
fi
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

cat /etc/os-release
cat /etc/nix/nix.conf 

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "First added line" grep -E '^extra-substituters = https://foo\.cachix\.org$' /etc/nix/nix.conf 
check "Second added line" grep -E '^extra-trusted-public-keys = foo\.cachix\.org-1:bar=$' /etc/nix/nix.conf 

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/flake.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
if [ "${uid}" != "1000" ]; then
    echo "Current user UID was adjusted."
fi
set +e 
vscode_uid="$(id -u vscode)"
set -e
if [ "${vscode_uid}" != "" ]; then
    echo "User vscode UID is ${vscode_uid}."
    if [ "${vscode_uid}" != "1000" ]; then
        echo "User vscode UID was adjusted."
    fi
fi
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix" type nix
check "hello" type hello

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/multi-user-install.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
if [ "${uid}" != "1000" ]; then
    echo "Current user UID was adjusted."
fi
set +e 
vscode_uid="$(id -u vscode)"
set -e
if [ "${vscode_uid}" != "" ]; then
    echo "User vscode UID is ${vscode_uid}."
    if [ "${vscode_uid}" != "1000" ]; then
        echo "User vscode UID was adjusted."
    fi
fi
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "install" nix-env --install vim
check "vim_installed" type vim

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/os-alpine.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
if [ "${uid}" != "1000" ]; then
    echo "Current user UID was adjusted."
fi
set +e 
vscode_uid="$(id -u vscode)"
set -e
if [ "${vscode_uid}" != "" ]; then
    echo "User vscode UID is ${vscode_uid}."
    if [ "${vscode_uid}" != "1000" ]; then
        echo "User vscode UID was adjusted."
    fi
fi
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

cat /etc/os-release

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "install" nix-env --install vim
check "vim_installed" type vim

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/os-debian.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

cat /etc/os-release

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "install" nix-env --install vim
check "vim_installed" type vim

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/os-fedora.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

cat /etc/os-release

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "install" nix-env --install vim
check "vim_installed" type vim

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/os-rockylinux.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

cat /etc/os-release

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "install" nix-env --install vim
check "vim_installed" type vim

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/os-ubuntu.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

cat /etc/os-release

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "install" nix-env --install vim
check "vim_installed" type vim

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/packages-use-attr-path.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
if [ "${uid}" != "1000" ]; then
    echo "Current user UID was adjusted."
fi
set +e
vscode_uid="$(id -u vscode)"
set -e
if [ "${vscode_uid}" != "" ]; then
    echo "User vscode UID is ${vscode_uid}."
    if [ "${vscode_uid}" != "1000" ]; then
        echo "User vscode UID was adjusted."
    fi
fi
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

cat /etc/os-release

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "vim_installed" type vim
check "node_installed" type node
check "yarn_installed" type yarn

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1



================================================
FILE: test/nix/packages.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
if [ "${uid}" != "1000" ]; then
    echo "Current user UID was adjusted."
fi
set +e 
vscode_uid="$(id -u vscode)"
set -e
if [ "${vscode_uid}" != "" ]; then
    echo "User vscode UID is ${vscode_uid}."
    if [ "${vscode_uid}" != "1000" ]; then
        echo "User vscode UID was adjusted."
    fi
fi
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

cat /etc/os-release

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "vim_installed" type vim
check "node_installed" type node
check "yarn_installed" type yarn

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/scenarios.json
================================================
{
    "single-user-install": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "nix": {
                "multiUser": false
            }
        }
    },
    "version": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "nix": {
                "multiUser": false,
                "version": "2.10"
            }
        }
    },
    "multi-user-install": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "nix": {
                "multiUser": true
            }
        }
    },
    "os-ubuntu": {
        "image": "ubuntu",
        "remoteUser": "root",
        "features": {
            "nix": {
                "multiUser": true
            }
        }
    },
    "os-debian": {
        "image": "debian",
        "remoteUser": "root",
        "features": {
            "nix": {
                "multiUser": true
            }
        }
    },
    "os-rockylinux": {
        "image": "rockylinux:9",
        "remoteUser": "root",
        "features": {
            "nix": {
                "multiUser": true
            }
        }
    },
    "os-fedora": {
        "image": "fedora",
        "remoteUser": "root",
        "features": {
            "nix": {
                "multiUser": true
            }
        }
    },
    "os-alpine": {
        "image": "mcr.microsoft.com/devcontainers/base:alpine",
        "remoteUser": "vscode",
        "features": {
            "nix": {
                "multiUser": true
            }
        }
    },
    "packages": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "nix": {
                "packages": "nodejs,vim,yarn"
            }
        }
    },
    "packages-use-attr-path": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "nix": {
                "packages": "nodePackages.nodejs,nixpkgs.vim,nixpkgs.yarn",
                "useAttributePath": true
            }
        }
    },
    "flake": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "nix": {
                "flakeUri": "github:nixos/nixpkgs/nixpkgs-unstable#hello"
            }
        }
    },
    "extra-config": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "remoteUser": "vscode",
        "features": {
            "nix": {
                "extraNixConfig": "extra-substituters = https://foo.cachix.org,extra-trusted-public-keys = foo.cachix.org-1:bar="
            }
        }
    }
}



================================================
FILE: test/nix/single-user-install.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
if [ "${uid}" != "1000" ]; then
    echo "Current user UID was adjusted."
fi
set +e 
vscode_uid="$(id -u vscode)"
set -e
if [ "${vscode_uid}" != "" ]; then
    echo "User vscode UID is ${vscode_uid}."
    if [ "${vscode_uid}" != "1000" ]; then
        echo -e "User vscode UID was adjusted.\nWARNING: This scenario is not expected to work, so adjusting owner on Nix."
        sudo chown -R vscode /nix
    fi
fi
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."
if [ "${nix_uid}" != "${vscode_uid}" ]; then
    echo -e "WARNING: User UID does not match /nix owner. This scenario is not expected to work, so adjusting owner of /nix for testing purposes."
    sudo chown -R vscode /nix
fi


cat /etc/os-release

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "install" nix-env --install vim
check "vim_installed" type vim

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/test.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
if [ "${uid}" != "1000" ]; then
    echo "Current user UID was adjusted."
fi
set +e 
vscode_uid="$(id -u vscode)"
set -e
if [ "${vscode_uid}" != "" ]; then
    echo "User vscode UID is ${vscode_uid}."
    if [ "${vscode_uid}" != "1000" ]; then
        echo "User vscode UID was adjusted."
    fi
fi
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."

cat /etc/os-release

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "install" nix-env --install vim
check "vim_installed" type vim

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/nix/version.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library bundled with the devcontainer CLI
source dev-container-features-test-lib

uid="$(id -u)"
echo "Current user UID is ${uid}."
if [ "${uid}" != "1000" ]; then
    echo "Current user UID was adjusted."
fi
set +e 
vscode_uid="$(id -u vscode)"
set -e
if [ "${vscode_uid}" != "" ]; then
    echo "User vscode UID is ${vscode_uid}."
    if [ "${vscode_uid}" != "1000" ]; then
        echo "User vscode UID was adjusted."
    fi
fi
nix_uid="$(stat /nix -c "%u")"
echo "/nix UID is ${nix_uid}."
if [ "${nix_uid}" != "${vscode_uid}" ]; then
    echo -e "WARNING: User UID does not match /nix owner. This scenario is not expected to work, so adjusting owner of /nix for testing purposes."
    sudo chown -R vscode /nix
fi

cat /etc/os-release

# Feature-specific tests
# The 'check' command comes from the dev-container-features-test-lib.
check "nix-env" type nix-env
check "install" nix-env --install vim
check "vim_installed" type vim

# Report result
# If any of the checks above exited with a non-zero exit code, the test will fail.
reportResults &2>1


================================================
FILE: test/node/alma-8-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"
check "yarn" yarn --version

# Report result
reportResults


================================================
FILE: test/node/alma-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"
check "yarn" yarn --version

# Report result
reportResults


================================================
FILE: test/node/alma-9-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"
check "yarn" yarn --version

# Report result
reportResults


================================================
FILE: test/node/alma-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"
check "yarn" yarn --version

# Report result
reportResults


================================================
FILE: test/node/centos-7.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" bash -c "pnpm -v | grep 8.8.0"
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"
check "yarn" yarn --version

# Report result
reportResults


================================================
FILE: test/node/debian_yarn_from_corepack.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
YARN_VERSION="4.3.0"

# Corepack provides shims for package managers like yarn. The first time yarn is invoked via the "yarn"
# command, corepack will interactively request permission to download the yarn binary. To
# avoid this interactive mode and download the binary automatically, we explicitly call "corepack use yarn"
# instead (doesn't require user input). Once that command completes, "yarn" can be used in a non-interactive mode.
check "yarn shim location" bash -c ". /usr/local/share/nvm/nvm.sh && type yarn &> /dev/null"
check "download yarn" bash -c ". /usr/local/share/nvm/nvm.sh && corepack use yarn@${YARN_VERSION}"
check "yarn version" bash -c ". /usr/local/share/nvm/nvm.sh && yarn --version | grep ${YARN_VERSION}"

# Report result
reportResults



================================================
FILE: test/node/fedora.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"
check "yarn" yarn --version

# Report result
reportResults


================================================
FILE: test/node/install_additional_node.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# 'lts' is now some version of node 22...
check "version_on_path"  node -v | grep 22
check "pnpm" bash -c "pnpm -v | grep 8.8.0"

check "v20_installed" ls -1 /usr/local/share/nvm/versions/node | grep 20.19.1
check "v19_installed" ls -1 /usr/local/share/nvm/versions/node | grep 19.9.0


# Report result
reportResults



================================================
FILE: test/node/install_additional_node_on_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# 'lts' is now some version of node 22...
check "version_on_path"  node -v | grep 22
check "pnpm" bash -c "pnpm -v | grep 6.16.0"

check "v20_installed" ls -1 /usr/local/share/nvm/versions/node | grep 20
check "v19_installed" ls -1 /usr/local/share/nvm/versions/node | grep 19.9.0
check "v20_installed" ls -1 /usr/local/share/nvm/versions/node | grep 20.19.1


# Report result
reportResults



================================================
FILE: test/node/install_node_16_on_bionic.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" bash -c "node --version | grep 16"
check "pnpm" bash -c "pnpm -v | grep 8.8.0"
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"

# Report result
reportResults



================================================
FILE: test/node/install_node_22_on_jammy.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" bash -c "node --version | grep 22"
check "pnpm" bash -c "pnpm -v | grep 8.8.0"
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"

# Report result
reportResults




================================================
FILE: test/node/install_node_on_universal_image.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "version_on_path" bash -c "node -v | grep 'v19.1.0'"
check "pnpm" pnpm -v

# Report result
reportResults



================================================
FILE: test/node/install_nvm_0.39.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" bash -c "node --version"
check "pnpm" bash -c "pnpm -v | grep 6.16.0"
check "nvm version" bash -c ". /usr/local/share/nvm/nvm.sh && nvm --version | grep 0.39"

# Report result
reportResults



================================================
FILE: test/node/install_nvm_0.39_on_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" bash -c "node --version"
check "pnpm" pnpm -v
check "nvm version" bash -c ". /usr/local/share/nvm/nvm.sh && nvm --version | grep 0.39"

# Report result
reportResults



================================================
FILE: test/node/mariner.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
# for some reason the "nvm" test switches the default node version on Mariner
# test yarn before that: it is only enabled in the default node version
check "yarn" yarn --version_list
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"

# Report result
reportResults


================================================
FILE: test/node/non_root_user.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" bash -c "pnpm -v | grep 8.8.0"
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"

# Report result
reportResults


================================================
FILE: test/node/nvm_test_fallback.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

set -e

trap 'echo "Error occurred at line $LINENO"; exit 1' ERR
source /usr/local/share/nvm/nvm.sh
#check nvm version
echo -e "\nâœ… nvm version as installed by feature = v$(nvm --version)"; 
NVM_DIR="/usr/local/share/nvm"
NODE_VERSION="lts"
FAKE_NVM_VERSION="1.2.XYZ"
curl -so- "https://raw.githubusercontent.com/nvm-sh/nvm/v${FAKE_NVM_VERSION}/install.sh" | bash ||  {
    PREV_NVM_VERSION=$(curl -s https://api.github.com/repos/nvm-sh/nvm/releases/latest | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
    curl -so- "https://raw.githubusercontent.com/nvm-sh/nvm/${PREV_NVM_VERSION}/install.sh" | bash
    NVM_VERSION="${PREV_NVM_VERSION}"
}

#check nvm version
echo -e "\nâœ… nvm version as installed by test = v$(nvm --version)"; 

# Report result
reportResults



================================================
FILE: test/node/rocky-8-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"
check "yarn" yarn --version

# Report result
reportResults


================================================
FILE: test/node/rocky-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"
check "yarn" yarn --version

# Report result
reportResults


================================================
FILE: test/node/rocky-9-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"
check "yarn" yarn --version

# Report result
reportResults


================================================
FILE: test/node/rocky-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"
check "yarn" yarn --version

# Report result
reportResults


================================================
FILE: test/node/scenarios.json
================================================
{
    "nvm_test_fallback": {
        "image": "debian:11",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },    
    "install_additional_node": {
        "image": "debian:11",
        "features": {
            "node": {
                "version": "lts",
                "additionalVersions": "v20.19.1,v19.9.0",
                "pnpmVersion": "8.8.0"
            }
        }
    },
    "install_additional_node_on_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "node": {
                "version": "lts",
                "additionalVersions": "v20.19.1,v19.9.0",
                "pnpmVersion": "6.16.0"
            }
        }
    },
    "non_root_user": {
        "image": "mcr.microsoft.com/devcontainers/base",
        "remoteUser": "vscode",
        "features": {
            "node": {
                "version": "latest",
                "pnpmVersion": "8.8.0"
            }
        }
    },
    "zsh_default": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
        "features": {
            "node": {
                "version": "lts"
            },
            "common-utils": {
                "configureZshAsDefaultShell": true
            }
        }
    },
    "zsh_default_on_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "node": {
                "version": "lts"
            },
            "common-utils": {
                "configureZshAsDefaultShell": true
            }
        }
    },
    "version_none": {
        "image": "mcr.microsoft.com/devcontainers/base",
        "remoteUser": "vscode",
        "features": {
            "node": {
                "version": "none"
            }
        }
    },
    "version_none_on_rhel_family": {
        "image": "mcr.microsoft.com/devcontainers/base",
        "remoteUser": "vscode",
        "features": {
            "node": {
                "version": "none"
            }
        }
    },
    "install_node_22_on_jammy": {
        "image": "mcr.microsoft.com/devcontainers/base:ubuntu-22.04",
        "features": {
            "node": {
                "version": "22",
                "pnpmVersion":"8.8.0"
            }
        }
    },
    "install_nvm_0.39": {
        "image": "mcr.microsoft.com/devcontainers/base",
        "features": {
            "node": {
                "nvmVersion": "0.39",
                "pnpmVersion": "6.16.0"
            }
        }
    },
    "install_nvm_0.39_on_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "node": {
                "nvmVersion": "0.39"
            }
        }
    },
    "centos-7": {
        "image": "centos:centos7",
        "features": {
            "node": {
                "version": "16",
                "pnpmVersion": "8.8.0"
            }
        }
    },
    "alma-8": {
        "image": "almalinux:8",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },
    "alma-8-minimal": {
        "image": "almalinux:8-minimal",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },
    "alma-9": {
        "image": "almalinux:9",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },
    "alma-9-minimal": {
        "image": "almalinux:9-minimal",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },
    "rocky-8": {
        "image": "rockylinux:8",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },
    "rocky-8-minimal": {
        "image": "rockylinux:8-minimal",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },
    "rocky-9": {
        "image": "rockylinux:9",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },
    "rocky-9-minimal": {
        "image": "rockylinux:9-minimal",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },
    "fedora": {
        "image": "fedora",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },
    "mariner": {
        "image": "mcr.microsoft.com/cbl-mariner/base/core:2.0",
        "features": {
            "node": {
                "version": "lts"
            }
        }
    },
    "debian_yarn_from_corepack": {
        "image": "debian:11",
        "features": {
            "node": {
                "installYarnUsingApt": false
            }
        }
    }
}



================================================
FILE: test/node/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" node  --version
check "pnpm" pnpm -v
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"

# Report result
reportResults


================================================
FILE: test/node/version_none.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"

# Report result
reportResults



================================================
FILE: test/node/version_none_on_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"

# Report result
reportResults



================================================
FILE: test/node/zsh_default.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"

# Report result
reportResults



================================================
FILE: test/node/zsh_default_on_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "nvm" bash -c ". /usr/local/share/nvm/nvm.sh && nvm install 10"

# Report result
reportResults



================================================
FILE: test/nvidia-cuda/install_all_options.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check installation of libcudnn8
check "libcudnn.so.8" test 1 -eq "$(find /usr -name 'libcudnn.so.8' | wc -l)"

# Check installation of libcudnn8-dev
check "cudnn.h" test 1 -eq "$(find /usr -name 'cudnn.h' | wc -l)"

# Check installation of cuda-nvtx-11-<version>
check "cuda-11+nvtx" test -e '/usr/local/cuda-11/targets/x86_64-linux/include/nvtx3'

# Check installation of cuda-nvcc-11-<version>
check "cuda-11+nvcc" test -e '/usr/local/cuda-11/bin/nvcc'

# Report result
reportResults



================================================
FILE: test/nvidia-cuda/install_cuda_12_3_version.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check installation of libcudnn9
check "libcudnn.so.9" test 1 -eq "$(find /usr -name 'libcudnn.so.9' | wc -l)"

# Check installation of cuda-nvtx-12-3 (12.3)
check "cuda-12-3+nvtx" test -e '/usr/local/cuda-12.3/targets/x86_64-linux/include/nvtx3/'

# Report result
reportResults



================================================
FILE: test/nvidia-cuda/install_cuda_12_4_version.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check installation of libcudnn9
check "libcudnn.so.9" test 1 -eq "$(find /usr -name 'libcudnn.so.9' | wc -l)"

# Check installation of cuda-nvtx-12-4 (12.4)
check "cuda-12-4+nvtx" test -e '/usr/local/cuda-12.4/targets/x86_64-linux/include/nvtx3/'

# Report result
reportResults



================================================
FILE: test/nvidia-cuda/install_cuda_12_5_version.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# # Check installation of libcudnn9-cuda-12 (9.4.0)
check "libcudnn.so.9.5.0" test 1 -eq "$(find /usr -name 'libcudnn.so.9.5.0' | wc -l)"

# Check installation of cuda-nvtx-12-5 (12.5)
check "cuda-12-5+nvtx" test -e '/usr/local/cuda-12.5/targets/x86_64-linux/include/nvtx3/'

# Report result
reportResults



================================================
FILE: test/nvidia-cuda/install_cudnn_nvxt_version.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check installation of libcudnn8 (8.5.0)
check "libcudnn.so.8.5.0" test 1 -eq "$(find /usr -name 'libcudnn.so.8.5.0' | wc -l)"

# Check installation of cuda-nvtx-11-7 (11.7)
check "cuda-11-7+nvtx" test -e '/usr/local/cuda-11.7/targets/x86_64-linux/include/nvtx3'

# Report result
reportResults
    


================================================
FILE: test/nvidia-cuda/scenarios.json
================================================
{
    "install_all_options": {
        "image": "debian",
        "features": {
            "nvidia-cuda": {
                "installCudnn": true,
                "installCudnnDev": true,
                "installNvtx": true,
                "installToolkit": true
            }
        }
    },
    "install_cudnn_nvxt_version": {
        "image": "debian",
        "features": {
            "nvidia-cuda": {
                "installCudnn": true,
                "installNvtx": true,
                "cudaVersion": "11.7"
            }
        }
    },
    "install_cuda_12_3_version": {
        "image": "debian",
        "features": {
            "nvidia-cuda": {
                "installCudnn": true,
                "installCudnnDev": true,
                "installNvtx": true,
                "cudaVersion": "12.3"
            }
        }
    },
    "install_cuda_12_4_version": {
        "image": "debian",
        "features": {
            "nvidia-cuda": {
                "installCudnn": true,
                "installCudnnDev": true,
                "installNvtx": true,
                "cudaVersion": "12.4"
            }
        }
    },
    "install_cuda_12_5_version": {
        "image": "debian",
        "features": {
            "nvidia-cuda": {
                "installCudnn": true,
                "installCudnnDev": true,
                "installNvtx": true,
                "cudaVersion": "12.5",
                "cudnnVersion": "9.5.0.50"
            }
        }
    }
}



================================================
FILE: test/nvidia-cuda/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "cuda version" test -d /usr/local/cuda-11.8

# Check installation of cuda-libraries-11-<version>
check "libcudart.so.11.0" test 1 -eq "$(find /usr -name 'libcudart.so.11.0' | wc -l)"
check "libcublas.so.11" test 1 -eq "$(find /usr -name 'libcublas.so.11' | wc -l)"
check "libcublasLt.so.11" test 1 -eq "$(find /usr -name 'libcublasLt.so.11' | wc -l)"
check "libcufft.so.10" test 1 -eq "$(find /usr -name 'libcufft.so.10' | wc -l)"
check "libcurand.so.10" test 1 -eq "$(find /usr -name 'libcurand.so.10' | wc -l)"
check "libcusolver.so.11" test 1 -eq "$(find /usr -name 'libcusolver.so.11' | wc -l)"
check "libcusparse.so.11" test 1 -eq "$(find /usr -name 'libcusparse.so.11' | wc -l)"

# Report result
reportResults



================================================
FILE: test/oryx/install_dotnet_and_oryx.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Runtimes are listed twice due to 'Microsoft.NETCore.App' and 'Microsoft.AspNetCore.App'
check "two versions of dotnet runtimes are present" bash -c "[ $(dotnet --list-runtimes | wc -l) -eq 4 ]"

check "Oryx version" oryx --version
check "Dotnet is not removed if it is not installed by the Oryx Feature" dotnet --version

# Install platforms with oryx build tool
check "oryx-install-dotnet-2.1" oryx prep --skip-detection --platforms-and-versions dotnet=2.1.30
check "dotnet-2-installed-by-oryx" ls /opt/dotnet/ | grep 2.1

check "oryx-install-nodejs-12.22.11" oryx prep --skip-detection --platforms-and-versions nodejs=12.22.11
check "nodejs-12.22.11-installed-by-oryx" ls /opt/nodejs/ | grep 12.22.11

check "oryx-install-php-7.3.25" oryx prep --skip-detection --platforms-and-versions php=7.3.25
check "php-7.3.25-installed-by-oryx" ls /opt/php/ | grep 7.3.25

check "oryx-install-java-12.0.2" oryx prep --skip-detection --platforms-and-versions java=12.0.2
check "java-12.0.2-installed-by-oryx" ls /opt/java/ | grep 12.0.2

# Replicates Oryx's behavior for universal image
mkdir -p /opt/oryx
echo "vso-focal" >> /opt/oryx/.imagetype

mkdir -p /opt/dotnet/lts
cp -R /usr/share/dotnet/dotnet /opt/dotnet/lts
cp -R /usr/share/dotnet/LICENSE.txt /opt/dotnet/lts
cp -R /usr/share/dotnet/ThirdPartyNotices.txt /opt/dotnet/lts

# Install platforms with oryx build tool
check "oryx-install-dotnet-2.1-universal" oryx prep --skip-detection --platforms-and-versions dotnet=2.1.30
check "dotnet-2-installed-by-oryx-universal" ls /opt/dotnet/ | grep 2.1

check "oryx-install-nodejs-12.22.11-universal" oryx prep --skip-detection --platforms-and-versions nodejs=12.22.11
check "nodejs-12.22.11-installed-by-oryx-universal" ls /opt/nodejs/ | grep 12.22.11

check "oryx-install-php-7.3.25-universal" oryx prep --skip-detection --platforms-and-versions php=7.3.25
check "php-7.3.25-installed-by-oryx-universal" ls /opt/php/ | grep 7.3.25

check "oryx-install-java-12.0.2-universal" oryx prep --skip-detection --platforms-and-versions java=12.0.2
check "java-12.0.2-installed-by-oryx-universal" ls /opt/java/ | grep 12.0.2

# Report result
reportResults



================================================
FILE: test/oryx/install_older_dotnet_and_oryx.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "Oryx version" oryx --version
check "Dotnet is not removed if it is not installed by the Oryx Feature" dotnet --version

# Install platforms with oryx build tool
check "oryx-install-dotnet-2.1" oryx prep --skip-detection --platforms-and-versions dotnet=2.1.30
check "dotnet-2-installed-by-oryx" ls /opt/dotnet/ | grep 2.1

check "oryx-install-nodejs-12.22.11" oryx prep --skip-detection --platforms-and-versions nodejs=12.22.11
check "nodejs-12.22.11-installed-by-oryx" ls /opt/nodejs/ | grep 12.22.11

check "oryx-install-php-7.3.25" oryx prep --skip-detection --platforms-and-versions php=7.3.25
check "php-7.3.25-installed-by-oryx" ls /opt/php/ | grep 7.3.25

check "oryx-install-java-12.0.2" oryx prep --skip-detection --platforms-and-versions java=12.0.2
check "java-12.0.2-installed-by-oryx" ls /opt/java/ | grep 12.0.2

# Replicates Oryx's behavior for universal image
mkdir -p /opt/oryx
echo "vso-focal" >> /opt/oryx/.imagetype

mkdir -p /opt/dotnet/lts
cp -R /usr/share/dotnet/dotnet /opt/dotnet/lts
cp -R /usr/share/dotnet/LICENSE.txt /opt/dotnet/lts
cp -R /usr/share/dotnet/ThirdPartyNotices.txt /opt/dotnet/lts

# Install platforms with oryx build tool
check "oryx-install-dotnet-2.1-universal" oryx prep --skip-detection --platforms-and-versions dotnet=2.1.30
check "dotnet-2-installed-by-oryx-universal" ls /opt/dotnet/ | grep 2.1

check "oryx-install-nodejs-12.22.11-universal" oryx prep --skip-detection --platforms-and-versions nodejs=12.22.11
check "nodejs-12.22.11-installed-by-oryx-universal" ls /opt/nodejs/ | grep 12.22.11

check "oryx-install-php-7.3.25-universal" oryx prep --skip-detection --platforms-and-versions php=7.3.25
check "php-7.3.25-installed-by-oryx-universal" ls /opt/php/ | grep 7.3.25

check "oryx-install-java-12.0.2-universal" oryx prep --skip-detection --platforms-and-versions java=12.0.2
check "java-12.0.2-installed-by-oryx-universal" ls /opt/java/ | grep 12.0.2

# Report result
reportResults



================================================
FILE: test/oryx/install_prev_dotnet_and_oryx.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "Oryx version" oryx --version
check "Dotnet is not removed if it is not installed by the Oryx Feature" dotnet --version

# Install platforms with oryx build tool
check "oryx-install-dotnet-2.1" oryx prep --skip-detection --platforms-and-versions dotnet=2.1.30
check "dotnet-2-installed-by-oryx" ls /opt/dotnet/ | grep 2.1

check "oryx-install-nodejs-12.22.11" oryx prep --skip-detection --platforms-and-versions nodejs=12.22.11
check "nodejs-12.22.11-installed-by-oryx" ls /opt/nodejs/ | grep 12.22.11

check "oryx-install-php-7.3.25" oryx prep --skip-detection --platforms-and-versions php=7.3.25
check "php-7.3.25-installed-by-oryx" ls /opt/php/ | grep 7.3.25

check "oryx-install-java-12.0.2" oryx prep --skip-detection --platforms-and-versions java=12.0.2
check "java-12.0.2-installed-by-oryx" ls /opt/java/ | grep 12.0.2

# Replicates Oryx's behavior for universal image
mkdir -p /opt/oryx
echo "vso-focal" >> /opt/oryx/.imagetype

mkdir -p /opt/dotnet/lts
cp -R /usr/share/dotnet/dotnet /opt/dotnet/lts
cp -R /usr/share/dotnet/LICENSE.txt /opt/dotnet/lts
cp -R /usr/share/dotnet/ThirdPartyNotices.txt /opt/dotnet/lts

# Install platforms with oryx build tool
check "oryx-install-dotnet-2.1-universal" oryx prep --skip-detection --platforms-and-versions dotnet=2.1.30
check "dotnet-2-installed-by-oryx-universal" ls /opt/dotnet/ | grep 2.1

check "oryx-install-nodejs-12.22.11-universal" oryx prep --skip-detection --platforms-and-versions nodejs=12.22.11
check "nodejs-12.22.11-installed-by-oryx-universal" ls /opt/nodejs/ | grep 12.22.11

check "oryx-install-php-7.3.25-universal" oryx prep --skip-detection --platforms-and-versions php=7.3.25
check "php-7.3.25-installed-by-oryx-universal" ls /opt/php/ | grep 7.3.25

check "oryx-install-java-12.0.2-universal" oryx prep --skip-detection --platforms-and-versions java=12.0.2
check "java-12.0.2-installed-by-oryx-universal" ls /opt/java/ | grep 12.0.2

# Report result
reportResults



================================================
FILE: test/oryx/scenarios.json
================================================
{
    "install_dotnet_and_oryx": {
        "image": "ubuntu:noble",
        "features": {
            "dotnet": {
                "version": "8.0",
                "dotnetRuntimeVersions": "7.0",
                "aspNetCoreRuntimeVersions": "7.0"
            },
            "oryx": {}
        }
    },
    "install_older_dotnet_and_oryx": {
        "image": "ubuntu:noble",
        "features": {
            "dotnet": {
                "version": "7.0"
            },
            "oryx": {}
        }
    },
    "install_prev_dotnet_and_oryx": {
        "image": "ubuntu:noble",
        "features": {
            "dotnet": {
                "version": "6.0"
            },
            "oryx": {}
        }
    },
    "test_python_project": {
        "image": "ubuntu:noble",
        "features": {
            "python": {
                "version": "3.10.4",
                "additionalVersions": "3.9.7",
                "useOryxIfAvailable": "false"
            },
            "dotnet": {
                "version": "8.0"
            },
            "oryx": {}
        }
    }
}


================================================
FILE: test/oryx/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "Oryx version" oryx --version
check "ORYX_SDK_STORAGE_BASE_URL" echo $ORYX_SDK_STORAGE_BASE_URL
check "ENABLE_DYNAMIC_INSTALL" echo $ENABLE_DYNAMIC_INSTALL

# Install platforms with oryx build tool
check "oryx-install-dotnet-2.1" oryx prep --skip-detection --platforms-and-versions dotnet=2.1.30
check "dotnet-2-installed-by-oryx" ls /opt/dotnet/ | grep 2.1

check "oryx-install-nodejs-12.22.11" oryx prep --skip-detection --platforms-and-versions nodejs=12.22.11
check "nodejs-12.22.11-installed-by-oryx" ls /opt/nodejs/ | grep 12.22.11

check "oryx-install-php-7.3.25" oryx prep --skip-detection --platforms-and-versions php=7.3.25
check "php-7.3.25-installed-by-oryx" ls /opt/php/ | grep 7.3.25

check "oryx-install-java-12.0.2" oryx prep --skip-detection --platforms-and-versions java=12.0.2
check "java-12.0.2-installed-by-oryx" ls /opt/java/ | grep 12.0.2

# Report result
reportResults


================================================
FILE: test/oryx/test_python_project.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

cd sample-python

# Replicates Oryx's behavior for universal image
DEBIAN_FLAVOR="focal-scm"
mkdir -p /opt/oryx && echo "vso-focal" > /opt/oryx/.imagetype
echo "DEBIAN|${DEBIAN_FLAVOR}" | tr '[a-z]' '[A-Z]' > /opt/oryx/.ostype

ln -snf /usr/local/oryx/* /opt/oryx

PYTHON_PATH="/home/codespace/.python/current"
mkdir -p /home/codespace/.python
ln -snf /usr/local/python/current $PYTHON_PATH
ln -snf /usr/local/python /opt/python

export PATH="/home/codespace/.python/current/bin:${PATH}"
which python

pythonVersion=$(python -V 2>&1 | grep -Po '(?<=Python )(.+)')
pythonSite=`python -m site --user-site`
check "oryx-build-python" oryx build --property python_version="${pythonVersion}" --property packagedir="${pythonSite}" ./
check "oryx-build-python-installed" python3 -m pip list | grep mpmath
check "oryx-build-python-result" python3 ./src/solve.py

check "templates/8.0.1-does-not-exist" test ! -d "/usr/share/dotnet/templates/8.0.1"

# Report result
reportResults



================================================
FILE: test/oryx/sample-python/requirements.txt
================================================
mpmath==1.3.0
sympy==1.11.1



================================================
FILE: test/oryx/sample-python/src/solve.py
================================================
from sympy import Symbol, Eq, solve

x = Symbol("x")
y = Symbol("y")

equation_1 = Eq((x + y), 2)
equation_2 = Eq((x - y), 4)
print("Equation 1:", equation_1)
print("Equation 2:", equation_2)

solution = solve((equation_1, equation_2), (x, y))
print("Solution:", solution)



================================================
FILE: test/php/install_additional_php.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "php version 8.4.2 installed as default" php --version | grep 8.4.2
check "php version 8.3.14 installed"   ls -l /usr/local/php | grep 8.3.14
check "php version 8.2.27 installed"  ls -l /usr/local/php | grep 8.2.27

check "composer-version" composer --version

# Report result
reportResults



================================================
FILE: test/php/install_only_composer.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library
source dev-container-features-test-lib

check "composer-version" composer --version

# Report result
reportResults



================================================
FILE: test/php/install_php_8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "php-version-8-is-installed" bash -c "php --version | grep '8.'"
check "composer-version" composer --version

# Report result
reportResults



================================================
FILE: test/php/install_php_8_2.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "php-version-8.2-is-installed" bash -c "php --version | grep '8.2'"
check "composer-version" composer --version

# Report result
reportResults



================================================
FILE: test/php/scenarios.json
================================================
{
    "install_additional_php": {
        "image": "ubuntu:noble",
        "features": {
            "php": {
                "version": "8.4.2",
                "additionalVersions": "8.3.14,8.2.27"
            }
        }
    },
    "install_php_8": {
        "image": "ubuntu:noble",
        "features": {
            "php": {
                "version": "8"
            }
        }
    },
    "install_php_8_2": {
        "image": "ubuntu:noble",
        "features": {
            "php": {
                "version": "8.2"
            }
        }
    },
    "install_only_composer": {
        "image": "mcr.microsoft.com/devcontainers/php:latest",
        "features": {
            "php": {
                "version": "none",
                "installComposer": true
            }
        }
    },
    "test_php_fallback": {
        "image": "ubuntu:noble",
        "features": {
            "php": {
                "version": "latest"
            }
        }
    }
}



================================================
FILE: test/php/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "PHP version" php --version
check "Mbstring loaded" php -r "extension_loaded('mbstring') || throw new Error('Extension Mbstring is not loaded');"
check "composer-version" composer --version

# Report result
reportResults


================================================
FILE: test/php/test_php_fallback.sh
================================================
#!/bin/bash

echo -e "\nInstalled PHP Version by Feature: ğŸ‘‡ "; php -v;

USERNAME="root"
PHP_DIR="/usr/local/php"

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    echo "${!variable_name}"
    echo "$(echo "${requested_version}" | grep -o "." | wc -l)"
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    echo "${!variable_name}"
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

init_php_install() {
    PHP_INSTALL_DIR="${PHP_DIR}/${PHP_VERSION}"
    if [ -d "${PHP_INSTALL_DIR}" ]; then
        echo "(!) PHP version ${PHP_VERSION} already exists."
        exit 1
    fi

    if ! cat /etc/group | grep -e "^php:" > /dev/null 2>&1; then
        groupadd -r php
    fi
    usermod -a -G php "${USERNAME}"

    PHP_URL="https://www.php.net/distributions/php-${PHP_VERSION}.tar.gz"

    PHP_INI_DIR="${PHP_INSTALL_DIR}/ini"
    CONF_DIR="${PHP_INI_DIR}/conf.d"
    mkdir -p "${CONF_DIR}";

    PHP_EXT_DIR="${PHP_INSTALL_DIR}/extensions"
    mkdir -p "${PHP_EXT_DIR}"

    PHP_SRC_DIR="/usr/src/php"
    mkdir -p $PHP_SRC_DIR
    cd $PHP_SRC_DIR
}

install_previous_version() {
    echo -e "\nInstalling Previous Version..."
    find_prev_version_from_git_tags PHP_VERSION https://github.com/php/php-src "tags/php-"
    echo -e "\nNow installing this version as a fallback previous version: ${PHP_VERSION} ğŸ¤ğŸ»"
    init_php_install
    wget -O php.tar.xz "$PHP_URL"
}

install_php() {  
    # trying to install with a possible new tag not having a released source binary yet
    PHP_VERSION="8.3.xyz"

    init_php_install

    wget -O php.tar.xz "$PHP_URL" || install_previous_version
    
    tar -xf $PHP_SRC_DIR/php.tar.xz -C "$PHP_SRC_DIR" --strip-components=1
    cd $PHP_SRC_DIR;

    # PHP 7.4+, the pecl/pear installers are officially deprecated and are removed in PHP 8+
    # Thus, requiring an explicit "--with-pear"
    IFS="."
    read -a versions <<< "${PHP_VERSION}"
    PHP_MAJOR_VERSION=${versions[0]}
    PHP_MINOR_VERSION=${versions[1]}

    VERSION_CONFIG=""
    if (( $(($PHP_MAJOR_VERSION)) >= 8 )) || (( $(($PHP_MAJOR_VERSION)) == 7 && $(($PHP_MINOR_VERSION)) >= 4 )); then 
        VERSION_CONFIG="--with-pear"
    fi

    ./configure --prefix="${PHP_INSTALL_DIR}" --with-config-file-path="$PHP_INI_DIR" --with-config-file-scan-dir="$CONF_DIR" --enable-option-checking=fatal --with-curl --with-libedit --enable-mbstring --with-openssl --with-zlib --with-password-argon2 --with-sodium=shared "$VERSION_CONFIG" EXTENSION_DIR="$PHP_EXT_DIR";

    make -j "$(nproc)"
    find -type f -name '*.a' -delete
    make install
    find "${PHP_INSTALL_DIR}" -type f -executable -exec strip --strip-all '{}' + || true
    make clean

    cp -v $PHP_SRC_DIR/php.ini-* "$PHP_INI_DIR/";
    cp "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini"

    # Install xdebug
    "${PHP_INSTALL_DIR}/bin/pecl" install xdebug
    XDEBUG_INI="${CONF_DIR}/xdebug.ini"

    echo "zend_extension=${PHP_EXT_DIR}/xdebug.so" > "${XDEBUG_INI}"
    echo "xdebug.mode = debug" >> "${XDEBUG_INI}"
    echo "xdebug.start_with_request = yes" >> "${XDEBUG_INI}"
    echo "xdebug.client_port = 9003" >> "${XDEBUG_INI}"
}

apt-get purge php.*
PHP_DIR="/usr/local/php"
PHP_INSTALL_DIR="${PHP_DIR}/${PHP_VERSION}"
PHP_SRC_DIR="/usr/src/php"

install_php
PHP_SRC="${PHP_INSTALL_DIR}/bin/php"

updaterc() {
    echo "Updating /etc/bash.bashrc and /etc/zsh/zshrc..."
    if [[ "$(cat /etc/bash.bashrc)" != *"$1"* ]]; then
        echo -e "$1" >> /etc/bash.bashrc
    fi
    if [ -f "/etc/zsh/zshrc" ] && [[ "$(cat /etc/zsh/zshrc)" != *"$1"* ]]; then
        echo -e "$1" >> /etc/zsh/zshrc
    fi
}

if [ "${PHP_VERSION}" != "none" ]; then
    CURRENT_DIR="${PHP_DIR}/current"
    if [[ ! -d "${CURRENT_DIR}" ]]; then
        ln -s -r "${PHP_INSTALL_DIR}" ${CURRENT_DIR}
    fi

    if [[ $(ls -l ${CURRENT_DIR}) != *"-> ${PHP_INSTALL_DIR}"* ]] ; then
        rm "${CURRENT_DIR}"
        ln -s -r "${PHP_INSTALL_DIR}" "${CURRENT_DIR}"
    fi

    rm -rf "${PHP_SRC_DIR}"
    updaterc "if [[ \"\${PATH}\" != *\"${CURRENT_DIR}\"* ]]; then export PATH=\"${CURRENT_DIR}/bin:\${PATH}\"; fi"

    chown -R "${USERNAME}:php" "${PHP_DIR}"
    chmod -R g+r+w "${PHP_DIR}"
    find "${PHP_DIR}" -type d -print0 | xargs -n 1 -0 chmod g+s
fi

echo -e "\nInstalled PHP Version by Test: ğŸ‘‡ "; php -v;




================================================
FILE: test/powershell/install_modules.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Extension-specific tests
check "az.resources" pwsh -Command "(Get-Module -ListAvailable -Name Az.Resources).Version.ToString()"
check "az.storage" pwsh -Command "(Get-Module -ListAvailable -Name Az.Storage).Version.ToString()"
check "profile" pwsh -Command "(Get-Variable $env:ProfileLoaded).Value"

# Report result
reportResults



================================================
FILE: test/powershell/install_modules_version.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Extension-specific tests
check "az.resources" pwsh -Command "(Get-Module -ListAvailable -Name Az.Resources).Version.ToString()" | grep 2.5.0
check "az.storage" pwsh -Command "(Get-Module -ListAvailable -Name Az.Storage).Version.ToString()" | grep 4.3.0

# Report result
reportResults



================================================
FILE: test/powershell/install_powershell_fallback_test.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Extension-specific tests
check "az.resources" pwsh -Command "(Get-Module -ListAvailable -Name Az.Resources).Version.ToString()"
check "az.storage" pwsh -Command "(Get-Module -ListAvailable -Name Az.Storage).Version.ToString()"
check "profile" pwsh -Command "if (\$null -eq \$env:ProfileLoaded) { echo 'Not set!'; exit 1 } else { if ( [bool]\$env:ProfileLoaded ) { echo 'Profile loaded.'; exit 0 } else { echo 'False value!'; exit 1 } }"

check "Powershell version as installed by feature" bash -c "pwsh --version"

. /etc/os-release
architecture="$(dpkg --print-architecture)"

sudo mkdir -p /var/lib/apt/lists/

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name}

    output=$(curl -s "$repo_url");
    message=$(echo "$output" | jq -r '.message')
    
    if [ $mode == "mode1" ]; then
        message="API rate limit exceeded"
    else 
        message=""
    fi

    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="${prev_version}"
    else 
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}

install_prev_pwsh() {
    local pwsh_url=$1
    local mode=$2
    local repo_url=$(get_github_api_repo_url $pwsh_url)
    echo -e "\n(!) Failed to fetch the latest artifacts for powershell v${POWERSHELL_VERSION}..."
    get_previous_version $pwsh_url $repo_url POWERSHELL_VERSION $mode
    echo -e "\nAttempting to install v${POWERSHELL_VERSION}"
    install_pwsh "${POWERSHELL_VERSION}"
}

install_pwsh() {
    POWERSHELL_VERSION=$1
    powershell_filename="powershell-${POWERSHELL_VERSION}-linux-${architecture}.tar.gz"
    powershell_target_path="/opt/microsoft/powershell/$(echo ${POWERSHELL_VERSION} | grep -oE '[^\.]+' | head -n 1)"
    sudo mkdir -p /tmp/pwsh "${powershell_target_path}"
    cd /tmp/pwsh
    sudo curl -sSL -o "${powershell_filename}" "https://github.com/PowerShell/PowerShell/releases/download/v${POWERSHELL_VERSION}/${powershell_filename}"
}

install_using_github() {
    mode=$1
    if [ "${architecture}" = "amd64" ]; then
        architecture="x64"
    fi
    pwsh_url="https://github.com/PowerShell/PowerShell"
    POWERSHELL_VERSION="7.4.xyz"
    install_pwsh "${POWERSHELL_VERSION}"
    if grep -q "Not Found" "${powershell_filename}"; then 
        install_prev_pwsh $pwsh_url $mode
    fi

    # Ugly - but only way to get sha256 is to parse release HTML. Remove newlines and tags, then look for filename followed by 64 hex characters.
    sudo curl -sSL -o "release.html" "https://github.com/PowerShell/PowerShell/releases/tag/v${POWERSHELL_VERSION}"
    powershell_archive_sha256="$(cat release.html | tr '\n' ' ' | sed 's|<[^>]*>||g' | grep -oP "${powershell_filename}\s+\K[0-9a-fA-F]{64}" || echo '')"
    if [ -z "${powershell_archive_sha256}" ]; then
        echo "(!) WARNING: Failed to retrieve SHA256 for archive. Skipping validaiton."
    else
        echo "SHA256: ${powershell_archive_sha256}"
        echo "${powershell_archive_sha256} *${powershell_filename}" | sha256sum -c -
    fi
    sudo tar xf "${powershell_filename}" -C "${powershell_target_path}"
    sudo chmod 755 "${powershell_target_path}/pwsh"
    sudo ln -sf "${powershell_target_path}/pwsh" /usr/bin/pwsh
    sudo add-shell "/usr/bin/pwsh"
    cd /tmp
    sudo rm -rf /tmp/pwsh
}

echo -e "\nInstalling Powershell with find_prev_version_from_git_tags() fn ğŸ‘ˆğŸ»"
install_using_github "mode1"
check "Powershell version as installed by test (find_prev_version_from_git_tags() fn)" bash -c "pwsh --version"

echo -e "\nInstalling Powershell with GitHub Api ğŸ‘ˆğŸ»"
install_using_github "mode2"
check "Powershell version as installed by test (GitHub Api)" bash -c "pwsh --version"

# Report result
reportResults



================================================
FILE: test/powershell/powershell_alma_linux.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Extension-specific tests
check "pwsh file is symlink" bash -c "[ -L /usr/bin/pwsh ]"
check "pwsh symlink is registered as shell" bash -c "[ $(grep -c '/usr/bin/pwsh' /etc/shells) -ge 1 ]"
check "pwsh target is correct" bash -c "[ $(readlink /usr/bin/pwsh) = /opt/microsoft/powershell/7/pwsh ]"
check "pwsh owner is root" bash -c "[ $(stat -c %U /opt/microsoft/powershell/7/pwsh) = root ]"
check "pwsh group is root" bash -c "[ $(stat -c %G /opt/microsoft/powershell/7/pwsh) = root ]"
check "pwsh file mode is -rwxr-xr-x" bash -c "[ $(stat -c '%A' /opt/microsoft/powershell/7/pwsh) = '-rwxr-xr-x' ]"
check "pwsh is in PATH" bash -c "command -v pwsh"

# Report result
reportResults


================================================
FILE: test/powershell/scenarios.json
================================================
{
  "install_modules": {
    "image": "mcr.microsoft.com/devcontainers/base:noble",
    "features": {
      "powershell": {
        "modules": "az.resources, az.storage",
        "powershellProfileURL": "https://raw.githubusercontent.com/codspace/powershell-profile/main/Test-Profile.ps1"
      }
    }
  },
  "install_powershell_fallback_test": {
    "image": "mcr.microsoft.com/devcontainers/base:noble",
    "features": {
      "powershell": {
        "modules": "az.resources, az.storage",
        "powershellProfileURL": "https://raw.githubusercontent.com/codspace/powershell-profile/main/Test-Profile.ps1"
      }
    }
  },
  "install_modules_version": {
    "image": "mcr.microsoft.com/devcontainers/base:noble",
    "features": {
      "powershell": {
        "modules": "az.resources==2.5.0, az.storage==4.3.0"
      }
    }
  },
  "validate_powershell_installation": {
    "image": "mcr.microsoft.com/devcontainers/base:noble",
    "features": {
      "powershell": {}
    }
  },
  "powershell_alma_linux": {
    "image": "almalinux:9",
    "features": {
      "powershell": {} 
    }
  }
}



================================================
FILE: test/powershell/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" pwsh  --version

# Report result
reportResults


================================================
FILE: test/powershell/validate_powershell_installation.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Extension-specific tests
check "pwsh file is symlink" bash -c "[ -L /usr/bin/pwsh ]"
check "pwsh symlink is registered as shell" bash -c "[ $(grep -c '/usr/bin/pwsh' /etc/shells) -eq 1 ]"
check "pwsh target is correct" bash -c "[ $(readlink /usr/bin/pwsh) = /opt/microsoft/powershell/7/pwsh ]"
check "pwsh target is registered as shell" bash -c "[ $(grep -c '/opt/microsoft/powershell/7/pwsh' /etc/shells) -eq 1 ]"
check "pwsh owner is root" bash -c "[ $(stat -c %U /opt/microsoft/powershell/7/pwsh) = root ]"
check "pwsh group is root" bash -c "[ $(stat -c %G /opt/microsoft/powershell/7/pwsh) = root ]"
check "pwsh file mode is -rwxr-xr-x" bash -c "[ $(stat -c '%A' /opt/microsoft/powershell/7/pwsh) = '-rwxr-xr-x' ]"
check "pwsh is in PATH" bash -c "command -v pwsh"

# Report result
reportResults



================================================
FILE: test/python/alma-8-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/alma-8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/alma-9-minimal.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/alma-9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/alternatives_switchable_versions.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "python version 3.11 installed as default" bash -c "python --version | grep 3.11"
check "python3 version 3.11 installed as default" bash -c "python3 --version | grep 3.11"
check "python version 3.10.5 installed"  bash -c "ls -l /usr/local/python | grep 3.10.5"
check "python version 3.8 installed"  bash -c "ls -l /usr/local/python | grep 3.8"
check "python version 3.9.13 installed"  bash -c  "ls -l /usr/local/python | grep 3.9.13"

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version

# check alternatives command
check_version_switch() {
    if type apt-get > /dev/null 2>&1; then
        PYTHON_ALTERNATIVES=$(update-alternatives --query python3 | grep -E 'Alternative:|Priority:')
        STYLE="debian"
    elif type dnf > /dev/null 2>&1 || type yum > /dev/null 2>&1 || type microdnf > /dev/null 2>&1; then
        PYTHON_ALTERNATIVES=$(alternatives --display python3 | grep " - priority")
        STYLE="fedora"
    else
        echo "No supported package manager found."
        exit 1
    fi

    AVAILABLE_VERSIONS=()
    INDEX=1
    echo "Available Python versions:"
    if [ "${STYLE}" = "debian" ]; then
        while read -r alt && read -r pri; do
            PATH=${alt#Alternative: }   # Extract only the path
            PRIORITY=${pri#Priority: }  # Extract only the priority number
            TEMP_VERSIONS+=("${PRIORITY} ${PATH}")
            echo "$INDEX) $PATH (Priority: $PRIORITY)"
            ((INDEX++))
        done <<< "${PYTHON_ALTERNATIVES}"
    elif [ "${STYLE}" = "fedora" ]; then
        export PATH="/usr/bin:$PATH"
        # Fedora/RHEL output: one line per alternative in the format:
        while IFS= read -r line; do
            # Split using " - priority " as a delimiter.
            PATH=$(/usr/bin/awk -F' - priority ' '{print $1}' <<< "$line" | /usr/bin/xargs /bin/echo)
            PRIORITY=$(/usr/bin/awk -F' - priority ' '{print $2}' <<< "$line" | /usr/bin/xargs /bin/echo)    
            TEMP_VERSIONS+=("${PRIORITY} ${PATH}") 
            echo "$INDEX) $PATH (Priority: $PRIORITY_VALUE)"
            ((INDEX++))
        done <<< "${PYTHON_ALTERNATIVES}"
    fi

    export PATH="/usr/bin:$PATH"
    # Sort by priority (numerically ascending)
    IFS=$'\n' TEMP_VERSIONS=($(sort -n <<<"${TEMP_VERSIONS[*]}"))
    unset IFS

    # Populate AVAILABLE_VERSIONS from sorted data
    AVAILABLE_VERSIONS=()
    INDEX=1
    echo -e "\nAvailable Python versions (Sorted in asc order of priority):"
    for ENTRY in "${TEMP_VERSIONS[@]}"; do
        PRIORITY=${ENTRY%% *}  # Extract priority (first part before space)
        PATH=${ENTRY#* }       # Extract path (everything after first space)
        AVAILABLE_VERSIONS+=("${PATH}")
        echo "$INDEX) $PATH (Priority: $PRIORITY)"
        ((INDEX++))
    done

    echo -e "\nAvailable Versions Count: ${#AVAILABLE_VERSIONS[@]}"
    # Ensure at least 4 alternatives exist
    if [ "${#AVAILABLE_VERSIONS[@]}" -lt 4 ]; then
        echo "Error: Less than 4 Python versions registered in update-alternatives."
        exit 1
    fi
    
    export PATH="/usr/bin:$PATH"
    echo -e "\nSwitching to different versions using update-alternatives --set command...\n"
    for CHOICE in {1..4}; do
        SELECTED_VERSION="${AVAILABLE_VERSIONS[$((CHOICE - 1))]}"
        echo "Switching to: ${SELECTED_VERSION}"
        if command -v apt-get > /dev/null 2>&1; then
            /usr/bin/update-alternatives --set python3 ${SELECTED_VERSION}
        elif command -v dnf > /dev/null 2>&1 || command -v yum > /dev/null 2>&1 || command -v microdnf > /dev/null 2>&1; then
            /usr/sbin/alternatives --set python3 ${SELECTED_VERSION}
        fi
        # Verify the switch
        echo "Python version after switch:"
        /usr/local/python/current/bin/python3 --version
        /bin/sleep 1
        echo -e "\n"
    done
    echo -e "Update-Alternatives --display: \n"
    if type apt-get > /dev/null 2>&1; then
        /usr/bin/update-alternatives --display python3
    elif type dnf > /dev/null 2>&1 || type yum > /dev/null 2>&1 || type microdnf > /dev/null 2>&1; then
        /usr/sbin/alternatives --display python3
    fi
}

check "Version Switch With Update_Alternatives" check_version_switch


================================================
FILE: test/python/centos-7.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/fedora.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/install_additional_jupyterlab.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Always run these checks as the non-root user
user="$(whoami)"
check "user" grep vscode <<< "$user"

# Check for an installation of JupyterLab
check "version" jupyter lab --version

# Check location of JupyterLab installation
packages="$(python3 -m pip list)"
check "location" grep jupyter <<< "$packages"

# Check for git extension
check "jupyterlab_git" grep jupyterlab_git <<< "$packages"

# Check for correct JupyterLab configuration
check "config" grep ".*.allow_origin = '*'" /home/vscode/.jupyter/jupyter_server_config.py

# Report result
reportResults



================================================
FILE: test/python/install_additional_jupyterlab_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Always run these checks as the non-root user
user="$(whoami)"
check "user" grep vscode <<< "$user"

# Check for an installation of JupyterLab
check "version" jupyter lab --version

# Check location of JupyterLab installation
packages="$(python3 -m pip list)"
check "location" grep jupyter <<< "$packages"

# Check for git extension
check "jupyterlab_git" grep jupyterlab_git <<< "$packages"

# Check for correct JupyterLab configuration
check "config" grep ".*.allow_origin = '*'" /home/vscode/.jupyter/jupyter_server_config.py

# Report result
reportResults



================================================
FILE: test/python/install_additional_python.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "python version 3.11 installed as default" bash -c "python --version | grep 3.11"
check "python3 version 3.11 installed as default" bash -c "python3 --version | grep 3.11"
check "python version 3.10.5 installed"  bash -c "ls -l /usr/local/python | grep 3.10.5"
check "python version 3.8 installed"  bash -c "ls -l /usr/local/python | grep 3.8"
check "python version 3.9.13 installed"  bash -c  "ls -l /usr/local/python | grep 3.9.13"

# Check that tools can execute - make sure something didn't get messed up in this scenario
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/install_additional_python_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "python version 3.11 installed as default" bash -c "python --version | grep 3.11"
check "python3 version 3.11 installed as default" bash -c "python3 --version | grep 3.11"
check "python version 3.10.5 installed"  bash -c "ls -l /usr/local/python | grep 3.10.5"
check "python version 3.8 installed"  bash -c "ls -l /usr/local/python | grep 3.8"
check "python version 3.9.13 installed"  bash -c  "ls -l /usr/local/python | grep 3.9.13"

# Check that tools can execute - make sure something didn't get messed up in this scenario
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/install_alternate_tools.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "bandit" bandit --version
check "mypy" mypy --version
check "pipenv" pipenv --version
check "pytest" pytest --version
check "ruff" ruff --version
check "virtualenv" virtualenv --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pipenv" bash -c "which pipenv | grep /usr/local/py-utils/bin/pipenv"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"
check "which ruff" bash -c "which ruff | grep /usr/local/py-utils/bin/ruff"
check "which virtualenv" bash -c "which virtualenv | grep /usr/local/py-utils/bin/virtualenv"

# Report result
reportResults



================================================
FILE: test/python/install_alternate_tools_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "bandit" bandit --version
check "mypy" mypy --version
check "pipenv" pipenv --version
check "pytest" pytest --version
check "ruff" ruff --version
check "virtualenv" virtualenv --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pipenv" bash -c "which pipenv | grep /usr/local/py-utils/bin/pipenv"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"
check "which ruff" bash -c "which ruff | grep /usr/local/py-utils/bin/ruff"
check "which virtualenv" bash -c "which virtualenv | grep /usr/local/py-utils/bin/virtualenv"

# Report result
reportResults



================================================
FILE: test/python/install_cpython_fallback_prev_version_test.sh
================================================
#!/bin/bash

# Optional: Import test library
source dev-container-features-test-lib

check "Python version as installed by Feature" bash -c "python3 -V"

PYTHON_INSTALL_PATH="/usr/local/python"
OPTIMIZE_BUILD_FROM_SOURCE="false"
OVERRIDE_DEFAULT_VERSION="true"
ENABLESHARED="false"
if [ "$(id -u)" -ne 0 ]; then
    echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
    exit 1
fi
# Bring in ID, ID_LIKE, VERSION_ID, VERSION_CODENAME
. /etc/os-release
# Get an adjusted ID independent of distro variants
MAJOR_VERSION_ID=$(echo ${VERSION_ID} | cut -d . -f 1)
if [ "${ID}" = "debian" ] || [ "${ID_LIKE}" = "debian" ]; then
    ADJUSTED_ID="debian"
elif [[ "${ID}" = "rhel" || "${ID}" = "fedora" || "${ID}" = "mariner" || "${ID_LIKE}" = *"rhel"* || "${ID_LIKE}" = *"fedora"* || "${ID_LIKE}" = *"mariner"* ]]; then
    ADJUSTED_ID="rhel"
    if [[ "${ID}" = "rhel" ]] || [[ "${ID}" = *"alma"* ]] || [[ "${ID}" = *"rocky"* ]]; then
        VERSION_CODENAME="rhel${MAJOR_VERSION_ID}"
    else
        VERSION_CODENAME="${ID}${MAJOR_VERSION_ID}"
    fi
else
    echo "Linux distro ${ID} not supported."
    exit 1
fi

# Setup INSTALL_CMD & PKG_MGR_CMD
if type apt-get > /dev/null 2>&1; then
    PKG_MGR_CMD=apt-get
    INSTALL_CMD="${PKG_MGR_CMD} -y install --no-install-recommends"
elif type microdnf > /dev/null 2>&1; then
    PKG_MGR_CMD=microdnf
    INSTALL_CMD="${PKG_MGR_CMD} ${INSTALL_CMD_ADDL_REPOS} -y install --refresh --best --nodocs --noplugins --setopt=install_weak_deps=0"
elif type dnf > /dev/null 2>&1; then
    PKG_MGR_CMD=dnf
    INSTALL_CMD="${PKG_MGR_CMD} ${INSTALL_CMD_ADDL_REPOS} -y install --refresh --best --nodocs --noplugins --setopt=install_weak_deps=0"
else
    PKG_MGR_CMD=yum
    INSTALL_CMD="${PKG_MGR_CMD} ${INSTALL_CMD_ADDL_REPOS} -y install --noplugins --setopt=install_weak_deps=0"
fi

pkg_mgr_update() {
    case $ADJUSTED_ID in
        debian)
            if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
                echo "Running apt-get update..."
                ${PKG_MGR_CMD} update -y
            fi
            ;;
        rhel)
            if [ ${PKG_MGR_CMD} = "microdnf" ]; then
                if [ "$(ls /var/cache/yum/* 2>/dev/null | wc -l)" = 0 ]; then
                    echo "Running ${PKG_MGR_CMD} makecache ..."
                    ${PKG_MGR_CMD} makecache
                fi
            else
                if [ "$(ls /var/cache/${PKG_MGR_CMD}/* 2>/dev/null | wc -l)" = 0 ]; then
                    echo "Running ${PKG_MGR_CMD} check-update ..."
                    set +e
                    ${PKG_MGR_CMD} check-update
                    rc=$?
                    if [ $rc != 0 ] && [ $rc != 100 ]; then
                        exit 1
                    fi
                    set -e
                fi
            fi
            ;;
    esac
}

check_packages() {
    case ${ADJUSTED_ID} in
        debian)
            if ! dpkg -s "$@" > /dev/null 2>&1; then
                pkg_mgr_update
                ${INSTALL_CMD} "$@"
            fi
            ;;
        rhel)
            if ! rpm -q "$@" > /dev/null 2>&1; then
                pkg_mgr_update
                ${INSTALL_CMD} "$@"
            fi
            ;;
    esac
}

# Get the list of GPG key servers that are reachable
get_gpg_key_servers() {
    declare -A keyservers_curl_map=(
        ["hkp://keyserver.ubuntu.com"]="http://keyserver.ubuntu.com:11371"
        ["hkp://keyserver.ubuntu.com:80"]="http://keyserver.ubuntu.com"
        ["hkps://keys.openpgp.org"]="https://keys.openpgp.org"
        ["hkp://keyserver.pgp.com"]="http://keyserver.pgp.com:11371"
    )

    local curl_args=""
    local keyserver_reachable=false  # Flag to indicate if any keyserver is reachable

    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        curl_args="--proxy ${KEYSERVER_PROXY}"
    fi

    for keyserver in "${!keyservers_curl_map[@]}"; do
        local keyserver_curl_url="${keyservers_curl_map[${keyserver}]}"
        if curl -s ${curl_args} --max-time 5 ${keyserver_curl_url} > /dev/null; then
            echo "keyserver ${keyserver}"
            keyserver_reachable=true
        else
            echo "(*) Keyserver ${keyserver} is not reachable." >&2
        fi
    done

    if ! $keyserver_reachable; then
        echo "(!) No keyserver is reachable." >&2
        exit 1
    fi
}

# Import the specified key in a variable name passed in as 
receive_gpg_keys() {
    local keys=${!1}
    local keyring_args=""
    local gpg_cmd="gpg"
    if [ ! -z "$2" ]; then
        mkdir -p "$(dirname \"$2\")"
        keyring_args="--no-default-keyring --keyring $2"
    fi
    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        keyring_args="${keyring_args} --keyserver-options http-proxy=${KEYSERVER_PROXY}"
    fi

    # Install curl
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi

    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    echo -e "disable-ipv6\n$(get_gpg_key_servers)" > ${GNUPGHOME}/dirmngr.conf
    # GPG key download sometimes fails for some reason and retrying fixes it.
    local retry_count=0
    local gpg_ok="false"
    set +e
    until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "5" ]; 
    do
        echo "(*) Downloading GPG key..."
        ( echo "${keys}" | xargs -n 1 gpg -q ${keyring_args} --recv-keys) 2>&1 && gpg_ok="true"
        if [ "${gpg_ok}" != "true" ]; then
            echo "(*) Failed getting key, retrying in 10s..."
            (( retry_count++ ))
            sleep 10s
        fi
    done
    set -e
    if [ "${gpg_ok}" = "false" ]; then
        echo "(!) Failed to get gpg key."
        exit 1
    fi
}
# RHEL7/CentOS7 has an older gpg that does not have dirmngr
# Iterate through keyservers until we have all the keys downloaded
receive_gpg_keys_centos7() {
    local keys=${!1}
    local keyring_args=""
    local gpg_cmd="gpg"
    if [ ! -z "$2" ]; then
        mkdir -p "$(dirname \"$2\")"
        keyring_args="--no-default-keyring --keyring $2"
    fi
    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        keyring_args="${keyring_args} --keyserver-options http-proxy=${KEYSERVER_PROXY}"
    fi

    # Install curl
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi

    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    # GPG key download sometimes fails for some reason and retrying fixes it.
    local retry_count=0
    local gpg_ok="false"
    num_keys=$(echo ${keys} | wc -w)
    set +e
        echo "(*) Downloading GPG keys..."
        until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "5" ]; do
            for keyserver in $(echo "$(get_gpg_key_servers)" | sed 's/keyserver //'); do
                ( echo "${keys}" | xargs -n 1 gpg -q ${keyring_args} --recv-keys --keyserver=${keyserver} ) 2>&1
                downloaded_keys=$(gpg --list-keys | grep ^pub | wc -l)
                if [[ ${num_keys} = ${downloaded_keys} ]]; then
                    gpg_ok="true"
                    break
                fi
            done
            if [ "${gpg_ok}" != "true" ]; then
                echo "(*) Failed getting key, retrying in 10s..."
                (( retry_count++ ))
                sleep 10s
            fi
        done
    set -e
    if [ "${gpg_ok}" = "false" ]; then
        echo "(!) Failed to get gpg key."
        exit 1
    fi
}


# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

add_symlink() {
    CURRENT_PATH="${PYTHON_INSTALL_PATH}/current"
    if [[ ! -d "${CURRENT_PATH}" ]]; then
        ln -s -r "${INSTALL_PATH}" "${CURRENT_PATH}" 
    fi

    if [ "${OVERRIDE_DEFAULT_VERSION}" = "true" ]; then
        if [[ $(ls -l ${CURRENT_PATH}) != *"-> ${INSTALL_PATH}"* ]] ; then
            rm "${CURRENT_PATH}"
            ln -s -r "${INSTALL_PATH}" "${CURRENT_PATH}" 
        fi
    fi
}

install_prev_vers_cpython() {
    VERSION=$1
    echo -e "\n(!) Failed to fetch the latest artifacts for cpython ${VERSION}..."
    find_prev_version_from_git_tags VERSION https://github.com/python/cpython
    echo -e "\nAttempting to install ${VERSION}"
    install_cpython "${VERSION}"
}

install_cpython() {
    VERSION=$1
    INSTALL_PATH="${PYTHON_INSTALL_PATH}/${VERSION}"
    mkdir -p /tmp/python-src ${INSTALL_PATH}
    cd /tmp/python-src
    cpython_tgz_filename="Python-${VERSION}.tgz"
    cpython_tgz_url="https://www.python.org/ftp/python/${VERSION}/${cpython_tgz_filename}"
    echo "Downloading ${cpython_tgz_filename}..."
    curl -sSL -o "/tmp/python-src/${cpython_tgz_filename}" "${cpython_tgz_url}"
}

install_from_source() {
    VERSION=$1  
    echo "(*) Building Python ${VERSION} from source..."
    echo "(*) Building Python ${VERSION} from source..."
    if ! type git > /dev/null 2>&1; then
        check_packages git
    fi

    echo -e "\nTrying to Install a fake version whose source binary wouldn't exist"
    VERSION="3.12.xyz"

    install_cpython "${VERSION}"
    if [ -f "/tmp/python-src/${cpython_tgz_filename}" ]; then
        if grep -q "404 Not Found" "/tmp/python-src/${cpython_tgz_filename}"; then
            # Use grep to search for "404 Not Found" in the file
            echo "\"404 Not Found\" found in /tmp/python-src/${cpython_tgz_filename}. Not able to create source binary"
            install_prev_vers_cpython "${VERSION}"
        fi
    fi;
    
    # Verify signature
    if [[ ${VERSION_CODENAME} = "centos7" ]] || [[ ${VERSION_CODENAME} = "rhel7" ]]; then
        receive_gpg_keys_centos7 PYTHON_SOURCE_GPG_KEYS
    else
        receive_gpg_keys PYTHON_SOURCE_GPG_KEYS
    fi

    echo "Downloading ${cpython_tgz_filename}.asc..."
    curl -sSL -o "/tmp/python-src/${cpython_tgz_filename}.asc" "${cpython_tgz_url}.asc"

    # Untar and build
    tar -xzf "/tmp/python-src/${cpython_tgz_filename}" -C "/tmp/python-src" --strip-components=1
    local config_args=""
 
    if [ "${OPTIMIZE_BUILD_FROM_SOURCE}" = "true" ]; then
        config_args="${config_args} --enable-optimizations"
    fi
    if [ "${ENABLESHARED}" = "true" ]; then
        config_args=" ${config_args} --enable-shared"
        # need double-$: LDFLAGS ends up in Makefile $$ becomes $ when evaluated.
        # backslash needed for shell that Make calls escape the $.
        export LDFLAGS="${LDFLAGS} -Wl,-rpath="'\$$ORIGIN'"/../lib"
    fi
    if [ -n "${ADDL_CONFIG_ARGS}" ]; then
        config_args="${config_args} ${ADDL_CONFIG_ARGS}"
    fi

    ./configure --prefix="${INSTALL_PATH}" --with-ensurepip=install ${config_args}
    make -j 8
    make install

    cd /tmp
    rm -rf /tmp/python-src ${GNUPGHOME} /tmp/vscdc-settings.env

    ln -s "${INSTALL_PATH}/bin/python3" "${INSTALL_PATH}/bin/python"
    ln -s "${INSTALL_PATH}/bin/pip3" "${INSTALL_PATH}/bin/pip"
    ln -s "${INSTALL_PATH}/bin/idle3" "${INSTALL_PATH}/bin/idle"
    ln -s "${INSTALL_PATH}/bin/pydoc3" "${INSTALL_PATH}/bin/pydoc"
    ln -s "${INSTALL_PATH}/bin/python3-config" "${INSTALL_PATH}/bin/python-config"

    add_symlink

}

install_from_source

check "Python version as installed by Fallback Test" bash -c "python3 -V"


================================================
FILE: test/python/install_jupyterlab.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Always run these checks as the non-root user
user="$(whoami)"
check "user" grep vscode <<< "$user"

# Check for an installation of JupyterLab
check "version" jupyter lab --version

# Check location of JupyterLab installation
packages="$(python3 -m pip list)"
check "location" grep jupyter <<< "$packages"

# Check for git extension
check "jupyterlab_git" grep jupyterlab_git <<< "$packages"

# Check for correct JupyterLab configuration
check "config" grep ".*.allow_origin = '*'" /home/vscode/.jupyter/jupyter_server_config.py

#check "default path has jupyterlab symlink"
check "default path has jupyterlab" test -L "/usr/local/jupyter"

# Report result
reportResults



================================================
FILE: test/python/install_jupyterlab_debian.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check for an installation of JupyterLab
check "version" jupyter lab --version

# Check location of JupyterLab installation
packages="$(python3 -m pip list)"
check "location" grep jupyter <<< "$packages"

# Check for git extension
check "jupyterlab_git" grep jupyterlab_git <<< "$packages"

# Check for correct JupyterLab configuration
check "config" grep ".*.allow_origin = '*'" /root/.jupyter/jupyter_server_config.py

# Report result
reportResults



================================================
FILE: test/python/install_jupyterlab_existing_sudoers_file.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Always run these checks as the non-root user
user="$(whoami)"
check "user" grep vscode <<< "$user"

# Check for an installation of JupyterLab
check "version" jupyter lab --version

# Check location of JupyterLab installation
packages="$(python3 -m pip list)"
check "location" grep jupyter <<< "$packages"

# Check for git extension
check "jupyterlab_git" grep jupyterlab_git <<< "$packages"

# Check for correct JupyterLab configuration
check "config" grep ".*.allow_origin = '*'" /home/vscode/.jupyter/jupyter_server_config.py

# Check for PATH modification
check "default path has jupyterlab" grep "Defaults secure_path=/home/${user}/.local/bin" /etc/sudoers.d/$user

# Check if previous PATH exists
check "existing default path is preserved" grep "Defaults secure_path=.*original_content_of_sudoers_file" /etc/sudoers.d/$user

# Check if PATH modification includes original and new paths
check "existing path included with jupyterlab" grep "Defaults secure_path.*/home/${user}/.local/bin.*original_content_of_sudoers_file" /etc/sudoers.d/$user


# Report result
reportResults



================================================
FILE: test/python/install_jupyterlab_from_python_image.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Always run these checks as the non-root user
user="$(whoami)"
check "user" grep vscode <<< "$user"

# Check for an installation of JupyterLab
check "version" jupyter lab --version

# Report result
reportResults



================================================
FILE: test/python/install_jupyterlab_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Always run these checks as the non-root user
user="$(whoami)"
check "user" grep vscode <<< "$user"

# Check for an installation of JupyterLab
check "version" jupyter lab --version

# Check location of JupyterLab installation
packages="$(python3 -m pip list)"
check "location" grep jupyter <<< "$packages"

# Check for git extension
check "jupyterlab_git" grep jupyterlab_git <<< "$packages"

# Check for correct JupyterLab configuration
check "config" grep ".*.allow_origin = '*'" /home/vscode/.jupyter/jupyter_server_config.py

# Report result
reportResults



================================================
FILE: test/python/install_jupyterlab_ubuntu.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Check for an installation of JupyterLab
check "version" jupyter lab --version

# Check location of JupyterLab installation
packages="$(python3 -m pip list)"
check "location" grep jupyter <<< "$packages"

# Check for git extension
check "jupyterlab_git" grep jupyterlab_git <<< "$packages"

# Check for correct JupyterLab configuration
check "config" grep ".*.allow_origin = '*'" /root/.jupyter/jupyter_server_config.py

# Report result
reportResults



================================================
FILE: test/python/install_os_provided_python_deb.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "python3 is installed" python3 --version
check "python is installed" python --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/install_os_provided_python_mariner.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "python3 is installed" python3 --version
check "python is installed" python --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/install_os_provided_python_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "python3 is installed" python3 --version
check "python is installed" python --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/install_python310_setuptools_vulnerability.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library
source dev-container-features-test-lib

FAILED=()

echoStderr()
{
    echo "$@" 1>&2
}

check-version-ge() {
    LABEL=$1
    CURRENT_VERSION=$2
    REQUIRED_VERSION=$3
    shift
    echo -e "\nğŸ§ª Testing $LABEL: '$CURRENT_VERSION' is >= '$REQUIRED_VERSION'"
    local GREATER_VERSION=$((echo ${CURRENT_VERSION}; echo ${REQUIRED_VERSION}) | sort -V | tail -1)
    if [ "${CURRENT_VERSION}" == "${GREATER_VERSION}" ]; then
        echo "âœ…  Passed!"
        return 0
    else
        echoStderr "âŒ $LABEL check failed."
        FAILED+=("$LABEL")
        return 1
    fi
}

checkPythonPackageVersion()
{
    PACKAGE=$1
    REQUIRED_VERSION=$2

    current_version=$(python -c "import importlib.metadata; print(importlib.metadata.version('${PACKAGE}'))")
    check-version-ge "${PACKAGE}-requirement" "${current_version}" "${REQUIRED_VERSION}"
}

checkPythonPackageVersion "setuptools" "65.5.1"

# Check that tools can execute - make sure something didn't get messed up in this scenario
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version
check "setuptools" pip list | grep setuptools

# Check paths in settings
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

checkVulnerableFile_OR_DIR()
{
    for arg in "$@"; do
        if [[ -e $arg ]]; then
            echo -e "\nâœ… Vulnerable:- ${arg} - exists in v3.10 as Vulnerability Patching has been skipped."
        else
            echo -e "\nâŒ Vulnerable:- ${arg} - don't exist in v3.10 as Vulnerability Patching has not been skipped."
        fi
    done
}

# print setuptools
check "Show All Files/Folders which include setuptools" bash -c 'find / -name "*setuptools*"'

# only for 3.10
checkVulnerableFile_OR_DIR "/usr/local/py-utils/shared/lib/python3.10/site-packages/setuptools-65.5.0.dist-info" "/usr/local/lib/python3.10/ensurepip/_bundled/setuptools-65.5.0-py3-none-any.whl"

# Function to check if a package is installed
checkPackageInstalled() {
    if python -c "import $1" &>/dev/null; then
        echo -e "\nâœ… Passed! \n$1 is installed"
    else
        echo -e "$1 is NOT installed\n"
        echoStderr "âŒ check failed."
    fi
}

# Function to install a package using pip
installPackage() {
    python3 -m pip install "$1"
}

checkPipWorkingCorrectly() {
    echo -e "\nğŸ§ª Testing whether pip install works fine \n"
    # List of packages to install via pip
    packages=("numpy" "requests" "matplotlib")
    # Install packages and check if installation was successful
    for package in "${packages[@]}"; do
        echo -e "\nğŸ§ª Testing pip install $package\n"
        installPackage "$package"
        checkPackageInstalled "$package"
    done
}

checkPipWorkingCorrectly

# Report result
reportResults



================================================
FILE: test/python/install_python310_skipVulnerabilityPatching_true.sh
================================================
#!/bin/bash
set -e

# Optional: Import test library
source dev-container-features-test-lib

FAILED=()

echoStderr()
{
    echo "$@" 1>&2
}

check-version-ge() {
    LABEL=$1
    CURRENT_VERSION=$2
    REQUIRED_VERSION=$3
    shift
    echo -e "\nğŸ§ª Testing $LABEL: '$CURRENT_VERSION' is >= '$REQUIRED_VERSION'"
    local GREATER_VERSION=$((echo ${CURRENT_VERSION}; echo ${REQUIRED_VERSION}) | sort -V | tail -1)
    if [ "${CURRENT_VERSION}" == "${GREATER_VERSION}" ]; then
        echo "âœ…  Passed!"
        return 0
    else
        echoStderr "âŒ $LABEL check failed."
        FAILED+=("$LABEL")
        return 1
    fi
}

checkPythonPackageVersion()
{
    PACKAGE=$1
    REQUIRED_VERSION=$2

    current_version=$(python -c "import importlib.metadata; print(importlib.metadata.version('${PACKAGE}'))")
    check-version-ge "${PACKAGE}-requirement" "${current_version}" "${REQUIRED_VERSION}"
}

checkPythonPackageVersion "setuptools" "65.5.1"

# Check that tools can execute - make sure something didn't get messed up in this scenario
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version
check "setuptools" pip list | grep setuptools

# Check paths in settings
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

HL="\033[1;33m"
N="\033[0;37m"

checkVulnerableFile_OR_DIR()
{
    for arg in "$@"; do
        if [[ -e $arg ]]; then
            echo -e "\nâœ…${HL} Vulnerable:- ${N}${arg} - ${HL}EXISTS ${N}in v3.10 as skipVulnerabilityPatching=true"
        else
            echo -e "\nâŒ${HL} Vulnerable:- ${arg} - ${N}don't ${HL}EXISTS ${N}in v3.10 as skipVulnerabilityPatching=false"
        fi
    done
}

# print setuptools
check "Show All Files/Folders which include setuptools" bash -c 'find / -name "*setuptools*"'

# only for 3.10
checkVulnerableFile_OR_DIR "/usr/local/py-utils/shared/lib/python3.10/site-packages/setuptools-65.5.0.dist-info" "/usr/local/lib/python3.10/ensurepip/_bundled/setuptools-65.5.0-py3-none-any.whl"

# Function to check if a package is installed
checkPackageInstalled() {
    if python -c "import $1" &>/dev/null; then
        echo -e "\nâœ… Passed! \n$1 is installed"
    else
        echo -e "$1 is NOT installed\n"
        echoStderr "âŒ check failed."
    fi
}

# Function to install a package using pip
installPackage() {
    python3 -m pip install "$1"
}

checkPipWorkingCorrectly() {
    echo -e "\nğŸ§ª Testing whether pip install works fine \n"
    # List of packages to install via pip
    packages=("numpy" "requests" "matplotlib")
    # Install packages and check if installation was successful
    for package in "${packages[@]}"; do
        echo -e "\nğŸ§ª Testing pip install $package\n"
        installPackage "$package"
        checkPackageInstalled "$package"
    done
}

checkPipWorkingCorrectly

# Report result
reportResults



================================================
FILE: test/python/install_python311_setuptools_vulnerability.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

FAILED=()

echoStderr()
{
    echo "$@" 1>&2
}

check-version-ge() {
    LABEL=$1
    CURRENT_VERSION=$2
    REQUIRED_VERSION=$3
    shift
    echo -e "\nğŸ§ª Testing $LABEL: '$CURRENT_VERSION' is >= '$REQUIRED_VERSION'"
    local GREATER_VERSION=$((echo ${CURRENT_VERSION}; echo ${REQUIRED_VERSION}) | sort -V | tail -1)
    if [ "${CURRENT_VERSION}" == "${GREATER_VERSION}" ]; then
        echo "âœ…  Passed!"
        return 0
    else
        echoStderr "âŒ $LABEL check failed."
        FAILED+=("$LABEL")
        return 1
    fi
}

checkPythonPackageVersion()
{
    PACKAGE=$1
    REQUIRED_VERSION=$2

    current_version=$(python -c "import importlib.metadata; print(importlib.metadata.version('${PACKAGE}'))")
    check-version-ge "${PACKAGE}-requirement" "${current_version}" "${REQUIRED_VERSION}"
}

checkPythonPackageVersion "setuptools" "65.5.1"

# Check that tools can execute - make sure something didn't get messed up in this scenario
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version
check "setuptools" pip list | grep setuptools

# Check paths in settings
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

checkVulnerableFile_OR_DIR()
{
    for arg in "$@"; do
        if [[ -e $arg ]]; then
            echo -e "\nâœ… Vulnerable:- ${arg} - exists in v3.11 as Vulnerability Patching has been skipped."
        else
            echo -e "\nâŒ Vulnerable:- ${arg} - don't exist in v3.11 as Vulnerability Patching has not been skipped."
        fi
    done
}

# print setuptools
check "Show All Files/Folders which include setuptools" bash -c 'find / -name "*setuptools*"'

# only for 3.11
checkVulnerableFile_OR_DIR "/usr/local/py-utils/shared/lib/python3.11/site-packages/setuptools-65.5.0.dist-info" "/usr/local/lib/python3.11/ensurepip/_bundled/setuptools-65.5.0-py3-none-any.whl"

# Function to check if a package is installed
checkPackageInstalled() {
    if python -c "import $1" &>/dev/null; then
        echo -e "\nâœ… Passed! \n$1 is installed"
    else
        echo -e "$1 is NOT installed\n"
        echoStderr "âŒ check failed."
    fi
}

# Function to install a package using pip
installPackage() {
    python3 -m pip install "$1"
}

checkPipWorkingCorrectly() {
    echo -e "\nğŸ§ª Testing whether pip install works fine \n"
    # List of packages to install via pip
    packages=("numpy" "requests" "matplotlib")
    # Install packages and check if installation was successful
    for package in "${packages[@]}"; do
        echo -e "\nğŸ§ª Testing pip install $package\n"
        installPackage "$package"
        checkPackageInstalled "$package"
    done
}

checkPipWorkingCorrectly

# Report result
reportResults



================================================
FILE: test/python/install_python_3_12.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "python version 3.12 installed as default" bash -c "python --version | grep 3.12"
check "python3 version 3.12 installed as default" bash -c "python3 --version | grep 3.12"

# Check that tools can execute - make sure something didn't get messed up in this scenario
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/install_python_shared_lib_deb.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Check compiled with "--enable-shared" -- python truth is opposite of the shells
#   therefore we negate the check to get a '0' exit code when the python
#   has been compiled with --enable-shared
check "python enable shared" /usr/local/python/current/bin/python -c 'import sys; import sysconfig; sys.exit(sysconfig.get_config_vars("Py_ENABLE_SHARED") != [1])'

# Report result
reportResults



================================================
FILE: test/python/install_python_shared_lib_rhel_family.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Check compiled with "--enable-shared" -- python truth is opposite of the shells
#   therefore we negate the check to get a '0' exit code when the python
#   has been compiled with --enable-shared
check "python enable shared" /usr/local/python/current/bin/python -c 'import sys; import sysconfig; sys.exit(sysconfig.get_config_vars("Py_ENABLE_SHARED") != [1])'

# Report result
reportResults



================================================
FILE: test/python/install_via_oryx.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "python3 is installed" python3 --version
check "python is installed" python --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/scenarios.json
================================================
{
    "install_cpython_fallback_prev_version_test": {
        "image": "python:3.12",
        "features": {
            "python": {
                "version": "3.12",
                "installTools": false,
                "skipVulnerabilityPatching": true
            }
        }
    },
    "install_python310_skipVulnerabilityPatching_true": {
        "image": "python:3.10",
        "features": {
            "python": {
                "version": "none",
                "installTools": true,
                "skipVulnerabilityPatching": true
            }
        }
    },
    "install_python310_setuptools_vulnerability": {
        "image": "python:3.10",
        "features": {
            "python": {
                "version": "none",
                "installTools": true,
                "skipVulnerabilityPatching": false
            }
        }
    },
    "install_python311_setuptools_vulnerability": {
        "image": "python:3.11",
        "features": {
            "python": {
                "version": "none",
                "installTools": true,
                "skipVulnerabilityPatching": false
            }
        }
    },
    "install_additional_python": {
        "image": "ubuntu:noble",
        "features": {
            "python": {
                "version": "3.11",
                "additionalVersions": "3.8,3.9.13,3.10.5"
            }
        }
    },
    "install_additional_python_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "python": {
                "version": "3.11",
                "additionalVersions": "3.8,3.9.13,3.10.5"
            }
        }
    },
    "install_jupyterlab": {
        "image": "mcr.microsoft.com/devcontainers/base:noble",
        "remoteUser": "vscode",
        "features": {
            "python": {
                "version": "latest",
                "installJupyterlab": true,
                "configureJupyterlabAllowOrigin": "*"
            }
        }
    },
    "install_jupyterlab_rhel_family": {
        "image": "almalinux:8",
        "remoteUser": "vscode",
        "features": {
            "common-utils": {
                "username": "vscode"
            },
            "python": {
                "version": "latest",
                "installJupyterlab": true,
                "configureJupyterlabAllowOrigin": "*"
            }
        }
    },
    "install_additional_jupyterlab": {
        "image": "mcr.microsoft.com/devcontainers/base:noble",
        "remoteUser": "vscode",
        "features": {
            "python": {
                "version": "latest",
                "additionalVersions": "3.9",
                "installJupyterlab": true,
                "configureJupyterlabAllowOrigin": "*"
            }
        }
    },
    "install_additional_jupyterlab_rhel_family": {
        "image": "almalinux:8",
        "remoteUser": "vscode",
        "features": {
            "common-utils": {
                "username": "vscode"
            },
            "python": {
                "version": "latest",
                "additionalVersions": "3.9",
                "installJupyterlab": true,
                "configureJupyterlabAllowOrigin": "*"
            }
        }
    },
    "install_os_provided_python_deb": {
        "image": "mcr.microsoft.com/devcontainers/base:1-bullseye",
        "features": {
            "python": "os-provided"
        }
    },
    "install_os_provided_python_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "python": "os-provided"
        }
    },
    "install_os_provided_python_mariner": {
        "image": "mcr.microsoft.com/cbl-mariner/base/core:2.0",
        "features": {
            "python": "os-provided"
        }
    },
    "install_jupyterlab_from_python_image": {
        "image": "mcr.microsoft.com/devcontainers/python:3.10-bullseye",
        "remoteUser": "vscode",
        "features": {
            "python": {
                "version": "none",
                "installTools": false,
                "installJupyterlab": true
            }
        }
    },
    "install_via_oryx": {
        "image": "mcr.microsoft.com/oryx/build:full-debian-bullseye",
        "features": {
            "python": "3.10"
        }
    },
    "install_jupyterlab_debian": {
        "image": "debian:bullseye-slim",
        "features": {
            "python": {
                "version": "3.11",
                "installJupyterlab": true,
                "configureJupyterlabAllowOrigin": "*"
            }
        }
    },
    "install_jupyterlab_ubuntu": {
        "image": "ubuntu:noble",
        "features": {
            "python": {
                "version": "3.11",
                "installJupyterlab": true,
                "configureJupyterlabAllowOrigin": "*"
            }
        }
    },
    "install_python_3_12": {
        "image": "mcr.microsoft.com/devcontainers/base:1-ubuntu-22.04",
        "features": {
            "python": {
                "version": "3.12"
            }
        }
    },
    "install_alternate_tools": {
        "image": "mcr.microsoft.com/devcontainers/base:1-ubuntu-22.04",
        "features": {
            "python": {
                "version": "3.12",
                "toolsToInstall": "ruff,mypy,bandit,pipenv,virtualenv,pytest"
            }
        }
    },
    "install_alternate_tools_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "python": {
                "version": "3.12",
                "toolsToInstall": "ruff,mypy,bandit,pipenv,virtualenv,pytest"
            }
        }
    },
    "centos-7": {
        "image": "centos:centos7",
        "features": {
            "python": {
                "version": "3.11"
            }
        }
    },
    "alma-8": {
        "image": "almalinux:8",
        "features": {
            "python": {
                "version": "3.11"
            }
        }
    },
    "alma-8-minimal": {
        "image": "almalinux:8-minimal",
        "features": {
            "python": {
                "version": "3.11"
            }
        }
    },
    "alma-9": {
        "image": "almalinux:9",
        "features": {
            "python": {
                "version": "3.11"
            }
        }
    },
    "alma-9-minimal": {
        "image": "almalinux:9-minimal",
        "features": {
            "python": {
                "version": "3.11"
            }
        }
    },
    "fedora": {
        "image": "fedora",
        "features": {
            "python": {
                "version": "3.11"
            }
        }
    },
    "install_python_shared_lib_deb": {
        "image": "ubuntu:noble",
        "features": {
            "python": {
                "version": "3.11",
                "enableShared": true
            }
        }
    },
    "install_python_shared_lib_rhel_family": {
        "image": "almalinux:8",
        "features": {
            "python": {
                "version": "3.11",
                "enableShared": true
            }
        }
    },
    "update_alternatives_switchable_versions": {
        "image": "ubuntu:noble",
        "features": {
            "python": {
                "version": "3.11",
                "installTools": true,
                "additionalVersions": "3.8,3.9.13,3.10.5"
            }
        }
    },
    "alternatives_switchable_versions": {
        "image": "fedora",
        "features": {
            "python": {
                "version": "3.11",
                "installTools": true,
                "additionalVersions": "3.8,3.9.13,3.10.5"
            }
        }
    }
}


================================================
FILE: test/python/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "version" python  --version
check "pip is installed" pip --version
check "pip is installed" pip3 --version

# Check that tools can execute
check "autopep8" autopep8 --version
check "black" black --version
check "yapf" yapf --version
check "bandit" bandit --version
check "flake8" flake8 --version
check "mypy" mypy --version
check "pycodestyle" pycodestyle --version
check "pydocstyle" pydocstyle --version
check "pylint" pylint --version
check "pytest" pytest --version

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version
check "which autopep8" bash -c "which autopep8 | grep /usr/local/py-utils/bin/autopep8"
check "which black" bash -c "which black | grep /usr/local/py-utils/bin/black"
check "which yapf" bash -c "which yapf | grep /usr/local/py-utils/bin/yapf"
check "which bandit" bash -c "which bandit | grep /usr/local/py-utils/bin/bandit"
check "which flake8" bash -c "which flake8 | grep /usr/local/py-utils/bin/flake8"
check "which mypy" bash -c "which mypy | grep /usr/local/py-utils/bin/mypy"
check "which pycodestyle" bash -c "which pycodestyle | grep /usr/local/py-utils/bin/pycodestyle"
check "which pydocstyle" bash -c "which pydocstyle | grep /usr/local/py-utils/bin/pydocstyle"
check "which pylint" bash -c "which pylint | grep /usr/local/py-utils/bin/pylint"
check "which pytest" bash -c "which pytest | grep /usr/local/py-utils/bin/pytest"

# Report result
reportResults



================================================
FILE: test/python/update_alternatives_switchable_versions.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "python version 3.11 installed as default" bash -c "python --version | grep 3.11"
check "python3 version 3.11 installed as default" bash -c "python3 --version | grep 3.11"
check "python version 3.10.5 installed"  bash -c "ls -l /usr/local/python | grep 3.10.5"
check "python version 3.8 installed"  bash -c "ls -l /usr/local/python | grep 3.8"
check "python version 3.9.13 installed"  bash -c  "ls -l /usr/local/python | grep 3.9.13"

# Check paths in settings
check "current symlink is correct" bash -c "which python | grep /usr/local/python/current/bin/python"
check "current symlink works" /usr/local/python/current/bin/python --version

# check alternatives command
check_version_switch() {
    if type apt-get > /dev/null 2>&1; then
        PYTHON_ALTERNATIVES=$(update-alternatives --query python3 | grep -E 'Alternative:|Priority:')
        STYLE="debian"
    elif type dnf > /dev/null 2>&1 || type yum > /dev/null 2>&1 || type microdnf > /dev/null 2>&1; then
        PYTHON_ALTERNATIVES=$(alternatives --display python3 | grep " - priority")
        STYLE="fedora"
    else
        echo "No supported package manager found."
        exit 1
    fi
    AVAILABLE_VERSIONS=()
    INDEX=1
    echo "Available Python versions:"
    if [ "${STYLE}" = "debian" ]; then
        while read -r alt && read -r pri; do
            PATH=${alt#Alternative: }   # Extract only the path
            PRIORITY=${pri#Priority: }  # Extract only the priority number
            TEMP_VERSIONS+=("${PRIORITY} ${PATH}")
            echo "$INDEX) $PATH (Priority: $PRIORITY)"
            ((INDEX++))
        done <<< "${PYTHON_ALTERNATIVES}"
    elif [ "${STYLE}" = "fedora" ]; then
        export PATH="/usr/bin:$PATH"
        # Fedora/RHEL output: one line per alternative in the format:
        while IFS= read -r line; do
            # Split using " - priority " as a delimiter.
            PATH=$(/usr/bin/awk -F' - priority ' '{print $1}' <<< "$line" | /usr/bin/xargs /bin/echo)
            PRIORITY=$(/usr/bin/awk -F' - priority ' '{print $2}' <<< "$line" | /usr/bin/xargs /bin/echo)    
            TEMP_VERSIONS+=("${PRIORITY} ${PATH}") 
            echo "$INDEX) $PATH (Priority: $PRIORITY_VALUE)"
            ((INDEX++))
        done <<< "${PYTHON_ALTERNATIVES}"
    fi

    export PATH="/usr/bin:$PATH"   
    # Sort by priority (numerically ascending)
    IFS=$'\n' TEMP_VERSIONS=($(sort -n <<<"${TEMP_VERSIONS[*]}"))
    unset IFS

    # Populate AVAILABLE_VERSIONS from sorted data
    AVAILABLE_VERSIONS=()
    INDEX=1
    echo -e "\nAvailable Python versions (Sorted in asc order of priority):"
    for ENTRY in "${TEMP_VERSIONS[@]}"; do
        PRIORITY=${ENTRY%% *}  # Extract priority (first part before space)
        PATH=${ENTRY#* }       # Extract path (everything after first space)
        AVAILABLE_VERSIONS+=("${PATH}")
        echo "$INDEX) $PATH (Priority: $PRIORITY)"
        ((INDEX++))
    done

    echo -e "\nAvailable Versions Count: ${#AVAILABLE_VERSIONS[@]}\n"
    # Ensure at least 4 alternatives exist
    if [ "${#AVAILABLE_VERSIONS[@]}" -lt 4 ]; then
        echo "Error: Less than 4 Python versions registered in update-alternatives."
        exit 1
    fi

    export PATH="/usr/bin:$PATH"
    echo -e "\nSwitching to different versions using update-alternatives --set command...\n"
    for CHOICE in {1..4}; do
        SELECTED_VERSION="${AVAILABLE_VERSIONS[$((CHOICE - 1))]}"
        echo "Switching to: ${SELECTED_VERSION}"
        if command -v apt-get > /dev/null 2>&1; then
            /usr/bin/update-alternatives --set python3 ${SELECTED_VERSION}
        elif command -v dnf > /dev/null 2>&1 || command -v yum > /dev/null 2>&1 || command -v microdnf > /dev/null 2>&1; then
            /usr/sbin/alternatives --set python3 ${SELECTED_VERSION}
        fi
        # Verify the switch
        echo "Python version after switch:"
        /usr/local/python/current/bin/python3 --version
        /bin/sleep 1
        echo -e "\n"
    done
    echo -e "Update-Alternatives --display: \n"
    if type apt-get > /dev/null 2>&1; then
        /usr/bin/update-alternatives --display python3
    elif type dnf > /dev/null 2>&1 || type yum > /dev/null 2>&1 || type microdnf > /dev/null 2>&1; then
        /usr/sbin/alternatives --display python3
    fi
}

check "Version Switch With Update_Alternatives" check_version_switch


================================================
FILE: test/ruby/install_additional_ruby.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "ruby version 3.4.2 installed as default" ruby -v | grep 3.4.2
check "ruby version 3.2.8 installed"  rvm list | grep 3.2.8
check "ruby version 3.3.2 installed"  rvm list | grep 3.3.2

check "rbenv" bash -c 'eval "$(rbenv init -)" && rbenv --version'
check "rake" bash -c "gem list | grep rake"

# Report result
reportResults



================================================
FILE: test/ruby/install_additional_ruby_trixie.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "ruby version 3.4.2 installed as default" ruby -v | grep 3.4.2
check "ruby version 3.2.8 installed"  rvm list | grep 3.2.8
check "ruby version 3.3.2 installed"  rvm list | grep 3.3.2

check "rbenv" bash -c 'eval "$(rbenv init -)" && rbenv --version'
check "rake" bash -c "gem list | grep rake"

# Report result
reportResults




================================================
FILE: test/ruby/install_ruby_trixie_base.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "ruby version" ruby  --version
check "rvm" rvm --version
check "gem version" gem --version

# Report result
reportResults




================================================
FILE: test/ruby/ruby_debian.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "ruby" ruby -v
check "rake" bash -c "gem list | grep rake"

# Report result
reportResults



================================================
FILE: test/ruby/ruby_fallback_test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

USERNAME="automatic"
echo -e "\nRVM version installed previously by ruby feature ..."
check "rvm" rvm --version
check "ruby" ruby -v

trap 'echo "Last executed command failed at line ${LINENO}"' ERR

RVM_GPG_KEYS="409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB"

# Clean up
rm -rf /var/lib/apt/lists/*

# Determine the appropriate non-root user
if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
    USERNAME=""
    POSSIBLE_USERS=("vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
    for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
        if id -u ${CURRENT_USER} > /dev/null 2>&1; then
            USERNAME=${CURRENT_USER}
            break
        fi
    done
    if [ "${USERNAME}" = "" ]; then
        USERNAME=root
    fi
elif [ "${USERNAME}" = "none" ] || ! id -u ${USERNAME} > /dev/null 2>&1; then
    USERNAME=root
fi

# Ensure apt is in non-interactive to avoid prompts
export DEBIAN_FRONTEND=noninteractive

architecture="$(uname -m)"
if [ "${architecture}" != "amd64" ] && [ "${architecture}" != "x86_64" ] && [ "${architecture}" != "arm64" ] && [ "${architecture}" != "aarch64" ]; then
    echo "(!) Architecture $architecture unsupported"
    exit 1
fi

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Get the list of GPG key servers that are reachable
get_gpg_key_servers() {
    declare -A keyservers_curl_map=(
        ["hkp://keyserver.ubuntu.com"]="http://keyserver.ubuntu.com:11371"
        ["hkp://keyserver.ubuntu.com:80"]="http://keyserver.ubuntu.com"
        ["hkps://keys.openpgp.org"]="https://keys.openpgp.org"
        ["hkp://keyserver.pgp.com"]="http://keyserver.pgp.com:11371"
    )

    local curl_args=""
    local keyserver_reachable=false  # Flag to indicate if any keyserver is reachable

    if [ ! -z "${KEYSERVER_PROXY}" ]; then
        curl_args="--proxy ${KEYSERVER_PROXY}"
    fi

    for keyserver in "${!keyservers_curl_map[@]}"; do
        local keyserver_curl_url="${keyservers_curl_map[${keyserver}]}"
        if curl -s ${curl_args} --max-time 5 ${keyserver_curl_url} > /dev/null; then
            echo "keyserver ${keyserver}"
            keyserver_reachable=true
        else
            echo "(*) Keyserver ${keyserver} is not reachable." >&2
        fi
    done

    if ! $keyserver_reachable; then
        echo "(!) No keyserver is reachable." >&2
        exit 1
    fi
}

# Import the specified key in a variable name passed in as 
receive_gpg_keys() {
    local keys=${!1}
    local keyring_args=""
    if [ ! -z "$2" ]; then
        keyring_args="--no-default-keyring --keyring \"$2\""
    fi

    # Install curl
    if ! type curl > /dev/null 2>&1; then
        check_packages curl
    fi

    # Use a temporary location for gpg keys to avoid polluting image
    export GNUPGHOME="/tmp/tmp-gnupg"
    mkdir -p ${GNUPGHOME}
    chmod 700 ${GNUPGHOME}
    echo -e "disable-ipv6\n$(get_gpg_key_servers)" | tee ${GNUPGHOME}/dirmngr.conf > /dev/null
    # GPG key download sometimes fails for some reason and retrying fixes it.
    local retry_count=0
    local gpg_ok="false"
    set +e
    until [ "${gpg_ok}" = "true" ] || [ "${retry_count}" -eq "5" ]; 
    do
        echo "(*) Downloading GPG key..."
        ( echo "${keys}" | xargs -n 1 gpg -q ${keyring_args} --recv-keys) 2>&1 && gpg_ok="true"
        if [ "${gpg_ok}" != "true" ]; then
            echo "(*) Failed getting key, retrying in 10s..."
            (( retry_count++ ))
            sleep 10s
        fi
    done
    set -e
    if [ "${gpg_ok}" = "false" ]; then
        echo "(!) Failed to get gpg key."
        exit 1
    fi
}

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");

    #install jq
    check_packages jq

    message=$(echo "$output" | jq -r '.message')

    if [[ $mode == "mode1" ]]; then
        message="API rate limit exceeded"
    else 
        message=""
    fi
    
    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v" "_"
        declare -g ${variable_name}="${prev_version}"
    else 
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name' | tr '_' '.')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}


# Figure out correct version of a three part version number is not passed
ruby_url="https://github.com/ruby/ruby"

RUBY_VERSION="3.4.xyz"

set_rvm_install_args() {
    RUBY_VERSION=$1
    if [ "${RUBY_VERSION}" = "none" ]; then
        RVM_INSTALL_ARGS=""
    elif [[ "$(ruby -v)" = *"${RUBY_VERSION}"* ]]; then
        echo "(!) Ruby is already installed with version ${RUBY_VERSION}. Skipping..."
        RVM_INSTALL_ARGS=""
    else
        if [ "${RUBY_VERSION}" = "latest" ] || [ "${RUBY_VERSION}" = "current" ] || [ "${RUBY_VERSION}" = "lts" ]; then
            RVM_INSTALL_ARGS="--ruby"
            RUBY_VERSION=""
        else
            RVM_INSTALL_ARGS="--ruby=${RUBY_VERSION}"
        fi
        if [ "${INSTALL_RUBY_TOOLS}" = "true" ]; then
            SKIP_GEM_INSTALL="true"
        else 
            DEFAULT_GEMS=""
        fi
    fi
}

install_previous_version() {
    mode=$1
    repo_url=$(get_github_api_repo_url "$ruby_url")
    get_previous_version "${ruby_url}" "${repo_url}" RUBY_VERSION $mode
    set_rvm_install_args $RUBY_VERSION
    curl -sSL https://get.rvm.io | bash -s stable --ignore-dotfiles ${RVM_INSTALL_ARGS} --with-default-gems="${DEFAULT_GEMS}" 2>&1
}

install_rvm() {
    mode=$1
    # Install RVM
    receive_gpg_keys RVM_GPG_KEYS
    # Determine appropriate settings for rvm installer
    set_rvm_install_args $RUBY_VERSION
    # Create rvm group as a system group to reduce the odds of conflict with local user UIDs
    if ! cat /etc/group | grep -e "^rvm:" > /dev/null 2>&1; then
        groupadd -r rvm
    fi
    # Install rvm
    curl -sSL https://get.rvm.io | bash -s stable --ignore-dotfiles ${RVM_INSTALL_ARGS} --with-default-gems="${DEFAULT_GEMS}" 2>&1 || install_previous_version "$mode"
    sudo usermod -aG rvm ${USERNAME}
    source /usr/local/rvm/scripts/rvm
    rvm fix-permissions system
    rm -rf ${GNUPGHOME}
}

install_rvm "mode1"
echo -e "\nğŸ‘‰ğŸ»ğŸ‘‰ğŸ»RVM version installed by test file ... (mode: 1 - install using find_prev_version_from_git_tags):"
check "rvm" rvm --version

install_rvm "mode2"
echo -e "\nğŸ‘‰ğŸ»ğŸ‘‰ğŸ»RVM version installed by test file ... (mode: 1 - install using GitHub Api):"
check "rvm" rvm --version

# Report result
reportResults


================================================
FILE: test/ruby/scenarios.json
================================================
{   
    "install_ruby_trixie_base": {
        "build": {
            "dockerfile": "Dockerfile"
        },        
        "features": {
            "ghcr.io/devcontainers/features/common-utils:2": {
                "installZsh": "true",
                "username": "vscode",
                "userUid": "1000",
                "userGid": "1000",
                "upgradePackages": "true"
            },
            "ruby": "none",
            "ghcr.io/devcontainers/features/node:1": "none",
            "ghcr.io/devcontainers/features/git:1": {
                "version": "latest",
                "ppa": "false"
            }
        },
        "remoteUser": "vscode"
    },
    "install_additional_ruby_trixie": {
        "image": "debian:trixie",
        "features": {
            "ruby": {
                "version": "3.4.2",
                "additionalVersions": "3.2,3.3.2"
            }
        }
    },       
    "install_additional_ruby": {
        "image": "ubuntu:noble",
        "features": {
            "ruby": {
                "version": "3.4.2",
                "additionalVersions": "3.2,3.3.2"
            }
        }
    },
    "ruby_debian": {
        "image": "mcr.microsoft.com/devcontainers/base:bullseye",
        "features": {
            "ruby": {}
        }
    },
    "ruby_fallback_test": {
        "image": "mcr.microsoft.com/devcontainers/base:bullseye",
        "features": {
            "ruby": {
                "version": "latest"
            }
        }
    }
}


================================================
FILE: test/ruby/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "ruby version" ruby  --version
check "gem version" gem --version

# Report result
reportResults


================================================
FILE: test/ruby/install_ruby_trixie_base/Dockerfile
================================================
# [Choice] Ruby version (use -bullseye variants on local arm64/Apple Silicon): 3, 3.4, 3.3, 3.2, 3-bookworm, 3.4-bookworm, 3.3-bookworm, 3.2-bookworm, 3-bullseye, 3.4-bullseye, 3.3-bullseye, 3.2-bullseye, 3-buster, 3.2-buster
ARG VARIANT=3-trixie
FROM ruby:${VARIANT}

RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \
    # Remove imagemagick due to https://security-tracker.debian.org/tracker/CVE-2019-10131
    && apt-get purge -y imagemagick imagemagick-6-common 

# [Optional] Uncomment this section to install additional OS packages.
# RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \
#     && apt-get -y install --no-install-recommends <your-package-list-here>

# [Optional] Uncomment this line to install additional gems.
# RUN gem install <your-gem-names-here>

# [Optional] Uncomment this line to install global node packages.
# RUN su vscode -c "source /usr/local/share/nvm/nvm.sh && npm install -g <your-package-here>" 2>&1




================================================
FILE: test/rust/rust_at_pinned_version.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "cargo version" cargo  --version
check "rustc version" rustc  --version
check "correct rust version" rustc  --version | grep 1.64.0


# Report result
reportResults


================================================
FILE: test/rust/rust_with_almalinux_8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Definition specific tests
check "cargo version" cargo  --version
check "rustc version" rustc  --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that all specified extended components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"
check "clippy is installed" check_component_installed "clippy"
check "rust-docs is installed" check_component_installed "rust-docs"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_almalinux_9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Definition specific tests
check "cargo version" cargo  --version
check "rustc version" rustc  --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that all specified extended components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"
check "clippy is installed" check_component_installed "clippy"
check "rust-docs is installed" check_component_installed "rust-docs"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_centos.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Definition specific tests
check "cargo version" cargo  --version
check "rustc version" rustc  --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that all specified extended components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"
check "clippy is installed" check_component_installed "clippy"
check "rust-docs is installed" check_component_installed "rust-docs"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_custom_components.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Helper function to check component is NOT installed
check_component_not_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 1  # Component is installed (failure)
    else
        return 0  # Component is not installed (success)
    fi
}

# Definition specific tests
check "cargo version" cargo --version
check "rustc version" rustc --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that specified custom components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"

# Check that clippy NOT installed
check "clippy not installed" check_component_not_installed "clippy"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_default_components.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Definition specific tests
check "cargo version" cargo --version
check "rustc version" rustc --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that default components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"
check "clippy is installed" check_component_installed "clippy"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_empty_components.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Helper function to check component is NOT installed
check_component_not_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 1  # Component is installed (failure)
    else
        return 0  # Component is not installed (success)
    fi
}

# Definition specific tests
check "cargo version" cargo --version
check "rustc version" rustc --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that no additional components are installed when empty list is provided
# Only the basic rust toolchain should be available
check "basic rust toolchain" rustc --version

# Verify that default components are automatically installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"
check "clippy is installed" check_component_installed "clippy"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_extended_components.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Definition specific tests
check "cargo version" cargo --version
check "rustc version" rustc --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that all specified extended components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"
check "clippy is installed" check_component_installed "clippy"
check "rust-docs is installed" check_component_installed "rust-docs"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_fedora.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Definition specific tests
check "cargo version" cargo  --version
check "rustc version" rustc  --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that all specified extended components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"
check "clippy is installed" check_component_installed "clippy"
check "rust-docs is installed" check_component_installed "rust-docs"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_mariner.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Definition specific tests
check "cargo version" cargo  --version
check "rustc version" rustc  --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that all specified extended components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"
check "clippy is installed" check_component_installed "clippy"
check "rust-docs is installed" check_component_installed "rust-docs"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_minimal_components.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Helper function to check component is NOT installed
check_component_not_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 1  # Component is installed (failure)
    else
        return 0  # Component is not installed (success)
    fi
}

# Definition specific tests
check "cargo version" cargo --version
check "rustc version" rustc --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that only specified minimal components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"

# Check that other default components are NOT installed
check "rustfmt not installed" check_component_not_installed "rustfmt"
check "clippy not installed" check_component_not_installed "clippy"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_rockylinux_8.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Definition specific tests
check "cargo version" cargo  --version
check "rustc version" rustc  --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that all specified extended components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"
check "clippy is installed" check_component_installed "clippy"
check "rust-docs is installed" check_component_installed "rust-docs"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_rockylinux_9.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Helper function to check component is installed
check_component_installed() {
    local component=$1
    if rustup component list | grep -q "${component}.*installed"; then
        return 0  # Component is installed (success)
    else
        return 1  # Component is not installed (failure)
    fi
}

# Definition specific tests
check "cargo version" cargo  --version
check "rustc version" rustc  --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu

# Check that all specified extended components are installed
check "rust-analyzer is installed" check_component_installed "rust-analyzer"
check "rust-src is installed" check_component_installed "rust-src"
check "rustfmt is installed" check_component_installed "rustfmt"
check "clippy is installed" check_component_installed "clippy"
check "rust-docs is installed" check_component_installed "rust-docs"

# Report result
reportResults




================================================
FILE: test/rust/rust_with_target.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "cargo version" cargo  --version
check "rustc version" rustc  --version
check "correct rust version" rustup target list | grep aarch64-unknown-linux-gnu


# Report result
reportResults


================================================
FILE: test/rust/scenarios.json
================================================
{
    "rust_at_pinned_version": {
        "image": "ubuntu:noble",
        "features": {
            "rust": {
                "version": "1.64.0"
            }
        }
    },
    "rust_with_target": {
        "image": "ubuntu:noble",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu"
            }
        }
    },
    "rust_with_default_components": {
        "image": "ubuntu:noble",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu"
            }
        }
    },
    "rust_with_custom_components": {
        "image": "ubuntu:noble",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": "rust-analyzer,rust-src,rustfmt"
            }
        }
    },
    "rust_with_minimal_components": {
        "image": "ubuntu:noble",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": "rust-analyzer,rust-src"
            }
        }
    },
    "rust_with_extended_components": {
        "image": "ubuntu:noble",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": "rust-analyzer,rust-src,rustfmt,clippy,rust-docs"
            }
        }
    },
    "rust_with_empty_components": {
        "image": "ubuntu:noble",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": ""
            }
        }
    },    
    "rust_with_centos": {
        "image": "centos:centos7",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": "rust-analyzer,rust-src,rustfmt,clippy,rust-docs"                
            }
        }
    },
    "rust_with_almalinux_8": {
        "image": "almalinux:8",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": "rust-analyzer,rust-src,rustfmt,clippy,rust-docs"                
            }
        }
    },
    "rust_with_almalinux_9": {
        "image": "almalinux:9",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": "rust-analyzer,rust-src,rustfmt,clippy,rust-docs"                
            }
        }
    },
    "rust_with_rockylinux_8": {
        "image": "rockylinux:8",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": "rust-analyzer,rust-src,rustfmt,clippy,rust-docs"                
            }
        }
    },
    "rust_with_rockylinux_9": {
        "image": "rockylinux:9",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": "rust-analyzer,rust-src,rustfmt,clippy,rust-docs"                
            }
        }
    },
    "rust_with_fedora": {
        "image": "fedora",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": "rust-analyzer,rust-src,rustfmt,clippy,rust-docs"                
            }
        }
    },
    "rust_with_mariner": {
        "image": "mcr.microsoft.com/cbl-mariner/base/core:2.0",
        "features": {
            "rust": {
                "version": "latest",
                "targets": "aarch64-unknown-linux-gnu",
                "components": "rust-analyzer,rust-src,rustfmt,clippy,rust-docs"                
            }
        }
    }                                                                
}



================================================
FILE: test/rust/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "cargo version" cargo  --version
check "rustc version" rustc  --version


# Report result
reportResults


================================================
FILE: test/sshd/scenarios.json
================================================
{
    "sshd_with_default_gateway_ports": {
        "image": "ubuntu:noble",
        "features": {
            "sshd": {
                "gatewayPorts": "no"
            }
        }
    },
    "sshd_with_pinned_gateway_ports_clientspecified": {
        "image": "ubuntu:noble",
        "features": {
            "sshd": {
                "gatewayPorts": "clientspecified"
            }
        }
    }                                                           
}



================================================
FILE: test/sshd/sshd_with_default_gateway_ports.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "correct default GatewayPorts" grep "GatewayPorts no" /etc/ssh/sshd_config

# Report result
reportResults


================================================
FILE: test/sshd/sshd_with_pinned_gateway_ports_clientspecified.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

# Definition specific tests
check "correct default GatewayPorts" grep "GatewayPorts clientspecified" /etc/ssh/sshd_config

# Report result
reportResults


================================================
FILE: test/sshd/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "sshd-init-exists" bash -c "ls /usr/local/share/ssh-init.sh"
check "sshd-log-exists" bash -c "ls /tmp/sshd.log"
check "sshd-log-contents" bash -c "cat /tmp/sshd.log | grep 'Starting OpenBSD Secure Shell server'"
check "sshd-log-has-sshd" bash -c "cat /tmp/sshd.log | grep 'sshd'"
check "sshd" bash -c "ps -aux | grep -v grep | grep sshd"

# Report result
reportResults


================================================
FILE: test/terraform/custom_download_server.sh
================================================
#!/bin/bash

set -e

# Import test library
source dev-container-features-test-lib

# Check if terraform was installed correctly and it's the expected version
check "terraform installed" terraform --version
check "terraform version matches" terraform --version | grep "1.6.5"

# Report results
reportResults



================================================
FILE: test/terraform/custom_download_server_with_sentinel.sh
================================================
#!/bin/bash

set -e

# Import test library
source dev-container-features-test-lib

# Check if terraform was installed correctly and it's the expected version
check "terraform installed" terraform --version
check "terraform version matches" terraform --version | grep "1.6.5"

# Check if sentinel was installed correctly
check "sentinel installed" sentinel --version

# Report results
reportResults



================================================
FILE: test/terraform/install_in_ubuntu_noble.sh
================================================
#!/bin/bash

set -e

# Import test library
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

# Check if terraform was installed correctly
check "terraform installed" terraform --version

check "tflint" tflint --version

# Report results
reportResults




================================================
FILE: test/terraform/install_in_ubuntu_noble_sentinel.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

# Check if terraform was installed correctly
check "terraform installed" terraform --version

check "tflint" tflint --version

# Sentinel specific tests
check "sentinel" sentinel --version

# Report result
reportResults




================================================
FILE: test/terraform/install_in_ubuntu_trixie.sh
================================================
#!/bin/bash

set -e

# Import test library
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

# Check if terraform was installed correctly
check "terraform installed" terraform --version

check "tflint" tflint --version

# Report results
reportResults





================================================
FILE: test/terraform/install_in_ubuntu_trixie_sentinel.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

# Check if terraform was installed correctly
check "terraform installed" terraform --version

check "tflint" tflint --version

# Sentinel specific tests
check "sentinel" sentinel --version

# Report result
reportResults





================================================
FILE: test/terraform/install_sentinel.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

# Sentinel specific tests
check "sentinel" sentinel --version

# Report result
reportResults


================================================
FILE: test/terraform/install_terraform_docs.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

# Terraform Docs specific tests
check "tfsec" terraform-docs --version

# Report result
reportResults


================================================
FILE: test/terraform/install_tfsec.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

# TFSec specific tests
check "tfsec" tfsec --version

# Report result
reportResults


================================================
FILE: test/terraform/older_tflint.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "terraform" terraform -version

check "tflint" tflint --version

# Report result
reportResults


================================================
FILE: test/terraform/scenarios.json
================================================
{
    "install_in_ubuntu_trixie": {
        "image": "mcr.microsoft.com/devcontainers/base:trixie",
        "features": {
            "terraform": {
                "version": "latest"
            }
        }
    },
    "install_in_ubuntu_trixie_sentinel": {
        "image": "mcr.microsoft.com/devcontainers/base:trixie",
        "features": {
            "terraform": {
                "installSentinel": true
            }
        }
    },    
    "install_in_ubuntu_noble": {
        "image": "mcr.microsoft.com/devcontainers/base:noble",
        "features": {
            "terraform": {
                "version": "latest"
            }
        }
    },
    "install_in_ubuntu_noble_sentinel": {
        "image": "mcr.microsoft.com/devcontainers/base:noble",
        "features": {
            "terraform": {
                "installSentinel": true
            }
        }
    },
    "install_sentinel": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "installSentinel": true
            }
        }
    },
    "install_tfsec": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "installTFsec": true
            }
        }
    },
    "tfsec_fallback_test": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "installTFsec": true
            }
        }
    },
    "install_terraform_docs": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "installTerraformDocs": true
            }
        }
    },
    "terraform_docs_fallback_test": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "installTerraformDocs": true
            }
        }
    },
    "terraform_fallback_test": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "version": "latest"
            }
        }
    },
    "terragrunt_fallback_test": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "terragrunt": "latest"
            }
        }
    },
    "tflint_fallback_test": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "tflint": "latest"
            }
        }
    },
    "older_tflint": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "tflint": "0.40.0"
            }
        }
    },
    "custom_download_server": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "version": "1.6.5",
                "customDownloadServer": "https://releases.hashicorp.com"
            }
        }
    },
    "custom_download_server_with_sentinel": {
        "image": "mcr.microsoft.com/devcontainers/base:jammy",
        "features": {
            "terraform": {
                "version": "1.6.5",
                "installSentinel": true,
                "customDownloadServer": "https://releases.hashicorp.com"
            }
        }
    }
}


================================================
FILE: test/terraform/terraform_docs_fallback_test.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

# Terraform Docs specific tests
check "terraform-docs version as installed by feature" terraform-docs --version

TERRAFORM_DOCS_SHA256="automatic"

set_error_handler() {
    echo "Error occurred on line: $LINENO"
}

# Register the error handler function to be triggered on ERR signal
trap 'set_error_handler' ERR

architecture="$(uname -m)"
case ${architecture} in
    x86_64) architecture="amd64";;
    aarch64 | armv8*) architecture="arm64";;
    aarch32 | armv7* | armvhf*) architecture="arm";;
    i?86) architecture="386";;
    *) echo "(!) Architecture ${architecture} unsupported"; exit 1 ;;
esac

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");

    # install jq
    check_packages jq
    
    message=$(echo "$output" | jq -r '.message')
    if [[ "$mode" == "mode1" ]]; then
        message="API rate limit exceeded";
    elif [[ "$mode" == "mode2" ]]; then
        message=""
    fi 
    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="${prev_version}"
    else
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}

install_previous_version() {
    given_version=$1
    requested_version=${!given_version}
    local URL=$2
    local mode=$3
    INSTALLER_FN=$4
    local REPO_URL=$(get_github_api_repo_url "$URL")
    local PKG_NAME=$(get_pkg_name "${given_version}")
    echo -e "\n(!) Failed to fetch the latest artifacts for ${PKG_NAME} v${requested_version}..."
    get_previous_version "$URL" "$REPO_URL" requested_version $mode
    echo -e "\nAttempting to install ${requested_version}"
    declare -g ${given_version}="${requested_version#v}"
    $INSTALLER_FN "${!given_version}"
    echo "${given_version}=${!given_version}"
}

install_terraform_docs() {
    local TERRAFORM_DOCS_VERSION=$1
    tfdocs_filename="terraform-docs-v${TERRAFORM_DOCS_VERSION}-linux-${architecture}.tar.gz"
    curl -sSL -o /tmp/tf-downloads/${tfdocs_filename} https://github.com/terraform-docs/terraform-docs/releases/download/v${TERRAFORM_DOCS_VERSION}/${tfdocs_filename}
}


try_install_terraform_docs_dummy_version() {
    mode=$1
    mkdir -p /tmp/tf-downloads
    cd /tmp/tf-downloads
    TERRAFORM_DOCS_VERSION="0.17.xyz"
    echo -e "\nInstalling TERRAFORM_DOCS dummy version.." v${TERRAFORM_DOCS_VERSION}
    terraform_docs_url='https://github.com/terraform-docs/terraform-docs'
    tfdocs_filename="terraform-docs-v${TERRAFORM_DOCS_VERSION}-linux-${architecture}.tar.gz"
    echo "(*) Downloading Terraform docs... ${tfdocs_filename}"
    install_terraform_docs "$TERRAFORM_DOCS_VERSION"
    if grep -q "Not Found" "/tmp/tf-downloads/${tfdocs_filename}"; then
        install_previous_version TERRAFORM_DOCS_VERSION $terraform_docs_url $mode "install_terraform_docs"
        tfdocs_filename="terraform-docs-v${TERRAFORM_DOCS_VERSION}-linux-${architecture}.tar.gz"
    fi
    if [ "${TERRAFORM_DOCS_SHA256}" != "dev-mode" ]; then
        if [ "${TERRAFORM_DOCS_SHA256}" = "automatic" ]; then
            curl -sSL -o tfdocs_SHA256SUMS https://github.com/terraform-docs/terraform-docs/releases/download/v${TERRAFORM_DOCS_VERSION}/terraform-docs-v${TERRAFORM_DOCS_VERSION}.sha256sum
        else
            echo "${TERRAFORM_DOCS_SHA256} *${tfsec_filename}" > tfdocs_SHA256SUMS
        fi
        sha256sum --ignore-missing -c tfdocs_SHA256SUMS
    fi
    mkdir -p /tmp/tf-downloads/tfdocs
    tar -xzf /tmp/tf-downloads/${tfdocs_filename} -C /tmp/tf-downloads/tfdocs
    sudo chmod a+x /tmp/tf-downloads/tfdocs/terraform-docs
    sudo mv -f /tmp/tf-downloads/tfdocs/terraform-docs /usr/local/bin/terraform-docs
}

try_install_terraform_docs_dummy_version "mode1"

check "terraform-docs version as installed by test (mode 1: install using find_prev_version_from_git_tags)" terraform-docs --version

try_install_terraform_docs_dummy_version "mode2"

check "terraform-docs version as installed by test (mode 2: install using GitHub Api)" terraform-docs --version

# Report result
reportResults


================================================
FILE: test/terraform/terraform_fallback_test.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

set_error_handler() {
    echo "Error occurred on line: $LINENO"
}

# Register the error handler function to be triggered on ERR signal
trap 'set_error_handler' ERR

check "terraform version as installed by feature" terraform --version

architecture="$(uname -m)"
case ${architecture} in
    x86_64) architecture="amd64";;
    aarch64 | armv8*) architecture="arm64";;
    aarch32 | armv7* | armvhf*) architecture="arm";;
    i?86) architecture="386";;
    *) echo "(!) Architecture ${architecture} unsupported"; exit 1 ;;
esac

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");

    # install jq
    check_packages jq

    message=$(echo "$output" | jq -r '.message')
    if [[ "$mode" == "mode1" ]]; then
        message="API rate limit exceeded";
    elif [[ "$mode" == "mode2" ]]; then
        message=""
    fi 
    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="${prev_version}"
    else
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}

install_previous_version() {
    given_version=$1
    requested_version=${!given_version}
    local URL=$2
    local mode=$3
    INSTALLER_FN=$4
    local REPO_URL=$(get_github_api_repo_url "$URL")
    local PKG_NAME=$(get_pkg_name "${given_version}")
    echo -e "\n(!) Failed to fetch the latest artifacts for ${PKG_NAME} v${requested_version}..."
    get_previous_version "$URL" "$REPO_URL" requested_version $mode
    echo -e "\nAttempting to install ${requested_version}"
    declare -g ${given_version}="${requested_version#v}"
    $INSTALLER_FN "${!given_version}"
    echo "${given_version}=${!given_version}"
}

install_terraform() {
    local TERRAFORM_VERSION=$1
    terraform_filename="terraform_${TERRAFORM_VERSION}_linux_${architecture}.zip"
    curl -sSL -o ${terraform_filename} "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/${terraform_filename}"
}

try_install_dummy_terraform_version() {
    mode=$1
    mkdir -p /tmp/tf-downloads
    cd /tmp/tf-downloads
    terraform_url='https://github.com/hashicorp/terraform'
    TERRAFORM_VERSION="1.7.xyz"
    echo -e "\nAttempting to install dummy version for Terraform v${TERRAFORM_VERSION}..."
    terraform_filename="terraform_${TERRAFORM_VERSION}_linux_${architecture}.zip"
    install_terraform "$TERRAFORM_VERSION"
    if grep -q "The specified key does not exist." "${terraform_filename}"; then
        install_previous_version TERRAFORM_VERSION $terraform_url $mode "install_terraform"
        terraform_filename="terraform_${TERRAFORM_VERSION}_linux_${architecture}.zip"
    fi
    unzip ${terraform_filename}
    sudo mv -f terraform /usr/local/bin/
}

try_install_dummy_terraform_version "mode1"

check "terraform version as installed by test after fallbacking from the dummy version (mode 1: install using find_prev_version_from_git_tags)" terraform --version

try_install_dummy_terraform_version "mode2"

check "terraform version as installed by test after fallbacking from the dummy version (mode 2: install using GitHub Api)" terraform --version

# Report result
reportResults




================================================
FILE: test/terraform/terragrunt_fallback_test.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

set_error_handler() {
    echo "Error occurred on line: $LINENO"
}

# Register the error handler function to be triggered on ERR signal
trap 'set_error_handler' ERR

check "terragrunt version as installed by feature" terragrunt --version

TERRAGRUNT_SHA256="automatic"

architecture="$(uname -m)"
case ${architecture} in
    x86_64) architecture="amd64";;
    aarch64 | armv8*) architecture="arm64";;
    aarch32 | armv7* | armvhf*) architecture="arm";;
    i?86) architecture="386";;
    *) echo "(!) Architecture ${architecture} unsupported"; exit 1 ;;
esac

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}


# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");

    # install jq
    check_packages jq

    message=$(echo "$output" | jq -r '.message')
    if [[ "$mode" == "mode1" ]]; then
        message="API rate limit exceeded";
    elif [[ "$mode" == "mode2" ]]; then
        message=""
    fi 
    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="${prev_version}"
    else
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}

install_previous_version() {
    given_version=$1
    requested_version=${!given_version}
    local URL=$2
    local mode=$3
    INSTALLER_FN=$4
    local REPO_URL=$(get_github_api_repo_url "$URL")
    local PKG_NAME=$(get_pkg_name "${given_version}")
    echo -e "\n(!) Failed to fetch the latest artifacts for ${PKG_NAME} v${requested_version}..."
    get_previous_version "$URL" "$REPO_URL" requested_version $mode
    echo -e "\nAttempting to install ${requested_version}"
    declare -g ${given_version}="${requested_version#v}"
    $INSTALLER_FN "${!given_version}"
    echo "${given_version}=${!given_version}"
}


install_terragrunt() {
    TERRAGRUNT_VERSION=$1
    curl -sSL -o /tmp/tf-downloads/${terragrunt_filename} https://github.com/gruntwork-io/terragrunt/releases/download/v${TERRAGRUNT_VERSION}/${terragrunt_filename}
}


try_install_dummy_terragrunt_version() {
    mode=$1
    mkdir -p /tmp/tf-downloads
    cd /tmp/tf-downloads
    terragrunt_url='https://github.com/gruntwork-io/terragrunt'
    TERRAGRUNT_VERSION="0.55.xyz"
    echo -e "\nAttempting to install terragrunt dummy v${TERRAGRUNT_VERSION}"
    echo "Downloading Terragrunt... v${TERRAGRUNT_VERSION}"
    terragrunt_filename="terragrunt_linux_${architecture}"
    install_terragrunt "$TERRAGRUNT_VERSION"
    output=$(cat "/tmp/tf-downloads/${terragrunt_filename}")
    if [[ $output == "Not Found" ]]; then
        install_previous_version TERRAGRUNT_VERSION $terragrunt_url $mode "install_terragrunt"
    fi
    if [ "${TERRAGRUNT_SHA256}" != "dev-mode" ]; then
        if [ "${TERRAGRUNT_SHA256}" = "automatic" ]; then
            curl -sSL -o terragrunt_SHA256SUMS https://github.com/gruntwork-io/terragrunt/releases/download/v${TERRAGRUNT_VERSION}/SHA256SUMS
        else
            echo "${TERRAGRUNT_SHA256} *${terragrunt_filename}" > terragrunt_SHA256SUMS
        fi
        sha256sum --ignore-missing -c terragrunt_SHA256SUMS
    fi
    sudo chmod a+x /tmp/tf-downloads/${terragrunt_filename}
    sudo mv -f /tmp/tf-downloads/${terragrunt_filename} /usr/local/bin/terragrunt
}

try_install_dummy_terragrunt_version "mode1"

check "terragrunt version as installed by test after fallbacking from the dummy version (mode 1: install using find_prev_version_from_git_tags)" terragrunt --version

try_install_dummy_terragrunt_version "mode2"

check "terragrunt version as installed by test after fallbacking from the dummy version (mode 2: install using GitHub Api)" terragrunt --version

# Report result
reportResults




================================================
FILE: test/terraform/test.sh
================================================
#!/bin/bash

set -e

# Optional: Import test library
source dev-container-features-test-lib

check "terraform" terraform -version

# Report result
reportResults


================================================
FILE: test/terraform/tflint_fallback_test.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

set_error_handler() {
    echo "Error occurred on line: $LINENO"
}

# Register the error handler function to be triggered on ERR signal
trap 'set_error_handler' ERR

TFLINT_SHA256="automatic"

GPG_KEY_SERVERS="keyserver hkps://keyserver.ubuntu.com
keyserver hkps://keys.openpgp.org
keyserver hkps://keyserver.pgp.com"

check "tflint version as installed by feature" tflint --version
check "cosign version as installed by feature" cosign version

architecture="$(uname -m)"
case ${architecture} in
    x86_64) architecture="amd64";;
    aarch64 | armv8*) architecture="arm64";;
    aarch32 | armv7* | armvhf*) architecture="arm";;
    i?86) architecture="386";;
    *) echo "(!) Architecture ${architecture} unsupported"; exit 1 ;;
esac

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");
    
    # install jq
    check_packages jq

    message=$(echo "$output" | jq -r '.message')
    if [[ "$mode" == "mode1" ]]; then
        message="API rate limit exceeded";
    elif [[ "$mode" == "mode2" ]]; then
        message=""
    fi 
    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="${prev_version}"
    else
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}

install_previous_version() {
    given_version=$1
    requested_version=${!given_version}
    local URL=$2
    local mode=$3
    INSTALLER_FN=$4
    local REPO_URL=$(get_github_api_repo_url "$URL")
    local PKG_NAME=$(get_pkg_name "${given_version}")
    echo -e "\n(!) Failed to fetch the latest artifacts for ${PKG_NAME} v${requested_version}..."
    get_previous_version "$URL" "$REPO_URL" requested_version $mode
    echo -e "\nAttempting to install ${requested_version}"
    declare -g ${given_version}="${requested_version#v}"
    $INSTALLER_FN "${!given_version}"
    echo "${given_version}=${!given_version}"
}

install_cosign() {
    COSIGN_VERSION=$1
    local URL=$2
    local mode=$3
    cosign_filename="/tmp/cosign_${COSIGN_VERSION}_${architecture}.deb"
    cosign_url="https://github.com/sigstore/cosign/releases/latest/download/cosign_${COSIGN_VERSION}_${architecture}.deb"
    curl -L "${cosign_url}" -o $cosign_filename
    if grep -q "Not Found" "$cosign_filename"; then
        echo -e "\n(!) Failed to fetch the latest artifacts for cosign v${COSIGN_VERSION}..."
        REPO_URL=$(get_github_api_repo_url "$URL")
        get_previous_version "$URL" "$REPO_URL" COSIGN_VERSION $mode
        echo -e "\nAttempting to install ${COSIGN_VERSION}"
        cosign_filename="/tmp/cosign_${COSIGN_VERSION}_${architecture}.deb"
        cosign_url="https://github.com/sigstore/cosign/releases/latest/download/cosign_${COSIGN_VERSION}_${architecture}.deb"
        curl -L "${cosign_url}" -o $cosign_filename
    fi
    dpkg -i $cosign_filename
    rm $cosign_filename
    echo "Installation of cosign succeeded with ${COSIGN_VERSION}."
}

# Install 'cosign' for validating signatures
# https://docs.sigstore.dev/cosign/overview/
ensure_cosign() {
    mode=$1
    if ! type cosign > /dev/null 2>&1; then
        echo -e "\nAttempting to install dummy cosign version..."
        COSIGN_VERSION="2.2.xyz"
        echo "Installing cosign... v${COSIGN_VERSION}"
        cosign_url='https://github.com/sigstore/cosign'
        install_cosign "${COSIGN_VERSION}" "${cosign_url}" $mode
    fi
    if ! type cosign > /dev/null 2>&1; then
        echo "(!) Failed to install cosign."
        exit 1
    fi
    cosign version
}

install_tflint() {
    TFLINT_VERSION=$1
    curl -sSL -o /tmp/tf-downloads/${TFLINT_FILENAME} https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/${TFLINT_FILENAME}
}


try_install_dummy_tflint_cosign_version() {
    mode=$1
    tflint_url='https://github.com/terraform-linters/tflint'
    mkdir -p /tmp/tf-downloads
    cd /tmp/tf-downloads
    echo -e "\nTrying to install dummy tflint version..."
    TFLINT_VERSION="0.50.XYZ"
    echo "Downloading tflint...v${TFLINT_VERSION}"
    TFLINT_FILENAME="tflint_linux_${architecture}.zip"
    install_tflint "$TFLINT_VERSION"
    if grep -q "Not Found" "/tmp/tf-downloads/${TFLINT_FILENAME}"; then 
        install_previous_version TFLINT_VERSION "$tflint_url" $mode "install_tflint"
    fi
    if [ "${TFLINT_SHA256}" != "dev-mode" ]; then

        if [ "${TFLINT_SHA256}" != "automatic" ]; then
            echo "${TFLINT_SHA256} *${TFLINT_FILENAME}" > tflint_checksums.txt
            sha256sum --ignore-missing -c tflint_checksums.txt
        else
            curl -sSL -o tflint_checksums.txt https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/checksums.txt

            set +e
            curl -sSL -o checksums.txt.keyless.sig https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/checksums.txt.keyless.sig
            set -e
            
            # Check that checksums.txt.keyless.sig exists and is not empty
            if [ -s checksums.txt.keyless.sig ]; then
                # Validate checksums with cosign
                curl -sSL -o checksums.txt.pem https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/checksums.txt.pem
                ensure_cosign $mode
                cosign verify-blob \
                    --certificate=/tmp/tf-downloads/checksums.txt.pem \
                    --signature=/tmp/tf-downloads/checksums.txt.keyless.sig \
                    --certificate-identity-regexp="^https://github.com/terraform-linters/tflint"  \
                    --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
                    /tmp/tf-downloads/tflint_checksums.txt
                # Ensure that checksums.txt has $TFLINT_FILENAME
                grep ${TFLINT_FILENAME} /tmp/tf-downloads/tflint_checksums.txt
                # Validate downloaded file
                sha256sum --ignore-missing -c tflint_checksums.txt
            else
                # Fallback to older, GPG-based verification (pre-0.47.0 of tflint)
                curl -sSL -o tflint_checksums.txt.sig https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/checksums.txt.sig
                curl -sSL -o tflint_key "${TFLINT_GPG_KEY_URI}"
                gpg -q --import tflint_key
                gpg --verify tflint_checksums.txt.sig tflint_checksums.txt
            fi
        fi
    fi

    unzip /tmp/tf-downloads/${TFLINT_FILENAME}
    sudo mv -f tflint /usr/local/bin/
}

try_install_dummy_tflint_cosign_version "mode1"

check "tflint version as installed when mode=1" tflint --version
check "cosign version as installed when mode=1" cosign version

try_install_dummy_tflint_cosign_version "mode2"

check "tflint version as installed when mode=2" tflint --version
check "cosign version as installed when mode=2" cosign version


================================================
FILE: test/terraform/tfsec_fallback_test.sh
================================================
#!/bin/bash

set -e

# Import test library for `check` command
source dev-container-features-test-lib

# Check to make sure the user is vscode
check "user is vscode" whoami | grep vscode

set_error_handler() {
    echo "Error occurred on line: $LINENO"
}

# Register the error handler function to be triggered on ERR signal
trap 'set_error_handler' ERR

# Trap errors and call the error handling function
trap 'handle_error' ERR

architecture="$(uname -m)"
case ${architecture} in
    x86_64) architecture="amd64";;
    aarch64 | armv8*) architecture="arm64";;
    aarch32 | armv7* | armvhf*) architecture="arm";;
    i?86) architecture="386";;
    *) echo "(!) Architecture ${architecture} unsupported"; exit 1 ;;
esac

TFSEC_SHA256="automatic"

# TFSec specific tests
check "tfsec version as installed by feature" tfsec --version

# Figure out correct version of a three part version number is not passed
find_version_from_git_tags() {
    local variable_name=$1
    local requested_version=${!variable_name}
    if [ "${requested_version}" = "none" ]; then return; fi
    local repository=$2
    local prefix=${3:-"tags/v"}
    local separator=${4:-"."}
    local last_part_optional=${5:-"false"}    
    if [ "$(echo "${requested_version}" | grep -o "." | wc -l)" != "2" ]; then
        local escaped_separator=${separator//./\\.}
        local last_part
        if [ "${last_part_optional}" = "true" ]; then
            last_part="(${escaped_separator}[0-9]+)?"
        else
            last_part="${escaped_separator}[0-9]+"
        fi
        local regex="${prefix}\\K[0-9]+${escaped_separator}[0-9]+${last_part}$"
        local version_list="$(git ls-remote --tags ${repository} | grep -oP "${regex}" | tr -d ' ' | tr "${separator}" "." | sort -rV)"
        if [ "${requested_version}" = "latest" ] || [ "${requested_version}" = "current" ] || [ "${requested_version}" = "lts" ]; then
            declare -g ${variable_name}="$(echo "${version_list}" | head -n 1)"
        else
            set +e
            declare -g ${variable_name}="$(echo "${version_list}" | grep -E -m 1 "^${requested_version//./\\.}([\\.\\s]|$)")"
            set -e
        fi
    fi
    if [ -z "${!variable_name}" ] || ! echo "${version_list}" | grep "^${!variable_name//./\\.}$" > /dev/null 2>&1; then
        echo -e "Invalid ${variable_name} value: ${requested_version}\nValid values:\n${version_list}" >&2
        exit 1
    fi
    echo "${variable_name}=${!variable_name}"
}

# Use semver logic to decrement a version number then look for the closest match
find_prev_version_from_git_tags() {
    local variable_name=$1
    local current_version=${!variable_name}
    local repository=$2
    # Normally a "v" is used before the version number, but support alternate cases
    local prefix=${3:-"tags/v"}
    # Some repositories use "_" instead of "." for version number part separation, support that
    local separator=${4:-"."}
    # Some tools release versions that omit the last digit (e.g. go)
    local last_part_optional=${5:-"false"}
    # Some repositories may have tags that include a suffix (e.g. actions/node-versions)
    local version_suffix_regex=$6
    # Try one break fix version number less if we get a failure. Use "set +e" since "set -e" can cause failures in valid scenarios.
    set +e
        major="$(echo "${current_version}" | grep -oE '^[0-9]+' || echo '')"
        minor="$(echo "${current_version}" | grep -oP '^[0-9]+\.\K[0-9]+' || echo '')"
        breakfix="$(echo "${current_version}" | grep -oP '^[0-9]+\.[0-9]+\.\K[0-9]+' 2>/dev/null || echo '')"

        if [ "${minor}" = "0" ] && [ "${breakfix}" = "0" ]; then
            ((major=major-1))
            declare -g ${variable_name}="${major}"
            # Look for latest version from previous major release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        # Handle situations like Go's odd version pattern where "0" releases omit the last part
        elif [ "${breakfix}" = "" ] || [ "${breakfix}" = "0" ]; then
            ((minor=minor-1))
            declare -g ${variable_name}="${major}.${minor}"
            # Look for latest version from previous minor release
            find_version_from_git_tags "${variable_name}" "${repository}" "${prefix}" "${separator}" "${last_part_optional}"
        else
            ((breakfix=breakfix-1))
            if [ "${breakfix}" = "0" ] && [ "${last_part_optional}" = "true" ]; then
                declare -g ${variable_name}="${major}.${minor}"
            else 
                declare -g ${variable_name}="${major}.${minor}.${breakfix}"
            fi
        fi
    set -e
}

apt_get_update()
{
    if [ "$(find /var/lib/apt/lists/* | wc -l)" = "0" ]; then
        echo "Running apt-get update..."
        apt-get update -y
    fi
}

# Checks if packages are installed and installs them if not
check_packages() {
    if ! dpkg -s "$@" > /dev/null 2>&1; then
        apt_get_update
        apt-get -y install --no-install-recommends "$@"
    fi
}

# Function to fetch the version released prior to the latest version
get_previous_version() {
    local url=$1
    local repo_url=$2
    local variable_name=$3
    local mode=$4
    prev_version=${!variable_name}
    
    output=$(curl -s "$repo_url");

    # install jq
    check_packages jq

    message=$(echo "$output" | jq -r '.message')

    if [[ "$mode" == "mode1" ]]; then
        message="API rate limit exceeded";
    elif [[ "$mode" == "mode2" ]]; then
        message=""
    fi 

    if [[ $message == "API rate limit exceeded"* ]]; then
        echo -e "\nAn attempt to find latest version using GitHub Api Failed... \nReason: ${message}"
        echo -e "\nAttempting to find latest version using GitHub tags."
        find_prev_version_from_git_tags prev_version "$url" "tags/v"
        declare -g ${variable_name}="${prev_version}"
    else
        echo -e "\nAttempting to find latest version using GitHub Api."
        version=$(echo "$output" | jq -r '.tag_name')
        declare -g ${variable_name}="${version#v}"
    fi  
    echo "${variable_name}=${!variable_name}"
}

get_github_api_repo_url() {
    local url=$1
    echo "${url/https:\/\/github.com/https:\/\/api.github.com\/repos}/releases/latest"
}

install_previous_version() {
    given_version=$1
    requested_version=${!given_version}
    local URL=$2
    local mode=$3
    INSTALLER_FN=$4
    local REPO_URL=$(get_github_api_repo_url "$URL")
    local PKG_NAME=$(get_pkg_name "${given_version}")
    echo -e "\n(!) Failed to fetch the latest artifacts for ${PKG_NAME} v${requested_version}..."
    get_previous_version "$URL" "$REPO_URL" requested_version $mode
    echo -e "\nAttempting to install ${requested_version}"
    declare -g ${given_version}="${requested_version#v}"
    $INSTALLER_FN "${!given_version}"
    echo "${given_version}=${!given_version}"
}

install_tfsec() {
    local TFSEC_VERSION=$1
    tfsec_filename="tfsec_${TFSEC_VERSION}_linux_${architecture}.tar.gz"
    curl -sSL -o /tmp/tf-downloads/${tfsec_filename} https://github.com/aquasecurity/tfsec/releases/download/v${TFSEC_VERSION}/${tfsec_filename}
}

try_install_tfsec_dummy_version() {
    mode=$1
    mkdir -p /tmp/tf-downloads
    cd /tmp/tf-downloads
    TFSEC_VERSION="1.28.XYZ"
    echo -e "\nInstalling TFSEC dummy version.." v${TFSEC_VERSION}
    tfsec_url='https://github.com/aquasecurity/tfsec'
    tfsec_filename="tfsec_${TFSEC_VERSION}_linux_${architecture}.tar.gz"
    echo "(*) Downloading TFSec... ${tfsec_filename}"
    install_tfsec "$TFSEC_VERSION"
    if grep -q "Not Found" "/tmp/tf-downloads/${tfsec_filename}"; then 
        install_previous_version TFSEC_VERSION $tfsec_url $mode "install_tfsec"
        tfsec_filename="tfsec_${TFSEC_VERSION}_linux_${architecture}.tar.gz"
    fi
    if [ "${TFSEC_SHA256}" != "dev-mode" ]; then
        if [ "${TFSEC_SHA256}" = "automatic" ]; then
            curl -sSL -o tfsec_SHA256SUMS https://github.com/aquasecurity/tfsec/releases/download/v${TFSEC_VERSION}/tfsec_${TFSEC_VERSION}_checksums.txt
        else
            echo "${TFSEC_SHA256} *${tfsec_filename}" > tfsec_SHA256SUMS
        fi
        sha256sum --ignore-missing -c tfsec_SHA256SUMS
    fi
    mkdir -p /tmp/tf-downloads/tfsec
    tar -xzf /tmp/tf-downloads/${tfsec_filename} -C /tmp/tf-downloads/tfsec
    chmod a+x /tmp/tf-downloads/tfsec/tfsec
    sudo mv -f /tmp/tf-downloads/tfsec/tfsec /usr/local/bin/tfsec
}

try_install_tfsec_dummy_version "mode1"

check "tfsec version as installed by test after fallbacking from the dummy version (mode 1: install using find_prev_version_from_git_tags)" tfsec --version

try_install_tfsec_dummy_version "mode2"

check "tfsec version as installed by test after fallbacking from the dummy version (mode 2: install using GitHub Api)" tfsec --version

# Report result
reportResults


================================================
FILE: .devcontainer/devcontainer.json
================================================
{
    "image": "mcr.microsoft.com/devcontainers/javascript-node:3-22",
    "features": {
        "ghcr.io/devcontainers/features/docker-in-docker:2": {}
    },
    "postCreateCommand": "npm install -g @devcontainers/cli",
    "hostRequirements": {
        "cpus": 4
    },
    "customizations": {
        "vscode": {
            "extensions": [
                "mads-hartmann.bash-ide-vscode"
            ]
        }
    }
}



================================================
FILE: .github/workflows/docker-in-docker-stress-test.yaml
================================================
name: "Stress test - Docker in Docker"
on:
  pull_request:
    paths:
      - 'src/docker-in-docker/**'
  workflow_dispatch:

jobs:
  test:
    strategy:
      matrix:
        test-pass: [ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50 ]
      fail-fast: false
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Install latest devcontainer CLI"
        run: npm install -g @devcontainers/cli

      - name: "Generating tests for 'docker-in-docker' which validates if docker daemon is running"
        run: devcontainer features test --skip-scenarios -f docker-in-docker -i mcr.microsoft.com/devcontainers/base:ubuntu .

  test-onCreate:
    strategy:
      matrix:
        test-pass: [ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50 ]
      fail-fast: false
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Install latest devcontainer CLI"
        run: npm install -g @devcontainers/cli

      - name: "Generating tests for 'docker-in-docker' which validates if docker daemon is available within 'onCreateCommand'"
        run: devcontainer features test -f docker-in-docker --skip-autogenerated --filter "docker_with_on_create_command"


================================================
FILE: .github/workflows/linter-automated.yaml
================================================
name: "CI - Shell Script Linter"
on:
  push:
    branches:
      - main
  pull_request:

jobs:
  shellchecker:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Shell Linter
      uses: azohra/shell-linter@v0.6.0
      with:
        path: "src/**/*.sh"
        severity: "error" # [style, info, warning, error]
      env:
        SHELLCHECK_OPTS: -e SC2072 # Acceptable use of decimal comparison


================================================
FILE: .github/workflows/linter-manual.yaml
================================================
name: "Manual - Shell Script Linter"
on:
  workflow_dispatch:
      inputs:
        path:
          description: "Path to the shell scripts to lint"
          required: true
          default: "src/**/*.sh"
        severity:
          description: "Minimum Severity (style, info, warning, error)"
          required: true
          default: "style"

jobs:
  shellchecker:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Shell Linter
      uses: azohra/shell-linter@v0.6.0
      with:
        path: ${{ github.event.inputs.path }}
        severity: ${{ github.event.inputs.severity }}
      env:
        SHELLCHECK_OPTS: -e SC2072 # Acceptable use of decimal comparison


================================================
FILE: .github/workflows/release.yaml
================================================
name: "Release dev container features"
on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  deploy:
    if: ${{ github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: "Publish"
        uses: devcontainers/action@v1
        with:
          publish-features: "true"
          base-path-to-features: "./src"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



================================================
FILE: .github/workflows/test-all.yaml
================================================
name: "CI - Test Features"
on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    continue-on-error: true
    strategy:
      matrix:
        features: [
            "anaconda",
            "aws-cli",
            "azure-cli",
            "common-utils",
            "conda",
            "desktop-lite",
            "docker-outside-of-docker",
            "docker-in-docker",
            "dotnet",
            "git",
            "git-lfs",
            "github-cli",
            "go",
            "hugo",
            "java",
            "kubectl-helm-minikube",
            "node",
            "nvidia-cuda",
            "oryx",
            "php",
            "powershell",
            "python",
            "ruby",
            "rust",
            "sshd",
            "terraform",
            "nix",
        ]
        baseImage:
          [
            "ubuntu:focal",
            "ubuntu:jammy",
            "debian:11",
            "debian:12",
            "mcr.microsoft.com/devcontainers/base:ubuntu",
            "mcr.microsoft.com/devcontainers/base:debian",
            "mcr.microsoft.com/devcontainers/base:noble"
          ]
    steps:
      - uses: actions/checkout@v4

      - name: "Install latest devcontainer CLI"
        run: npm install -g @devcontainers/cli

      - name: "Generating tests for '${{ matrix.features }}' against '${{ matrix.baseImage }}'"
        run: devcontainer features test  --skip-scenarios -f ${{ matrix.features }} -i ${{ matrix.baseImage }} .

  test-scenarios:
    runs-on: ubuntu-latest
    continue-on-error: true
    strategy:
      matrix:
        features: [
            "anaconda",
            "aws-cli",
            "azure-cli",
            "common-utils",
            "conda",
            "desktop-lite",
            "docker-outside-of-docker",
            "docker-in-docker",
            "dotnet",
            "git",
            "git-lfs",
            "github-cli",
            "go",
            "hugo",
            "java",
            "kubectl-helm-minikube",
            "node",
            "nvidia-cuda",
            "oryx",
            "php",
            "powershell",
            "python",
            "ruby",
            "rust",
            "sshd",
            "terraform",
            "nix",
        ]
    steps:
      - uses: actions/checkout@v4

      - name: "Install latest devcontainer CLI"
        run: npm install -g @devcontainers/cli

      - name: "Testing '${{ matrix.features }}' scenarios"
        run: devcontainer features test -f ${{ matrix.features }} --skip-autogenerated  .

  test-global:
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4

      - name: "Install latest devcontainer CLI"
        run: npm install -g @devcontainers/cli

      - name: "Testing global scenarios"
        run: devcontainer features test --global-scenarios-only .



================================================
FILE: .github/workflows/test-manual.yaml
================================================
name: "Manual - Test Features"
on:
  workflow_dispatch:
    inputs:
      features:
        description: "List of features to execute tests against"
        required: true
        default: "go dotnet"
      baseImage:
        description: "Base image"
        required: true
        default: "ubuntu:focal"
      logLevel:
        description: "Log Level (info/debug/trace)"
        required: true
        default: "info"

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Install latest devcontainer CLI"
        run: npm install -g @devcontainers/cli

      - name: "Testing '${{ github.event.inputs.features }}' against '${{ github.event.inputs.baseImage }}'"
        run: devcontainer features test --features ${{ github.event.inputs.features }} --base-image ${{ github.event.inputs.baseImage }} --log-level ${{ github.event.inputs.logLevel }} .



================================================
FILE: .github/workflows/test-pr.yaml
================================================
name: "PR - Test Updated Features"
on:
  pull_request:

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      features: ${{ steps.filter.outputs.changes }}
    steps:
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            anaconda: ./**/anaconda/**
            aws-cli: ./**/aws-cli/**
            azure-cli: ./**/azure-cli/**
            common-utils: ./**/common-utils/**
            conda: ./**/conda/**
            desktop-lite: ./**/desktop-lite/**
            docker-outside-of-docker: ./**/docker-outside-of-docker/**
            docker-in-docker: ./**/docker-in-docker/**
            dotnet: ./**/dotnet/**
            git: ./**/git/**
            git-lfs: ./**/git-lfs/**
            github-cli: ./**/github-cli/**
            go: ./**/go/**
            hugo: ./**/hugo/**
            java: ./**/java/**
            kubectl-helm-minikube: ./**/kubectl-helm-minikube/**
            node: ./**/node/**
            nvidia-cuda: ./**/nvidia-cuda/**
            oryx: ./**/oryx/**
            php: ./**/php/**
            powershell: ./**/powershell/**
            python: ./**/python/**
            ruby: ./**/ruby/**
            rust: ./**/rust/**
            sshd: ./**/sshd/**
            terraform: ./**/terraform/**
            nix: ./**/nix/**

  test:
    needs: [detect-changes]
    runs-on: ubuntu-latest
    continue-on-error: true
    strategy:
      matrix:
        features: ${{ fromJSON(needs.detect-changes.outputs.features) }}
        baseImage:
          [
            "ubuntu:focal",
            "ubuntu:jammy",
            "debian:11",
            "debian:12",
            "mcr.microsoft.com/devcontainers/base:ubuntu",
            "mcr.microsoft.com/devcontainers/base:debian",
            "mcr.microsoft.com/devcontainers/base:noble"
          ]
        exclude:
          - features: oryx
            baseImage: ubuntu:jammy
          - features: oryx
            baseImage: mcr.microsoft.com/devcontainers/base:ubuntu
          - features: docker-in-docker
            baseImage: mcr.microsoft.com/devcontainers/base:debian         
          - features: docker-outside-of-docker
            baseImage: mcr.microsoft.com/devcontainers/base:debian             
    steps:
      - uses: actions/checkout@v4

      - name: "Install latest devcontainer CLI"
        run: npm install -g @devcontainers/cli

      - name: "Generating tests for '${{ matrix.features }}' against '${{ matrix.baseImage }}'"
        run: devcontainer features test  --skip-scenarios -f ${{ matrix.features }} -i ${{ matrix.baseImage }} .

  test-scenarios:
    needs: [detect-changes]
    runs-on: devcontainer-image-builder-ubuntu
    continue-on-error: true
    strategy:
      matrix:
        features: ${{ fromJSON(needs.detect-changes.outputs.features) }}
    steps:
      - uses: actions/checkout@v4

      - name: "Install latest devcontainer CLI"
        run: npm install -g @devcontainers/cli

      - name: "Testing '${{ matrix.features }}' scenarios"
        run: devcontainer features test -f ${{ matrix.features }} --skip-autogenerated  .



================================================
FILE: .github/workflows/update-aws-cli-completer-scripts.yml
================================================
name: "Updates vendor 'aws_bash_completer' and 'aws_zsh_completer.sh' scripts"
on:
  workflow_dispatch:
  schedule:
  - cron: '0 0 * * 0'  # Runs every Sunday at midnight UTC (adjust as needed)

jobs:
  fetch-latest-aws-completer-scripts:
    runs-on: ubuntu-latest
    environment: documentation # grants access to secrets.PAT, for creating pull requests
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4

      - name: Run fetch-latest-completer-scripts.sh
        run: src/aws-cli/scripts/fetch-latest-completer-scripts.sh

      - name: Create a PR for completer scripts
        id: push_image_info
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        run: |
          set -e
          echo "Start."

          # Configure git and Push updates
          git config --global user.email github-actions@github.com
          git config --global user.name github-actions
          git config pull.rebase false

          branch=automated-script-update-$GITHUB_RUN_ID
          git checkout -b $branch
          message='[Updates] Automated vendor 'aws-cli' completer scripts'

          # Add / update and commit
          git add src/aws-cli/scripts/vendor/aws_bash_completer
          git add src/aws-cli/scripts/vendor/aws_zsh_completer.sh

          git commit -m 'Automated completer scripts update' || export NO_UPDATES=true

          # Bump version and push
          if [ "$NO_UPDATES" != "true" ] ; then
              echo "$(jq --indent 4 '.version = (.version | split(".") | map(tonumber) | .[2] += 1 | join("."))' src/aws-cli/devcontainer-feature.json)"  > src/aws-cli/devcontainer-feature.json
              git add src/aws-cli/devcontainer-feature.json

              git commit -m 'Bump version'
              git push origin "$branch"
              gh api \
                --method POST \
                -H "Accept: application/vnd.github+json" \
                /repos/${GITHUB_REPOSITORY}/pulls \
                -f title="$message" \
              -f body="$message" \
              -f head="$branch" \
              -f base="$GITHUB_REF_NAME"
          fi



================================================
FILE: .github/workflows/update-documentation.yml
================================================
name: "Update Documentation"
on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  generate:
    runs-on: ubuntu-latest
    environment: documentation
    permissions:
      contents: write
      pull-requests: write
    if: "github.ref == 'refs/heads/main'"
    steps:
      - uses: actions/checkout@v4

      - name: Generate Documentation
        uses: devcontainers/action@v1
        with:
          generate-docs: "true"
          base-path-to-features: "./src"

      - name: Create a PR for Documentation
        id: push_image_info
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        run: |
          set -e
          echo "Start."

          # Configure git and Push updates
          git config --global user.email github-actions@github.com
          git config --global user.name github-actions
          git config pull.rebase false

          branch=automated-documentation-update-$GITHUB_RUN_ID
          git checkout -b $branch
          message='Automated documentation update'

          # Add / update and commit
          git add */**/README.md
          git commit -m 'Automated documentation update [skip ci]' || export NO_UPDATES=true

          # Push
          if [ "$NO_UPDATES" != "true" ] ; then
              git push origin "$branch"
              gh api \
                --method POST \
                -H "Accept: application/vnd.github+json" \
                /repos/${GITHUB_REPOSITORY}/pulls \
                -f title="$message" \
              -f body="$message" \
              -f head="$branch" \
              -f base='main'
          fi



================================================
FILE: .github/workflows/update-dotnet-install-script.yml
================================================
name: "Updates vendor 'dotnet-install' script"
on:
  workflow_dispatch:
  schedule:
  - cron: '0 0 * * 0'  # Runs every Sunday at midnight UTC (adjust as needed)

jobs:
  fetch-latest-dotnet-install:
    runs-on: ubuntu-latest
    environment: documentation # grants access to secrets.PAT, for creating pull requests
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4

      - name: Run fetch-latest-dotnet-install.sh
        run: src/dotnet/scripts/fetch-latest-dotnet-install.sh

      - name: Create a PR for dotnet-install.sh
        id: push_image_info
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        run: |
          set -e
          echo "Start."

          # Update dotnet-install for Oryx Feature as well
          cp src/dotnet/scripts/vendor/dotnet-install.sh src/oryx/scripts/vendor/dotnet-install.sh

          # Configure git and Push updates
          git config --global user.email github-actions@github.com
          git config --global user.name github-actions
          git config pull.rebase false

          branch=automated-script-update-$GITHUB_RUN_ID
          git checkout -b $branch
          message='[Updates] Automated vendor 'dotnet-install' script'

          # Add / update and commit
          git add src/dotnet/scripts/vendor/dotnet-install.sh
          git add src/oryx/scripts/vendor/dotnet-install.sh

          git commit -m 'Automated dotnet-install script update' || export NO_UPDATES=true

          # Bump version and push
          if [ "$NO_UPDATES" != "true" ] ; then
              echo "$(jq --indent 4 '.version = (.version | split(".") | map(tonumber) | .[2] += 1 | join("."))' src/dotnet/devcontainer-feature.json)"  > src/dotnet/devcontainer-feature.json
              git add src/dotnet/devcontainer-feature.json

              echo "$(jq --indent 4 '.version = (.version | split(".") | map(tonumber) | .[2] += 1 | join("."))' src/oryx/devcontainer-feature.json)"  > src/oryx/devcontainer-feature.json
              git add src/oryx/devcontainer-feature.json

              git commit -m 'Bump version'
              git push origin "$branch"
              gh api \
                --method POST \
                -H "Accept: application/vnd.github+json" \
                /repos/${GITHUB_REPOSITORY}/pulls \
                -f title="$message" \
              -f body="$message" \
              -f head="$branch" \
              -f base="$GITHUB_REF_NAME"
          fi



================================================
FILE: .github/workflows/validate-metadata-files.yml
================================================
name: "Validate devcontainer-feature.json files"
on:
  workflow_dispatch:
  pull_request:

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Validate devcontainer-feature.json files"
        uses: devcontainers/action@v1
        with:
          validate-only: "true"
          base-path-to-features: "./src"


